{"meta":{"title":"Wicksome Blog","subtitle":null,"description":null,"author":"Yeongjun Kim","url":"https://wicksome.github.io"},"pages":[{"title":"Hello World(and MD Test)","date":"2017-04-28T07:56:46.000Z","updated":"2017-04-28T07:58:28.000Z","comments":true,"path":"md-test/index.html","permalink":"https://wicksome.github.io/md-test/index.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 预处理器很强大，但它只是编写 CSS 的辅助工具。出于对扩展和维护等方面的考虑，在大型项目中有必要使用预处理器构建 CSS；但是对于小型项目，原生的 CSS 可能是一种更好的选择。不要肆意使用预处理器！ Advertisement pica - high quality and fast imageresize in browser. babelfish - developer friendlyi18n with plurals support and easy syntax. You will like those projects! h1 Headingh2 Headingh3 Headingh4 Headingh5 Headingh6 HeadingHorizontal Rules Typographic replacementsEnable typographer option to see result. (c) (C) (r) (R) (tm) (TM) (p) (P) +- test.. test… test….. test?….. test!…. !!!!!! ???? ,, – — “Smartypants, double quotes” and ‘single quotes’ EmphasisThis is bold text This is bold text This is italic text This is italic text Strikethrough Blockquotes Blockquotes can also be nested… …by using additional greater-than signs right next to each other… …or with spaces between arrows. ListsUnordered Create a list by starting a line with +, -, or * Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Very easy! Ordered Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa You can use sequential numbers… …or keep all the numbers as 1. Start numbering with offset: foo bar CodeInline code Indented code // Some comments line 1 of code line 2 of code line 3 of code Block code “fences” Sample text here... Syntax highlighting var foo = function (bar) &#123; return bar++;&#125;;console.log(foo(5)); Tables Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Right aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Linkslink text link with title Autoconverted link https://github.com/nodeca/pica (enable linkify to see) Images Like links, Images also have a footnote style syntax With a reference later in the document defining the URL location: PluginsThe killer feature of markdown-it is very effective support ofsyntax plugins. see how to change output with twemoji. Subscript / Superscript 19th H2O \\++Inserted text++ FootnotesFootnote 1 link[1]. Footnote 2 link[3]. Duplicated footnote reference[4]. AbbreviationsThis is HTML abbreviation example. It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on. *[HTML]: Hyper Text Markup Language Custom containers::: tip here be dragons test ::: 1.basic footnote content ↩3.paragraph ↩4.footnote content with some markdown ↩st=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something...|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(document.getElementById(\"flowchart-0-options\").value); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks!{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(document.getElementById(\"sequence-0-options\").value); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);"}],"posts":[{"title":"Factory Method Pattern","slug":"factory-method-pattern","date":"2017-04-26T04:32:16.000Z","updated":"2017-04-28T10:24:30.000Z","comments":true,"path":"2017/04/26/factory-method-pattern/","link":"","permalink":"https://wicksome.github.io/2017/04/26/factory-method-pattern/","excerpt":"[GOF{kr}:156] - 팩토리 메서드 GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015. 정의의도객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다. 구조 활용성 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때","text":"[GOF{kr}:156] - 팩토리 메서드 GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015. 정의의도객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다. 구조 활용성 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때 예제 방법 1) 추상 클래스 방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern 방법 3) Lazy Initialization 기법 방법 4) 템플릿 활용 참고 예제예를 들어 다양한 종류의 문서를 표현하는 응용프로그램 프레임워크가 있다. 이를 위해서는 일단 두 개의 큰 추상화가 필요하다. 하나는 Creator(응용프로그램) 추상 클래스이고, 다른 하나는 Product(문서) 추상 클래스(혹은 인터페이스)이다.Creator 클래스는 문서의 인스턴스를 ++언제++ 만들지는 알지만, ++어떤 문서++를 만들어야 하는지는 알지 못한다. Product 클래스가 추상 클래스이기 때문에 인스턴스를 가질 수 없기 때문이다. abstract class Creator &#123; public Product newProduct() &#123; return createProduct(); &#125; public abstract Product createProduct(); // factory method&#125;interface Product &#123;&#125; 팩토리 메서드 패턴은 이런 문제에 대한 해법을 제시한다. Document의 서브클래스 중 어느 것을 생성해야 하는지에 대한 정보를 캡슐화하고, 그것을 프레임워크에서 떼어낸다. public class TextProduct implements Product &#123;&#125;public class PhotoProduct implements Product &#123;&#125; TextProduct 클래스와 PhotoProduct 클래스를 팩토리 메서드 패턴을 활용하여 생성한다면 아래와 같은 방법이 있다. 방법 1) 추상 클래스사용자는 특정 응용프로그램에 종속적인 구현을 위해서 두 클래스의 서브 클래스를 정의할 수 있다. Creator 클래스는 Product 객체를 관리하는 책임을 맡고 있으며, 필요에 따라 문서를 생성할 수도 있다. // factory pattern example with abstract classCreator textCreator = new TextCreator();Product p1 = textCreator.newProduct();Creator photoCreator = new PhotoCreator();Product p2 = photoCreator.newProduct(); public class TextCreator extends Creator &#123; @Override public Product createProduct() &#123; return new WordProduct(); &#125;&#125;public class PhotoCreator extends Creator &#123; @Override public Product createProduct() &#123; return new PhotoProduct(); &#125;&#125; public class TextProduct implements Product &#123;&#125;public class PhotoProduct implements Product &#123;&#125; 방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern팩토리 메서드가 매개변수를 받아서 어떤 종류의 제품을 생성할지 만드는 방법도 있다. (추상 팩토리 패턴은 팩토리 메서드를 이용해서 구현할 때가 많다) // Factory pattern example using argumentProduct p1 = Creator1.create(ProductType.TEXT);Product p2 = Creator1.create(ProductType.PHOTO); public enum ProductType &#123; TEXT, PHOTO&#125; public class Creator &#123; static public Product create(ProductType type) &#123; switch (type) &#123; case TEXT: return new ExcelProduct(); case PHOTO: return new ImageProduct(); default: return null; &#125; &#125;&#125; 방법 3) Lazy Initialization 기법인스턴스화하는 접근자 메서드를 통해서만 인스턴스에 접근하는 방법으로, 생성자에서 아무 의미 없는 값으로 인스턴스에 대한 매개변수를 초기화하고, 접근자 메서드가 인스턴스를 반환하도록 할 수 있다. 생성자가 초기화 시키는 것이 아니라 필요한 시점에서 초기화를 수행하기 때문에 이런 기법을 Lazy Initialization이라고 한다. // factory pattern with lazy initializationTextCreator textCreator = new TextCreator();List collection = textCreator.newCollection(); public class TextCreator extends Creator &#123; @Override protected List createCollection() &#123; return new ArrayList&lt;TextProduct&gt;(); &#125;&#125; public abstract class Creator &#123; private List&lt;Product&gt; collection = null; public List newCollection() &#123; // lazy initialization if (collection == null) &#123; collection = createCollection(); &#125; return collection; &#125; // factory method abstract protected List createCollection();&#125; 방법 4) 템플릿 활용팩토리 메서드를 사용하면 생길 수 있는 문제점 중 하나는 Product 클래스 하나를 추가하려 할 때마다 Creator 클래스를 서브클래싱해야 한다는 점이다(방법 1). 이로써 클래스 계통의 부피가 확장되는 문제가 생길 수 있다. 이런 문제를 해결할 수 있는 방법 중 하나는 Creator 클래스를 상속받는 제네릭 클래스를 정의하고 Product 클래스로 매개변수화되도록 만드는 것이다. // factory pattern example whti templateStandardCreator&lt;WordProduct&gt; wordProductCreator = new StandardCreator&lt;&gt;(WordProduct.class);Product p1 = wordProductCreator.newProduct();StandardCreator&lt;ImageProduct&gt; imageProductCreator = new StandardCreator&lt;&gt;(ImageProduct.class);Product p2 = imageProductCreator.newProduct(); /** * Creator Template * @param &lt;T&gt; product type */public class StandardCreator&lt;T extends Product&gt; extends Creator &#123; private Class&lt;T&gt; cls; public StandardCreator(Class&lt;T&gt; cls) &#123; this.cls = cls; &#125; @Override public Product createProduct() &#123; T product = null; try &#123; product = cls.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return product; &#125;&#125; 참고Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다. 위키백과팩토리 메서드 패턴 st=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something...|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(document.getElementById(\"flowchart-0-options\").value); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks!{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(document.getElementById(\"sequence-0-options\").value); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wicksome.github.io/tags/java/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://wicksome.github.io/tags/design-pattern/"},{"name":"creational pattern","slug":"creational-pattern","permalink":"https://wicksome.github.io/tags/creational-pattern/"}]},{"title":"Effective Java 2장 - 객체 생성과 삭제","slug":"2-creating-and-destroying-objects","date":"2017-04-24T13:31:52.000Z","updated":"2017-04-28T10:24:39.000Z","comments":true,"path":"2017/04/24/2-creating-and-destroying-objects/","link":"","permalink":"https://wicksome.github.io/2017/04/24/2-creating-and-destroying-objects/","excerpt":"객체의 생성과 삭제 규칙 1. 생성자 대신 static factory 메서드 사용을 고려하자규칙 2. 생성자의 매개변수가 많을 때는 builder를 고려하자규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라규칙 5. 불필요한 객체는 만들지 말라규칙 6. 유효기간이 지난 객체 참조는 폐기하라규칙 7. 종료자 사용을 피하라","text":"객체의 생성과 삭제 규칙 1. 생성자 대신 static factory 메서드 사용을 고려하자규칙 2. 생성자의 매개변수가 많을 때는 builder를 고려하자규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라규칙 5. 불필요한 객체는 만들지 말라규칙 6. 유효기간이 지난 객체 참조는 폐기하라규칙 7. 종료자 사용을 피하라 규칙 1. 생성자 대신 static factory method 사용을 고려하자클래스를 통해 객체를 만드는 방법 Constructor Static factory method(Design Patterns에 나오는 [팩토리 메서드 패턴][dp-factory-method]과 다르다.) e.g. Static factory method \"Static factory method\"public class Boolean &#123; public static final Boolean TRUE; public static final Boolean FALSE; private boolean value; static &#123; TRUE = new Boolean(true); FALSE = new Boolean(false); // Q. static 초기화 블록 vs 선언과 동시에 생성 // A. 초기화 블록은 클래스 초기화 될 떄 수행하고, 동시 생성은 언제? &#125; private Boolean(boolean b) &#123; this.value = b; &#125; private Boolean(String str) &#123; this.value = \"true\".equalsIgnoreCase(str); &#125; // Q. str.equalsIgnoreCase(\"true\") 를 안쓰는 이유 // A. str이 null이면 NullPointException 발생 // Static factory method public static Boolean valueOf(boolean b) &#123; return b ? Boolean.TRUE : Boolean.FALSE; &#125; ...&#125; boolean b = (boolean)Boolean.TRUE; // unboxingBoolean b = (Boolean)true; // boxingBoolean b = true; // auto boxingBoolean b = Boolean.valueOf(true); public으로 선언된 생성자 대신 Static factory method를 제공하는 방법의 장단점은 아래와 같다. 장점package java.util;public class Collections &#123; // 3-3 private Collections() &#123;&#125; // 2-2(Non-instantiable class) public static final Map EMPTY_MAP = new EmptyMap&lt;&gt;(); // 2-1, 2-2(Singleton) public static final &lt;K,V&gt; Map&lt;K,V&gt; emptyMap() &#123; // 1, 3-2, 4 return (Map&lt;K,V&gt;) EMPTY_MAP; &#125; private static class EmptyMap&lt;K,V&gt; // 3-1 extends AbstractMap&lt;K,V&gt; implements Serializable &#123; /* ... */ &#125;&#125; public interface Map&lt;K,V&gt; &#123;/* ... */&#125;public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;/* ... */&#125; // 3-3 이해하기 쉬운 이름의 메서드를 생성자로 사용할 수 있다(가독성). 클래스의 인스턴스를 생성하는데 있어서 매개변수의 타입과 갯수로 구별하는 것보단 잘 지은 이름이 더 파악하기 쉽다. 호출할 때마다 인스턴스화하지 않아도 된다. 만든 객체를 캐시cache 해놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수 있다. Boolean.value(boolean)는 이 기법을 활용한 좋은 사례로 [Flyweight 패턴][dp-flyweight]과 유사하다. 동일한 객체가 요청되는 일이 잦고, 특히 객체를 만드는 비용이 클 때 적용하면 성능을 크게 개선할 수 있다. 같은 객체를 반복해서 반환할 수 있다. &gt; 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. 그런 기능을 갖춘 클래스를 *개체 통제 클래스&lt;sub&gt;instance-controlled class&lt;/sub&gt;*라고 부른다. 개체 통제 클래스를 작성하는 이유는 아래와 같다. - [Singleton pattern](#item3) 적용 - [Non-instantiable class](#item4) 생성 가능(e.g. Utility class) public class UtilityClass &#123; private UtilityClass() &#123; throw new AssertionError(); &#125;&#125; - [불변 클래스](#item15) - `equals()` 대신 `==` 연산자 사용 가능 - [enum](#item30)이 이 기법을 사용 public class Complex &#123; private final double re; private final double im; private Complex(double re, double im) &#123; this.re = re; this.im = im; &#125; public static Complex valueOf(double re, double im) &#123; return new Complex(re, im); &#125;&#125; 자신의 인스턴스만 반환하는 생성자와는 달리, 서브타입 객체도 반환 가능하다. “public으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다. 그러면 구현 세부사항을 감출 수 있으므로 아주 간결한 API가 가능하다.” “이 기법은 인터페이스 기반 프레임워크(interface-based framework) 구현에 적합한데, 이 프레임워크에서 인터페이스는 정적 팩터리 메서드의 반환값 자료형으로 이용된다.” “관습상 반환값 자료형이 Type이라는 이름의 인터페이스인 정적 팩터리 맥서드를 Types라는 이름의 객체 생성 불가능 클래스안에 둔다.” public interface Fruit &#123; String getName();&#125;public class Fruits &#123; private Fruits() &#123;&#125; public static Fruit getBanana() &#123; return new Banana(); &#125; public static Fruit getApple() &#123; return new Apple(); &#125; private static class Apple implements Fruit &#123; @Override public String getName() &#123; return \"apple\"; &#125; &#125; private static class Banana implements Fruit &#123; @Override public String getName() &#123; return \"banana\"; &#125; &#125;&#125; @Testpublic void main() &#123; Fruit apple = Fruits.getApple(); apple.getName();&#125; 제네릭 클래스의 인스턴스를 생성하는 코드를 간결하게 해준다. static 팩토리 메서드를 사용하면 컴파일러가 타입 추론(type inference)으로 해결할 수 있다. // beforeMap&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;String, List&lt;String&gt;&gt;();// after: 1.6 버전public static &lt;K, V&gt; HashMap&lt;K, V&gt; newInstance() &#123; return new HashMap&lt;K, V&gt;();&#125;Map&lt;String, List&lt;String&gt;&gt; m = HahsMap.newInstance();// after: 1.7// &lt;&gt;(다이아몬드) 연산자 추가Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;&gt;(); java.utils.Collections 클래스에는 Static factory method의 장점이 대부분 적용되어 있다. 단점 Static factory method만 있는 클래스는 public이나 protected로 선언된 클래스가 없으므로 하위 클래스를 만들 수 없다. public class Collections &#123; Collections() &#123;&#125;&#125;// inheritancepublic class CustomCollections extends Collections &#123; public CustomCollections() &#123; super(); // 불가능 &#125;&#125; 그러므로, Composition을 사용한다. // compositionpublic class CustomCollections &#123; private Collections collections;&#125; 상속을 사용하는 경우: is-a 관계 컴포지션을 사용하는 경우: has-a 관계 다른 Static factory method와 쉽게 구별할 수 없다. API 문서에 메서드와 생성자가 분리되어 있지만, static 팩토리 메서드는 다른 메서드와 섞여 잘 구분되지 않는다. 그래서 컨벤션을 정하여 보다 구별하기 쉽게 한다. valueOf: 자신의 매개변수와 같은 값을 갖는 인스턴스를 반환 of: valueOf 줄인 형태, EnumSet에서 사용 getInstance: 매개변수에 맞는 인스턴스 반환, 싱글톤인 경우 하나의 인스턴스 반환 newInstance: 새로운 인스턴스 반환 getType: getInstance와 유사하나 팩토리 메서드가 다른 클래스에 있을 때 사용. 여기서 Type은 팩토리 메서드에서 반환되는 객체의 타입을 나타낸다. newType: getType와 같음(?) [🔝 위로 이동][top] 규칙 2. 생성자의 매개변수가 많을 때는 빌더(builder)를 고려하자선택적 인자가 많을 때 객체를 생성하는 방법 세 가지. 방법 1) 점층적 생성자 패턴(telescoping constructor pattern) Bad Practice 👎 이 방법은 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 받는 생성자를 추가하는 것이다. 객체를 생성할 때는 설정하려는 인자 갯수에 맞는 생성자를 골라 호출한다. 문제점 설정할 필요가 없는 필드에도 인자를 전달해야 해야 한다. 인자 수가 늘어날수록 가독성이 떨어진다. Code public class Person &#123; private final String name; // 필수 private final int age; // 필수 private final String mail; private final String city; private final String state; public Person(String name, int age) &#123; this(name, age, \"\"); &#125; public Person(String name, int age, String mail) &#123; this(name, age, mail, \"\"); &#125; public Person(String name, int age, String mail, String city) &#123; this(name, age, mail, city, \"\"); &#125; public Person(String name, int age, String mail, String city, String state) &#123; this.name = name; this.age = age; this.mail = mail; this.city = city; this.state = state; &#125;&#125; Usage Person me = new Person(\"yeongjun.kim\", \"27\");Person me = new Person(\"yeongjun.kim\", \"27\", \"opid911@gmail.com\"); 방법 2) JavaBeans 패턴 Bad Practice 👎 인자 없는 생성자를 호출하여 객체를 만들고, setter로 값 설정하는 방법. 객체 생성도 쉽고, 가독성도 좋다. 문제점 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성이 일시작으로 깨질 수 있다. 변경 불가능 클래스를 만들 수 없다. 해결하기 위해서 추가 구현할 코드가 많아진다. Code @Setterpublic class Person &#123; private String name; private int age; private String mail; private String city; private String state; public Person() &#123;&#125;&#125; Usage Person me = new Person();me.setName(\"yeongjun.kim\");me.setAge(27); 방법 3) Builder 패턴[↩︎][dp-builder] Good Practice 👍 필수 인자들을 생성자(또는 정적 팩터리 메서드)에 전달하여 빌더 객체를 만들고, 선택적 인자들을 추가한 뒤, 마지막에 build()를 호출하여 Immutable 객체를 만드는 방법. Code public class Person &#123; private final String name; private final int age; private final String mail; private final String city; private final String state; // 빌더 객체 public static class Builder &#123; // 필수 인자 private final String name; private final String age; // 선택적 인자 - 기본값으로 초기화 private final String mail = \"\"; private final String city = \"\"; private final String state = \"\"; public Builder(String of, int age) &#123; this.name = name; this.age = age; &#125; public Builder mail(String mail) &#123; this.mail = mail; return this; &#125; public Builder city(String city) &#123; this.city = city; return this; &#125; public Builder state(String state) &#123; this.state = state; return this; &#125; public Person build() &#123; return new Person(this); &#125; &#125; private Person(Builder builder) &#123; this.name = name; this.age = age; this.mail = mail; this.city = city; this.state = state; &#125;&#125; Usage Person me = Person.Builder(\"yeongjun.kim\", 27) .mail(\"opid911@gmail.com\") .build(); 빌더 클래스(Builder)는 빌더가 만드는 객체 클래스(Person)의 정적 맴버 클래스로 정의한다(규칙 22). public class Person &#123; public static class Builder &#123; ... &#125;&#125; 불변식을 적용할 수 있으며, build()에서 불변식이 위반되었는지 검사할 수 있다. public class Person &#123; public static class Builder &#123; ... public Person build() &#123; Person result = new Person(this); if(/* result의 값 검사 */) &#123; throw new IllegalStateException(/* 위반 원인 */); &#125; return result; &#125; &#125;&#125; 빌더 객체에서 실제 객체로 인자가 복사된 다음에 불변식들을 검사할 수 있다는 것, 그리고 그 불변식을 빌더 객체의 필드가 아니라 실제 객체의 필드를 두고 검사할 수 있다는 것은 중요하다(규칙 39). 불변식을 위반한 경우, build()는 IllegalStateException을 던져야 한다(규칙 60). 예외 객체를 살펴보면 어떤 불변식을 위반했는지 알아낼 수도 있어야 한다(규칙 63). cf. 불변식을 강제하는 방법 불변식이 적용될 값 전부를 인자로 받는 setter를 정의하는 방법. setter는 불변식이 만족하지 않으면 IllegalArgumentException을 던짐. build()가 호출되기 전에 불변식을 깨뜨리는 인자가 전달되었다는 것을 신속하게 알 수 있는 장점. public class Person &#123; ... public static class Builder &#123; public Builder setNameAndAge(String name, int ate) &#123; if(name == null) &#123; throw new IllegalArgumentException(); &#125; return this; &#125; ... public Person build() &#123; return new Person(this); &#125; &#125; ...&#125; 메서드마다 하나씩, 필요한 만큼 varargs 인자를 받을 수 있다. public class Person &#123; public static class Builder &#123; public Builder names(String... names) &#123; this.names = names; return this; &#125; public Builder foramily(String... names) &#123; this.farther = names[0]; this.marther = names[1]; return this; &#125; &#125; ...&#125; 유연하다. (e.g. 객체가 만들어질 때마다 자동적으로 증가하는 일련번호 같은 것을 채울 수 있다) 인자가 설정된 빌더는 훌륭한 [Abstract Factory][dp-abstract-factory]다. JDK1.5 이상을 사용하는 경우, 제네릭 자료형 하나면 어떤 자료형의 객체를 만드는 빌더냐의 관계 없이 모든 빌더에 적용할 수 있다. public interface Builder&lt;T&gt; &#123; public T build();&#125; public class Person &#123; public static class Builder implements Builder&lt;Person&gt; &#123; ... public Person build() &#123; return new Person(this); &#125; &#125;&#125; e.g. Code at package java.util.stream Stream.builder().add(1).add(2).add(3).build(); 빌더 객체를 인자로 받는 메서드는 보통 한정적 와일드카드 자료형bounded wildcard type을 통해 인자의 자료형을 제한한다(규칙 28). Tree buildTree(Builder&lt;? extends Node&gt; nodeBuilder) &#123;...&#125; 자바가 제공하는 추상적 팩토리로는 Class 객체가 있으며, 이 객체의 newInstance() 가 build 메서드 구실을 한다. 하지만, newInstance()는 항상 무인자 생성자를 호출하려 하는데, 문제는 그런 생성자가 없을 수도 있다는 것. TO-DO 문제점 빌더 객체를 만드는 오버헤드가 문제가 될 수 있다(성능이 중요한 상황). 그러니 인자 갯수가 통제할 수 없을 정도로 많아지만 빌더 패턴을 적용하자. 요약빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특시 대부분의 인자가 선택적 인자인 상황에 유용하다. cf. Code with Lombok - 정적 팩터리 메서드로 구현 @Value // immutable(private, final 적용)@Builderpublic class Person &#123; String name; int age; String mail; String city; String state;&#125; [🔝 위로 이동][top] 규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라 싱글턴은 객체를 하나만 만들 수 있는 클래스다. singleton 구현 방법public static final 상수(before JDK 1.5)public class Single &#123; public static final Single INSTANCE = new Single(); private Single() &#123; ... &#125;&#125; 문제점 리플렉션으로 private 생성자 호출 가능 생성자에서 에러날 경우 예외처리 불가능 -&gt; static 초기화 블럭으로 해결 가능 static factory 메서드(before JDK 1.5)public class Single &#123; private static final Single INSTANCE = new Single(); private Single() &#123; ... &#125; public static Single getInstance() &#123; return INSTANCE; &#125;&#125; 문제점 리플렉션으로 private 생성자 호출 가능 위 두 방법에서 직렬화가능 클래스로 만드려면 클래스 선언에 implements Serializable을 추가하는 것으로는 부족하다. 클래스 선언에 implements Serializable 추가 모든 객체 필드에 transient 선언 readResolve() 추가 private Object readResolve() &#123; // 동일한 객체가 반환되도록 하는 동시에, // 가짜 객체는 gc가 처리하도록 만든다. return INSTANCE;&#125; thread safe하려면 synchronized 적용 public static synchronized Single getInstance() &#123; ... &#125; ``` ### Initialization on demand holder idiom- jvm 의 class loader의 매커니즘과 class의 load 시점을 이용하여 내부 class를 생성시킴으로 thread 간의 동기화 문제를 해결- lazy initialization```javapublic class Singleton &#123; private Singleton() &#123; &#125; private static class SingletonHolder &#123; public static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; enum을 이용하는 방법(after JDK 1.5)public enum Single &#123; INSTANCE; ...&#125; 직렬화 자동으로 처리된다. 리플렉션 공격에도 안전하다. Enum 생성은 Thread-safe하지만, 내부 메서드들은 Thread-safe를 보장하지 않는다. why? 선언된 상수 이외의 다른 객체는 존재할 수 없다는 확실한 보장이 생긴다(JVM이 해주는 보장). enum 타입은 Comparable 인터페이스, Serializable 인터페이스가 구현되어 있다. 참고Link java singleton pattern (싱글톤 패턴) - https://blog.seotory.com/post/2016/03/java-singleton-pattern 게으른 홀더를 통한 싱글턴의 동시성 문제 해결 (Initialization on demand holder idiom) - http://changsuk.me/?p=1433 Thread-safe Enum Singleton - http://stackoverflow.com/questions/28369025/thread-safe-enum-singleton serializable 객체의 내용을 파일에 저장하거나 네트워크로 전송하기 위해서 스트림으로 만드는 작업(바이트 단위로 변환) Serializable 인터페이스 구현 모든 필드 또한 Serializable 인터페이스 구현 제외하고자하는 필드는 transient example public class Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; SerializerTest test = new SerializerTest(); test.serialization(); test.deserialization(); &#125;&#125;class SerializerTest &#123; private String filePath = \"/Users/yeongjun/Desktop/test.ser\"; private User user; public void serialization() throws IOException &#123; user = new User(\"yj\", 26, \"pwd\"); FileOutputStream f = new FileOutputStream(filePath); ObjectOutputStream o = new ObjectOutputStream(f); // 직렬화 클래스 o.writeObject(user); // 파라미터로 넘긴 객체를 스트림으로 만들어서 출력하는 메서드 o.close(); &#125; public void deserialization() throws IOException, ClassNotFoundException &#123; FileInputStream f = new FileInputStream(filePath); ObjectInputStream o = new ObjectInputStream(f); // 역직렬화 클래스 user = (User)o.readObject(); // 입력된 스트림으로부터 객체를 만들어서 반환하는 메서드 o.close(); System.out.println(user.toString()); &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 1L; // 이건 왜? private String name; private int age; private transient String password; public User(String name, int age, String password) &#123; this.name = name; this.age = age; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;name='\" + name + '\\'' + \", age=\" + age + \", password='\" + password + \"\\'&#125;\"; &#125;&#125; [🔝 위로 이동][top] 규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라 생성자를 생략하면 컴파일러는 자동으로 인자없는 public 생성자를 만든다. 그러므로, 객체 생성을 막기 위해서 private 생성자를 추가한다. AssertionError()를 통해 혹시나 클래스내에서 생성자를 사용할 경우를 방지한다. public class Utils &#123; private Utils() &#123; throw new AssertionError(); &#125;&#125; cf. Code with Lombok 필드, 메서드를 static으로 변환 private 생성자 추가 @UtilityClasspublic class Utils &#123; private final int VERSION = 1; public void getVersion() &#123; return VERSION; &#125;&#125; 🔝 [위로 이동][top] 규칙 5. 불필요한 객체는 만들지 말라 변경 불가능(immutable) 객체는 언제나 재용사할수 있다.(규칙 15) Bad Practice 코드는 실행될 때마다 String 객체를 만드는 쓸데없는 짓을 한다. loop 도는 만큰 String 객체를 생성한다. Good Practices는 실행할 때마다 객체를 생성하지 않고, 동일한 String 객체를 사용한다. 같은 가상머신에서 실행되는 모든 코드가 해당 객체를 사용한다(JLS, 3.10.5). for(int i = 0; i &lt; 999999; i++) &#123; // Bad Practice System.out.println(new String(\"test\")); // Good Practice System.out.println(\"test\");&#125; Static Factory Method(규칙 1)를 이용하면 불필요한 객체 생성을 피할 수 있다. Boolean.valueOf(String) 변경 가능한 객체이지만 변경할 일이 없다면 재사용한다. AS-IS public class Person &#123; private final Date birthDate; public boolean isBabyBoomer() &#123; Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\")); gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0); Date boomStart = gmtCal.getTime(); gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0); Date boomEnd = gmtCal.getTime(); return birthDate.compareTo(boomStart) &gt;= 0 &amp;&amp; birthDate.compareTo(boomEnd) &lt; 0; &#125;&#125; TO-BE public class Person &#123; private final Date birthDate; private static final Date BOOM_START; private static final Date BOOM_END; static &#123; Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\")); gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0); BOOM_START = gmtCal.getTime(); gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0); BOOM_END = gmtCal.getTime(); &#125; public boolean isBabyBoomer() &#123; return birthDate.compareTo(BOOM_START) &gt;= 0 &amp;&amp; birthDate.compareTo(BOOM_END) &lt; 0; &#125;&#125; static initialzer을 하지않고 lazy initialization 기법을 사용할 수도 있다. 하지만, 추천하지 않는다. 구현이 복잡해질 뿐더러 TO-BE로 개선한 것 이상으로 성능을 높이기 어렵기 때문이다(규칙 55). 어댑터 TO-DO JDK 1.5 이후, 쓸데없는 객체 생성하는 방법 추가 - autoboxing public static void main(String[] args) &#123; Long sum = 0L; for (long i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sum += i; &#125;&#125; sum이 long이 아닌 Long으로 선언되어 있기 때문에 더해질때마다 객체가 생성된다(2^31개 생성). 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않도록 유의하라. 직접 관리하는 객체 풀을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다. 독자적으로 관리되는 객체풀을 만들면, 코드의 복잡성 메모리 요구량 증가 성능 떨어짐 사용해야할 상황: 데이터베이스 접속 비용이 큼 라이선스 정책에 따라 연결 수가 제한될 수 있음 규칙 39는 방어적 복사defensive copy에 관한 것. 규칙 5: “재사용이 가능하다면 새로운 객체는 만들지 말라” 규칙 39: “새로운 객체를 만들어야 한다면 기존 객체는 재사용하지 말라” 방어적 복사가 요구되는 상황에서 객체를 재사용하는 것은 (쓸데없이 같은 객체를 만드는) 비용보다 훨씬 높다는 것에 유의하자. 필요할 때 방어적 복사본을 만들지 못하면 버그나 보안 결함으로 이어진다. 쓸데 없는 객체들은 고작 코드 스타일과 성능에나 영향을 줄 뿐이다. // 방어적 복사 방법public Period(Date start, Date end) &#123; this.start = new Date(start.getTime()); this.end = new Date(end.getTime());&#125; [🔝 위로 이동][top] st=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something...|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(document.getElementById(\"flowchart-0-options\").value); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks!{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(document.getElementById(\"sequence-0-options\").value); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wicksome.github.io/tags/java/"},{"name":"effective java","slug":"effective-java","permalink":"https://wicksome.github.io/tags/effective-java/"}]}]}