{"meta":{"title":"Wicksome Blog","subtitle":null,"description":null,"author":"Yeongjun Kim","url":"https://wickso.me"},"pages":[{"title":"Hello World(and MD Test)","date":"2017-04-28T07:56:46.000Z","updated":"2017-05-02T13:30:34.000Z","comments":true,"path":"md-test/index.html","permalink":"https://wickso.me/md-test/index.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 预处理器很强大，但它只是编写 CSS 的辅助工具。出于对扩展和维护等方面的考虑，在大型项目中有必要使用预处理器构建 CSS；但是对于小型项目，原生的 CSS 可能是一种更好的选择。不要肆意使用预处理器！ Advertisement pica - high quality and fast imageresize in browser. babelfish - developer friendlyi18n with plurals support and easy syntax. You will like those projects! h1 Headingh2 Headingh3 Headingh4 Headingh5 Headingh6 HeadingHorizontal Rules Typographic replacementsEnable typographer option to see result. (c) (C) (r) (R) (tm) (TM) (p) (P) +- test.. test… test….. test?….. test!…. !!!!!! ???? ,, – — “Smartypants, double quotes” and ‘single quotes’ EmphasisThis is bold text This is bold text This is italic text This is italic text Strikethrough Blockquotes Blockquotes can also be nested… …by using additional greater-than signs right next to each other… …or with spaces between arrows. ListsUnordered Create a list by starting a line with +, -, or * Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Very easy! Ordered Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa You can use sequential numbers… …or keep all the numbers as 1. Start numbering with offset: foo bar CodeInline code Indented code // Some comments line 1 of code line 2 of code line 3 of code Block code “fences” Sample text here... Syntax highlighting var foo = function (bar) &#123; return bar++;&#125;;console.log(foo(5)); Tables Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Right aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Linkslink text link with title Autoconverted link https://github.com/nodeca/pica (enable linkify to see) Images Like links, Images also have a footnote style syntax With a reference later in the document defining the URL location: PluginsThe killer feature of markdown-it is very effective support ofsyntax plugins. see how to change output with twemoji. Subscript / Superscript 19th H2O \\++Inserted text++ FootnotesFootnote 1 link[1]. Footnote 2 link[3]. Duplicated footnote reference[4]. AbbreviationsThis is HTML abbreviation example. It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on. *[HTML]: Hyper Text Markup Language Custom containers::: tip here be dragons test ::: st=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something...|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob–&gt;Alice: I am good thanks!{“theme”:”simple”,”scale”:1,”line-width”:2,”line-length”:50,”text-margin”:10,”font-size”:12} var code = document.getElementById(“sequence-0-code”).value; var options = JSON.parse(document.getElementById(“sequence-0-options”).value); var diagram = Diagram.parse(code); diagram.drawSVG(“sequence-0”, options);1.basic footnote content ↩3.paragraph ↩4.footnote content with some markdown ↩"}],"posts":[{"title":"Template Method Pattern","slug":"template-method-pattern","date":"2017-05-02T03:57:22.000Z","updated":"2017-05-02T13:11:13.000Z","comments":true,"path":"2017/05/02/template-method-pattern/","link":"","permalink":"https://wickso.me/2017/05/02/template-method-pattern/","excerpt":"의도연산operation에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다. 구조 활용성 어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때 서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93][1] “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다. 서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.","text":"의도연산operation에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다. 구조 활용성 어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때 서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93][1] “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다. 서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다. 결과 템플릿 메서드는 코드 재사용을 위한 기본 기술이다(특히 클라스 라이브러리 구현 시 중요). 템플릿 메서드는 IoC(Inversion of Control, 제어 역전) 구조를 이끌어 낸다. 즉, 부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만 반대 방향의 호출은 안 된다.Don’t call us, we’ll call you. 할리우드 원칙(Hollywood principle) 템플릿 메서드는 여러 종류의 연산 중 하나를 호출한다. 구체 연산 AbstractClass 구체 연산 기본 연산 factory method hook operation: 필요하다면 서브클래스에서 활장할 수 있는 기본 행동을 제공하는 연산. 기본적으로 아무 내용도 정의하지 않는다. 구현 접근제어자를 이용한다. - 템플릿 메서드에서 호출하는 기본 연산들을 protected로 구현한다. 이렇게 하면 이 연산들은 템플릿 메서드만 호출할 수 있게 된다. 템플릿 메서드는 재정의하면 안되므로 맴버 함수로 만든다(final로 정의하면 재정의 불가능). 기본 연산의 수를 최소화한다. - 템플릿 메서드를 설계할 때 중요한 목표 중 하나는 서브클래스가 오버라이드해야 하는 연산의 수를 최소화하는 것이다. 재정의해야 하는 메서드가 많아질수록 사용자는 불편해진다. 네이밍 규칙을 만든다. - 재정의 연산에 접두어를 추가하여 식별이 잘되도록 할 수 있다. 예를 들어, 매킨토시 응용프로그램의 MapAPP프레임워크[App89][2]의 모든 템플릿 메서드는 Do-로 시작한다. DoCreateDocument, DoRead 예제문서 관리 응용프로그램이 새 문서를 만드는 경우로 예를 들어 보자. 모든 응용프로그램은 파일을 생성하기 전에 파일 존재 확인과 권한 확인을 하며, 특정 응용프로그램은 파일을 열기전에 로그를 출력해야 한다. 이런 경우에 openNewDocument() 템플릿 메서드를 사용할 수 있다. Application.java는 항상 확인해야할 연산(파일 존재 확인, 권한 확인)을 추상 메서드로 정의하고 템플릿 메서드에서 수행한다. Application에서 beforeCreateDocument()는 hook 연산으로 필요에따라 확장해서 사용 가능하다. 이렇게 함으로 추상 연산을 통해 알고리즘의 일부를 정의함으로써, 템플릿 메서드는 각 단계의 순서는 고정하되 각각의 서브클래스는 필요에 따라 이들 단계의 처리를 다양화시킬 수 있다. Application.java(AbstractClass) public abstract class Application &#123; public Document newDcument() &#123; return createDocument(); &#125; public abstract Document createDocument(); // factory method // template method final public Document openNewDocument(String fileName) &#123; if (!existDocument(fileName)) &#123; throw new IllegalStateException(\"The file doesn't exist: \" + fileName); &#125; if (!canOpenDocument(fileName)) &#123; throw new IllegalStateException(\"can't open the document: \" + fileName); &#125; beforeCreateDocument(); // hook 연산 Document document = createDocument(); // template method에서 factory method가 호출된다. document.setFileName(fileName); return document; &#125; protected abstract boolean existDocument(String fileName); protected abstract boolean canOpenDocument(String fileName); protected void beforeCreateDocument() &#123;&#125; // hook: 기본적으로 아무 내용도 정의하지 않는다.&#125; MyApplication.java(ConcreteClass) public class MyApplication extends Application &#123; private static final String BASE_PATH = \"/local/path/base\"; @Override public void beforeCreateDocument() &#123; System.out.println(\"create document\"); &#125; @Override public Document createDocument() &#123; return new WordDocument(); &#125; @Override protected boolean existDocument(String fileName) &#123; return (new File(BASE_PATH + fileName)).exists(); &#125; ...&#125; 아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다. [GOF{kr}:419] - 템플릿 메서드 GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015. 1.William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC ‘93), pages 66–73, Indianapolis, IN, February 1993. ↩2.Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994. ↩","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wickso.me/tags/java/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://wickso.me/tags/design-pattern/"},{"name":"befavioral pattern","slug":"befavioral-pattern","permalink":"https://wickso.me/tags/befavioral-pattern/"}]},{"title":"Factory Method Pattern","slug":"factory-method-pattern","date":"2017-04-26T04:32:16.000Z","updated":"2017-05-02T05:23:40.000Z","comments":true,"path":"2017/04/26/factory-method-pattern/","link":"","permalink":"https://wickso.me/2017/04/26/factory-method-pattern/","excerpt":"의도객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다. Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다. 위키백과팩토리 메서드 패턴 구조 활용성 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때","text":"의도객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다. Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다. 위키백과팩토리 메서드 패턴 구조 활용성 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때 예제예를 들어 다양한 종류의 문서를 표현하는 응용프로그램 프레임워크가 있다. 이를 위해서는 일단 두 개의 큰 추상화가 필요하다. 하나는 Creator(응용프로그램) 추상 클래스이고, 다른 하나는 Product(문서) 추상 클래스(혹은 인터페이스)이다.Creator 클래스는 문서의 인스턴스를 ++언제++ 만들지는 알지만, ++어떤 문서++를 만들어야 하는지는 알지 못한다. Product 클래스가 추상 클래스이기 때문에 인스턴스를 가질 수 없기 때문이다. abstract class Creator &#123; public Product newProduct() &#123; return createProduct(); &#125; public abstract Product createProduct(); // factory method&#125;interface Product &#123;&#125; 팩토리 메서드 패턴은 이런 문제에 대한 해법을 제시한다. Document의 서브클래스 중 어느 것을 생성해야 하는지에 대한 정보를 캡슐화하고, 그것을 프레임워크에서 떼어낸다. public class TextProduct implements Product &#123;&#125;public class PhotoProduct implements Product &#123;&#125; TextProduct 클래스와 PhotoProduct 클래스를 팩토리 메서드 패턴을 활용하여 생성한다면 아래와 같은 방법이 있다. 방법 1) 추상 클래스사용자는 특정 응용프로그램에 종속적인 구현을 위해서 두 클래스의 서브 클래스를 정의할 수 있다. Creator 클래스는 Product 객체를 관리하는 책임을 맡고 있으며, 필요에 따라 문서를 생성할 수도 있다. // factory pattern example with abstract classCreator textCreator = new TextCreator();Product p1 = textCreator.newProduct();Creator photoCreator = new PhotoCreator();Product p2 = photoCreator.newProduct(); public class TextCreator extends Creator &#123; @Override public Product createProduct() &#123; return new WordProduct(); &#125;&#125;public class PhotoCreator extends Creator &#123; @Override public Product createProduct() &#123; return new PhotoProduct(); &#125;&#125; public class TextProduct implements Product &#123;&#125;public class PhotoProduct implements Product &#123;&#125; 방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern팩토리 메서드가 매개변수를 받아서 어떤 종류의 제품을 생성할지 만드는 방법도 있다. (추상 팩토리 패턴은 팩토리 메서드를 이용해서 구현할 때가 많다) // Factory pattern example using argumentProduct p1 = Creator1.create(ProductType.TEXT);Product p2 = Creator1.create(ProductType.PHOTO); public enum ProductType &#123; TEXT, PHOTO&#125; public class Creator &#123; static public Product create(ProductType type) &#123; switch (type) &#123; case TEXT: return new ExcelProduct(); case PHOTO: return new ImageProduct(); default: return null; &#125; &#125;&#125; 방법 3) Lazy Initialization 기법인스턴스화하는 접근자 메서드를 통해서만 인스턴스에 접근하는 방법으로, 생성자에서 아무 의미 없는 값으로 인스턴스에 대한 매개변수를 초기화하고, 접근자 메서드가 인스턴스를 반환하도록 할 수 있다. 생성자가 초기화 시키는 것이 아니라 필요한 시점에서 초기화를 수행하기 때문에 이런 기법을 Lazy Initialization이라고 한다. // factory pattern with lazy initializationTextCreator textCreator = new TextCreator();List collection = textCreator.newCollection(); public class TextCreator extends Creator &#123; @Override protected List createCollection() &#123; return new ArrayList&lt;TextProduct&gt;(); &#125;&#125; public abstract class Creator &#123; private List&lt;Product&gt; collection = null; public List newCollection() &#123; // lazy initialization if (collection == null) &#123; collection = createCollection(); &#125; return collection; &#125; // factory method abstract protected List createCollection();&#125; 방법 4) 템플릿 활용팩토리 메서드를 사용하면 생길 수 있는 문제점 중 하나는 Product 클래스 하나를 추가하려 할 때마다 Creator 클래스를 서브클래싱해야 한다는 점이다(방법 1). 이로써 클래스 계통의 부피가 확장되는 문제가 생길 수 있다. 이런 문제를 해결할 수 있는 방법 중 하나는 Creator 클래스를 상속받는 제네릭 클래스를 정의하고 Product 클래스로 매개변수화되도록 만드는 것이다. // factory pattern example whti templateStandardCreator&lt;WordProduct&gt; wordProductCreator = new StandardCreator&lt;&gt;(WordProduct.class);Product p1 = wordProductCreator.newProduct();StandardCreator&lt;ImageProduct&gt; imageProductCreator = new StandardCreator&lt;&gt;(ImageProduct.class);Product p2 = imageProductCreator.newProduct(); /** * Creator Template * @param &lt;T&gt; product type */public class StandardCreator&lt;T extends Product&gt; extends Creator &#123; private Class&lt;T&gt; cls; public StandardCreator(Class&lt;T&gt; cls) &#123; this.cls = cls; &#125; @Override public Product createProduct() &#123; T product = null; try &#123; product = cls.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return product; &#125;&#125; 아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다. [GOF{kr}:419] - 템플릿 메서드 GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wickso.me/tags/java/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://wickso.me/tags/design-pattern/"},{"name":"creational pattern","slug":"creational-pattern","permalink":"https://wickso.me/tags/creational-pattern/"}]},{"title":"Java Generic","slug":"generic","date":"2016-04-12T07:40:01.000Z","updated":"2017-05-03T07:45:03.000Z","comments":true,"path":"2016/04/12/generic/","link":"","permalink":"https://wickso.me/2016/04/12/generic/","excerpt":"","text":"제네릭 프로그래밍 generic class, method// class public class Entry&lt;K, V&gt; { private K key; private V value; ... } Entry&lt;String, Integer&gt; entry = new Entry&lt;&gt;(...); // method public class Arrays { public &lt;T&gt; void swap(T[] array, int i, int j) { T tmp = array[i]; array[i] = array[j]; array[j] = tmp; } } – generic methodpublic static &lt;T&gt; void swap(T[] array, int i, int j) 타입 파라미터를 제어자와 반환타입 사이에 둔다 호출할 때는 명시하지 않아도 가능 컴파일러가 타입파라미터 추론 Arrays.&lt;String&gt;swap(friends, 0, 1); 원한다면 명시적으로 가능 문제 발생시 더 자세한 오류 메시지 – E? T? ?? E : Element T : Type V : Value K : Key ? : 와일드 카드 … – 기본 타입은 불가능Entry&lt;String, int&gt; // 불가능 타입 경계제네릭 클래스/메서드가 받는 타입 파라미터의 타입을 제한할 때 public status &lt;T extends AutoCloseable&gt; void closeAll(ArrayList&lt;T&gt; elems) { for (T elem : elems) { elem.close(); } } 다중 경계 지정 T extends Runable &amp; AutoCloseable – &lt;T extends AutoCloseable&gt; 요소타입이 AutoCloseable의 서브타입임을 보장한다. extends == 서브타입, 상속 X 기존에 사용하던 extends 키워드를 사용함 타입 가변성과 와일드카드 Employee의 서브클래스 객체로 구성된 배열을 사용하고자 할 때, public static void process(Employee[] staff) &#123;...&#125; 이때, Manager[]이 Employee[]의 서브타입이라면 process()에 전달할 수 있다. 이러한 동작을 공변성(covariance)라고 한다. 즉, 배열은 요소 타입과 같은 방식으로 변한다. 자바에서는 와일드카드로 메서드의 파라미터와 반환 타입이 변하는 방식을 지정. 이 메커니즘을 use-site variance(사용처 공변성)이라고 한다. – covarianceManager[] bosses1 = new Manager[10]; Employee[] empls1 = bosses1; // 공변성 empls1[0] = new Manager(); // p.169 // 런타임에서 ArrayStoreException을 던질 때 잡을 수 파악 자바의 모든 제네릭 타입은 불변(invariant) – But!ArrayList&lt;Manager&gt; bosses2 = new ArrayList&lt;&gt;(); ArrayList&lt;Employee&gt; empls2 = bosses2; // error 자바의 모든 제네릭 타입은 불변(invariant) ArrayList은 ArrayList의 서브타입이 아니다. – 서브타입 와일드카드 &lt;? extends Employee&gt; public statis void pringNames(ArrayList&lt;? extends Employee&gt; staff) &#123; for(Employee e : staff) &#123; System.out.println(e.getName()); &#125;&#125; ?는 Employee의 서브타입 – But!!Employee e = staff.get(0); // 가능 staff.add(new Manager(&quot;yj&quot;)); // 불가능, 컴파일 에러 ?는 어떤 서브클래스든 가르킬 수 있으므로 컴파일 오류 즉, ? extends Employee는 Employee로 변환할 수 있지만 어떤 것도 절대 ? extends Employee로 변환할 수 없다. ArrayList&lt;? extends Employee&gt;에서 읽을 수는 있지만 쓸 수는 없다. – 슈퍼타입 와일드카드 ? super Employee 함수형 객체의 파라미터로 유용 public interface Pridicate&lt;T&gt; &#123; boolean test(T arg); ...&#125; p.247 다시 볼것 super vs extends – 슈퍼타입 와일드카드 2PECS(Producer Extends Consumer Super)와일드카드와 관련해 PECS라는 약칭을 사용하기도 한다. 생산자에는 extends, 소비자에는 super를 사용한다는 의미이다. public void pushAll(Iterable&lt;? extends E&gt; src) { for (E e : src) { push(e); } } public void popAll(Collection&lt;? super E&gt; dst) { while(!isEmpty()) { dst.add(pop()); } } 예를 들어, Stack의 경우에 pushAll()의 src는 Stack에서 사용될 E 인스턴스를 생산하므로 extends, popAll()의 dst는 Stack으로부터 E 인스턴스를 소비하므로 super가 적합하다. (이펙티브자바 항목 28) – 타입 변수와 함께 사용하는 와일드카드 p.249 공부할 곳 – 경계 없는 와일드카드public static boolean hasNulls(ArrayList&lt;?&gt; elems) { for(Object e : elems) { if (e == null) return true; } return false; } 파라미터(ArrayList)의 타입 파라미터(?)가 중요하지 않을 때 제네릭 메서드보다 ArrayList&lt;?&gt;를 사용하는 것이 타당 – 와일드카드 캡처public static void swap(ArrayList&lt;?&gt; elems, int i, int j) { ? temp = elems.get(i); elems.set(i, elems.get(j)); elems.set(j, temp); } ?을 타입으로 사용할 수 없다. – 정상적인 코드public static void swap(ArrayList&lt;?&gt; elems, int i, int j) { swapHelper(elems, i, j); } private static &lt;T&gt; void swapHelper(ArrayList&lt;T&gt; elems, int i, int j) { T temp = elems.get(i); elems.set(i, elems.get(j)); elems.set(j, temp); } – why? 와일드카드 캡처라는 규칙 덕분에 가능 컴파일러는 ?를 모르지만, ?는 어떤 타입을 나타내므로 제네릭 메서드를 호출해도 된다. swapHelper 메서드의 타입파라미터 T는 와일드카드 타입을 캡처한다. API 사용자가 T보다 ?를 이해하는것이 쉽다. 자바 가상 머신에서의 제네릭 제네릭이 없던 시절에는 Object 타입으로 받았다. 이후 설계자들은 VM에서 타입을 지우는 구현 방식으로 기존 버전 클래스와 호환되게 했다. 그리고 점진적으로 제네릭으로 옮겨갔다. – 1. 타입소거제네릭을 정의하면 해당 타입은 raw 타입으로 컴파일된다. public class Entry { private Object key; private Object value; public Entry(Object key, Object value) { this.key = key; this.value = value; } ... } – 경계가 있는 타입변수의 경우첫 번째 경계로 교체된다. public class Entry&lt;K extends Comparable&lt;? super K&gt; &amp; Serializable, V extends Serializable&gt; 다음과 같이 교체 public class Entry{ private Comparable key; private Serializable value; ... – 2. 타입 변환 연산자 삽입 Entry의 객체로 생성할 경우 반드시 String, Integer가 전달되야 한다. 그렇지 않으면 컴파일 X 즉, getKey()는 String을 반환한다는 것을 보장받는다.(컴파일이 안되므로) – 2.1 타입 변환 연산자 삽입 타입 연산자(T), 제네릭, raw(Object)를 사용하여 컴파일된 경우(비검사 경고옵션으로) 다른 값이 들어갈 수 있다. 따라서 실행 시간에 안전성 검사를 해야 한다. Entry&lt;String, Integer&gt; entry = ...String key = entry.getKey(); 타입이 소거된 getKey()는 Object를 반환하므로 컴파일러는 다음과 같은 코드를 만들어낸다. String key = (String) entry.getKey(); – 3. bridge method 메서드 파라미터와 반환 타입을 소거할 때 때때로 컴파일러가 브릿지 메서드를 만들어내야 한다. 컴파일러가 raw로 만들었기 때문에 bridge method 생성 – examplepublic class WordList extends ArrayList&lt;String&gt; { public void add(String e) { return isBadWord(e) ? false : super.add(e); } ... } ... WordList words = ... ArrayList&lt;String&gt; strs = words; strs.add(&quot;JAVA&quot;); strs.add()에서 타입소거된 ArrayList의 add(Object)를 호출한다. WordList 객체의 add를 호춣하면 동적 메서드 조회가 일어나고, ArrayList가 아닌 WordList의 add가 호출될 것을 예상할 수 있다. – example 컴파일러는 예상대로 동작하게 하려고 WordList 안에 bridge method를 만든다. public class WordList extends ArrayList&lt;String&gt; &#123; public void add(String e) &#123; return isBasWord(e) ? false : super.add(e); &#125; // bridge method public void add(Object e) &#123; add((String) e); &#125; ...&#125; add(Object)가 호출되고 WordList의 add(String)가 호출된다. – bridge method 컴파일러는 동적 메서드 조회가 일어나게 하려고 브릿지 메서드를 만들어낸다. 자바에서는 이러한 메서드 쌍을 구현할 수 없다.(?) 파라미터 타입이 다르면 오버로딩으로 가능한데 why? String get(int), Object get(int)의 형태로도 bridge method 생성! 가상 머신에서는 메서드를 이름, 파라미터 타입, 반환 타입으로 명시하므로 컴파일러가 이 메서드 쌍을 만들어낼 수 있다. – Note 제네릭 외에 공변 반환 타입(covariant return type)을 구현하는데도 이용 public class Employee implements Cloneable &#123; public Employee clone() throws CloneNotSupportedException &#123; ... &#125;&#125;Employee clone()Object clone() // bridge method 제네릭의 제약 기본 타입 인자가 없다 실행 시간에는 모든 타입이 raw 형태다 타입 변수의 인스턴스를 만들 수 없다 파라미터화된 타입의 배열을 생성할 수 없다 정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다 메서드가 소거 후 충동하지 않을 수도 있다 예외와 제네릭 실행 시간에는 모든 타입이 raw 형태다VM에는 오직 raw type만 있다. 그래서 실행시간에 ArrayList가 String 객체를 담고 있는지 알아낼 수 없다. 이와 같은 조건은 절대로 검사할 수 없으므로 compile-time error를 일으킨다 – 실행 시간에는 모든 타입이 raw 형태다아래 코드는 비효율적이지만 합법적인 방법이다. obj가 ArrayList인지만 검사한다. Object obj = ...; ArrayList&lt;String&gt; list = (ArrayList&lt;String&gt;) obj; 경고창을 사라지게 하려면 변수앞에 어노테이션을 붙여야 한다. @SuppressWarnings(&quot;unchecked&quot;) ArrayList&lt;String&gt; list = (ArrayList&lt;String&gt;) obj; – but!caution @SuppressWarnings 어노테이션을 잘못 사용하면 heap pollution으로 이어질 수 있다. heap pollution이란 객체가 특정 제네릭 타입 인스턴스에 속해야 하지만 실제로는 다른 인스턴스에 속하는 현상을 말한다. ArrayList에 ArrayList을 할당할 수 있지만, 부적합한 타입 요소를 추출하면 당연히 ClassCastException이 일어난다. – but!tip 힙 펄루션의 문제점은 보고된 실행 시간 오류가 문제의 원인(부적합한 요소의 삽입)과 상당히 다르다는 점이다(문제의 원인은 인스턴스에 다른 값을 넣은 것인데 ClassCate가 발생하는 점). 이런 문제를 디버그하려면 checked view를 사용해야 한다. List&lt;String&gt; strings = Collections.checkedList(new ArrayList&lt;&gt;, String.class); 이 검사 뷰는 해당 리스트에 삽입하는 동작을 모두 검사해서 부적합한 타입 객체를 추가하는 순간 예외를 던진다. – 실행 시간에는 모든 타입이 raw 형태다getClass 메서드는 항상 raw 타입을 반환한다. ArrayList&lt;String&gt; list = ...; list.getClass(); // ArrayList.class ArrayList&lt;String&gt;/classl // 없는 클래스이므로 문법오류 발생 – 타입 변수의 인스턴스를 만들 수 없다.해결하려면 호출하는 쪽에서 배열 생성자를 메서드 참조로 제공하게 해야 한다. // obj가 n개 들어간 배열을 만든다고 가정할때 String[] arr = Arrays.repeat(10, &quot;hi&quot;, String[]::new); public static &lt;T&gt; T[] repeat(int i, T obj, IntFunction&lt;T[]&gt; constr) { T[] result = constr.apply(n); for (int i=0; i &lt; n; i++) result[i] = obj; return result; } String[] arr = Arrays.repeat(10, &quot;hi&quot;, String.class); // 리플렉션 public static &lt;T&gt; T[] repeat(int n, T obj, Class&lt;T&gt; cl) { @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) java.lang.reflect.Array.newInstance(cl, n); for (int i=0; i &lt; n; i++) result[i] = obj; return result; } – 타입 변수의 인스턴스를 만들 수 없다.또 다른 방법으로 호출하는 쪽에서 배열을 할당하게 하는 방법 String[] arr = Arrays.repeat(10, &quot;hi&quot;, new String[5]); public static &lt;T&gt; T[] repeat(int i, T obj, T[] array) { T[] result; if(array.length &gt;= n) { result = array; } else { @SuppressWarnings(&quot;unchecked&quot;) T[] newArray = (T[]) java.lang.reflect.Array.newInstance( array.getClass().getComponenetType(), n); result = newArray; } for (int i=0; i &lt; n; i++) result[i] = obj; return result; } – tip타입 변수를 이용하여 ArrayList는 생성가능하니, 마땅히 배열을 사용해야하는 이유가 없다면 ArrayList방법을 권장한다. public static &lt;T&gt; ArrayList&lt;T&gt; repeat(int n, T obj) { ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; n; i++) result.add(obj); return result; } – 파라미터화된 타입의 배열을 생성할 수 없다.// 오류 - 제네릭 컴포넌트 타입으로 구성된 배열은 생성할 수 없다. Entry&lt;String, Integer&gt;[] entries = new Entry&lt;String, Integer&gt;[100]; // 해결방안 @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;String, Integer&gt;[] entries = (Entry&lt;String, Integer&gt;[]) new Entry&lt;?, ?&gt;[100]; // 더 나은 방안 - ArrayList 사용 ArrayList&lt;Entry&lt;String, Integer&gt;&gt; entries = new ArrayList&lt;&gt;(100); – 파라미터화된 타입의 배열을 생성할 수 없다.public static &lt;T&gt; ArrayList&lt;T&gt; asList(T... elements) { ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T e : elements) { result.add(e); } return result; } ... Entry&lt;String, Integer&gt; e1 = ...; Entry&lt;String, Integer&gt; e2 = ...; ArrayList&lt;Entry&lt;String, Integer&gt;&gt; entries = Lists.asList(e1, e2); // 컴파일러가 경고, 오류X @SafeVarargs public static &lt;T&gt; ArrayList&lt;T&gt; asList(T... elements) { ... – 정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다.public class Entry&lt;K, V&gt; { private static V defaultValue; // 오류 public static void setDefault(V value) { ... } // 오류 ... } 타입 소거는 소거된 Entry 클래스에 이런 종류의 변수나 메서드가 K와 V별로 있는 것이 아니라 오직 한 개만 있다는 것을 알 수 있다. == 타입 소거가 되면 Entry 클래스에는 Object로 모두 바뀌어서 구분할 수 없이 Object 한 개만 있다는 것이다? – 메서드가 소거 후 충돌하지 않을 수도 있다.타입 소거 후 충돌을 일으킬 수 있는 메서드는 선언하지 않아야 한다. 다음 코드는 타입 소거후 Object의 equals과 충돌한다. public interface Ordered&lt;T&gt; extends Comparable&lt;T&gt; { public default boolean equals(T value) { return compareTo(value) == 0; } ... } – 메서드가 소거 후 충돌하지 않을 수도 있다. 2충돌의 원인이 미묘할 때 public class Employee implements Comparable&lt;Employee&gt; { ... public int compareTo(Employee other) { return name.compareTo(other.name); } } public class Manager extends Employee implements Comparable&lt;Manager&gt; { // 오류 - 두 Comparable 인스턴스를 슈퍼타입으로 둘 수 없다. ... public int compareTo(Manager other) { return Double.compare(salary, other.salary); } } 여기서는 소거가 일어나지 않는다. 두 compareTo의 브릿지 메서드가 충돌한다.// ?. 제목이랑 내용이랑 무슨 말인지..? – 예외와 제네릭제네릭 클래스의 객체는 예외로 던지거나 잡아낼 수 없다. Throwable의 제네릭 서브클래스조차 만들 수 없다. public class Problem&lt;T&gt; extends Exception { // 제네릭 틀래스는 Throwable의 서브타입이 될 수 없다. } catch 절에서도 타입 변수를 사용할 수 없다. ... try { r.run(); } catch(T ex) { Logger.get.... } – butthrows 선언에는 타입 변수를 사용할 수 있다. public static &lt;V, T extends Throwable&gt; V doWork(Callable&lt;V&gt; c, T ex) throws T { try { return c.call(); } catch (Throwable realEx) { ex.initCause(realEx); throw ex; } } 리플렉션과 제네릭– Class 클래스Class 클래스는 Class 객체가 기술하는 클래스를 타입 파라미터로 받는다. String.class 는 타입이 Class이다. 그러므로, Class의 newInstance 메서드는 String을 반환한다.이 정보 덕분에 타입 변환 연산자를 사용하지 않아도된다. – 가상 머신에서 제네릭 타입 정보제네릭 클래스와 제네릭 메서드의 선언부가 지워지지 않으므로 리플렉션으로 접근할 수 있다. – 가상 머신에서 제네릭 타입 정보 2java.lang.reflect 패키지의 Type 인터페이스는 제네릭 타입 선언을 나타낸다. Type 인터페이스의 서브타입은 다음과 같다. 구체적인 타입을 기술하는 Class 클래스 (T extends Comparable&lt;? super T&gt; 같은) 타입 변수를 나타내는 TypeVariable 인터페이스 (? super T 같은) 와일드카드를 나타내는 WildcardType 인터페이스 (Comparable&lt;? super T&gt; 같은) 제네릭 클래스나 인터페이스를 나타내는 ParameterizedType 인터페이스 (T[] 같은) 제네릭 배열을 나타내는 GenericArrayType 인터페이스 – 가상 머신에서 제네릭 타입 정보 3Class, Method, Constructor 객체가 제네릭 선언에서 나온 것인지 알아내려면 getTypeParameters 메서드를 호출한다. 반환값으로 TypeVariable 인스턴스 배열을 얻으며 각 요소는 선언부에 있는 타입 변수를 나타낸다. 길이가 0이라면 제네릭 선언이 아니다. Method m = Collections.class.getMethod(&quot;sort&quot;, List.class); TypeVariable&lt;Method&gt;[] vars = m.getTypeParameters(); String name = vars[0].getName(); System.out.println(name); // &quot;T&quot;","categories":[{"name":"slide","slug":"slide","permalink":"https://wickso.me/categories/slide/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wickso.me/tags/java/"}]},{"title":"spring study 01","slug":"spring-01","date":"2016-04-06T17:32:16.000Z","updated":"2017-05-03T07:45:24.000Z","comments":true,"path":"2016/04/07/spring-01/","link":"","permalink":"https://wickso.me/2016/04/07/spring-01/","excerpt":"","text":"Spring in Action chapter 1 스프링 속으로 @date 2016.04.07—## readmeSpring in Action 으로 공부하면서 어려웠던 부분, 기억해야 할 것같은 부분 위주로 정리한 ppt이다. 상단 제목의 번호는 필요할 때 책을 참고하고자 동일하게 적어두었다.—## 1.1 자바 개발 간소화자바 복잡도 간소화를 지원하기 위한 주요 전략1. POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive)인 개발2. DI와 인터페이스 지향(interface orientation)을 통한 느슨한 결합도(loose coupling)3. 애스펙트와 공통 규약을 통한 선언적(declarative) 프로그래밍4. 애스팩트와 템플릿(template)을 통한 반복적인 코드 제거비침투적 개발이란, 바탕이 되는 기술을 사용하는 클래스, 인터페이스, API 등을 코드에 직접 나타내지 않는 방법으로 복잡함을 분리할 수 있다.–## 1.1.2 종속객체 주입- 종속객체 주입(DI, Dependency Injection)- 객체는 종속객체를 생성하거나 얻지 않는다. 즉, 종속객체는 종속객체가 필요한 객체에 주입된다.–### 1.1.2-1생성자 주입(constructor injection) public class BraveKnight implements Knight { private Quest quest; public BraveKnight(Quest quest) { // Quest 주입 this.quest = quest; } public void embarkOnQuest() { quest.embark(); } }–### 1.1.2-2BraveNight 테스트 public class BraveKnightTest { @Test public void knightShouldEmbarkOnQuest() { Quest mockQuest = mock(Quest.class); // 모의 Quest 생성 BraveKnight knight = new BraveKnight(mockQuest); // 모의 Quest 주입 knight.embarkOnQuest(); verify(mockQuest, time(1)).embark(); } }강한 결합으로 생성자 안에서 quest를 생성할 때는 테스트가 불가능 했지만 DI를 이용하고 테스트가 가능하다. embarkOnQuest()를 호출한 후에 Mockito에게 Quest의 embark()가 정확히 한 번 호출됐는지 확인한다.–### 1.1.2-3 public class SlayDragonQuest implements Quest { private PrintStream stream; public SlayDragonQuest(PrintStream stream) { this.stream = stream; } public void embark() { stream.println(“Embarking on quest to slay the dragon!”); } }위와 같은 클래스가 있을 때, 어떻게 BraveKnight에게 SlayDragonQuest를 줄 수 있는가? 그리고 어떻게 SlayDragonQuest에게 PrintStrean을 줄 수 있는가?–### 1.1.2-4와이어링(wiring): 애플리케이션 컴포넌트 간의 관계를 정의하는 것(xml or java를 이용한 방법)xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; –### 1.1.2-5java @Configuration public class KnightConfig { @Bean public Knight knight() { return new BraveKnight(quest()); } @Bean public Quest quest() { return new SlayDragonQuest(System.out); } }–### 1.1.2-6실행해 보기application context은 빈에 관한 정의들을 바탕으로 빈들을 엮어 준다. 스프링 애플리케이션 컨텍스트는 애플리케이션을 구성하는 객체의 생성과 와이어링을 전적으로 책임진다.xml: ClassPathXmlApplicationContext()java: AnnotationConfigApplicationContext() public static void main(String[] args) { ClassPathXmlApplicationContext context = // 스프링 컨텍스트 로드 new ClassPathXmlApplicationContext( “META-INF/spring/knights.xml”); Knight k = context.getBean(Knight.class); // 빈 얻기 k.embarkOnQuest(); // 사용 context.close(); }–## 1.1.3 애스펙트 적용AOP(Aspect-Oriented Programming)은 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용할 수 있는 컴포넌트에 담는다. 즉, 소프트웨어 내부의 관심사들을 서로 분리하는 기술이다. 예를 들어 로깅, 트랜잭션 관리, 보안 등의 시스템 서비스(이렇게 여러 컴포넌트에 관련되는 것을 *횡단 관심사(cross-cutting concerns)라고 한다. 이러한 관심사가 각각의 컴포넌트에 퍼지게 되면 다음과 같은 문제점이 있다.1. 관심사를 구현하는 코드가 시스템 전반에 중복되어 걸쳐있어, 변경해야하는 경우 모두 변경해야 한다.2. 컴포넌트의 코드가 본연의 기능과 관련 없응 코드로 지저분해진다.–### 1.1.3-1AOP를 이용하면 응집도가 높고 본연의 관심사에 집중하는 컴포넌트를 만든다. 즉, 애스펙트는 확실히 POJO를 단순화한다. – 1.1.3-2ex) 기사가 원정전,후에 노래가 울려야 할 경우 public class BraveKnight implements Knight { ... public void embarkOuest() { sing.beforeQuest(); // 기사가 이것까지 관리해야할까? quest.embark(); sing.afterQuest(); } } – 1.1.3-3&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; ...&gt; &lt;bean id=&quot;sing&quot; class=&quot;com.test.Sing&quot;&gt; ... &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;sing&quot;&gt; &lt;aop:pointcut id=&quot;embark&quot; expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt; &lt;!-- 포인트커트 정의 --&gt; &lt;aop:before pointcut-ref=&quot;embark&quot; method=&quot;beforeQuest&quot;/&gt; &lt;aop:after pointcut-ref=&quot;embark&quot; method=&quot;afterQuest&quot;/&gt; &lt;/sop:aspect&gt; &lt;/aop:config&gt; &lt;/bean&gt; 1.2 빈은 담는 그릇, 컨테이너스프링 기반 애플리케이션은 spring container 안에서 객체가 태어나고, 자라고, 소멸한다. 그래서 spring container는 객체를 생성하고, 엮어주고, 이들의 전체 생명주기를 관리한다. – 1.2-1스프링에는 여러 컨테이너 구현체가 존재하며, 이들은 크게 두 가지로 분류된다. 빈 팩토리(org.springframework.beans.factory.BeanFactory) 인터페이스에 의해 정의 DI에 대한 기본적인 지원을 제공하는 가장 단순한 컨테이너 애플리케이션 컨텍스트(org.springframework.context.ApplicationContext) 인터페이스에 의해 정의 빈 팩토리를 확장해 애플리케이션 프레임워크 서비스를 제공하는 컨테이너 – 1.2.1 애플리케이션 컨텍스트애플리케이션의 설정을 제공하기 위한 중앙 인터페이스로, 실행중일땐 읽기만 가능하지만, 실행이 지원되면 리로드될 수 있다. AnnotationConfigApplicationContext 하나 이상의 자바 기반 설정 클래스에서 스코프 애플리케이션 컨텍스트를 로드 AnnotationConfigWebApplicationContext 하나 이상의 자바 기반 설정 클래스에서 스프링 웹 애플리케이션 컨텍스트를 로드 ClassPathXmlApplicationContext 클래스패스에 위치한 xml 파일에서 컨텍스트 정의 내용을 로드 FileSystemXmlApplicationContext 파일 경로로 지정된 xml 파일에서 컨텍스트 정의 내용 로드 XmlWebApplicationContext 웹 어플리케이션에 포함된 xml 파일에서 컨텍스트 정의 내용 로드 – 1.2.2 빈의 생명주기 – 1.2.2-1 life-cycle 스프링이 빈 인스턴스화 스프링이 값과 빈의 레퍼런스를 빈의 프로퍼티에 주입 빈이 BeanNameAware를 구현하면 스프링이 빈의 ID를 setBEanName()에 넘김 빈이 BeanFactoryAware를 구현하면 setBEanFactory() 호출하여 빈팩토리 자체를 넘김 빈이 ApplicationContextAware를 구현하면 스프링이 setApplicationContext()를 호출하고 둘러싼 애플리케이션컨텍스트에 대한 참조를 넘김 빈이 BeanPostProcessor 인터페이스를 구현하면 스프링은 postProcessBeforeInitialzation()을 호출 – 1.2.2-2 life-cycle빈이 InitialzingBean 인터페이스를 구현하면 스프링은 afterPropertiesSet() 호출, 빈이 init-method와 함께 선언됐으면 지정한 초기화 메소드가 호출빈이 BeanPostProcessor를 구현하면 스프링은 postProcessAfterInitialization() 호출이 상태가 되면 빈은 애플리케이션에서 사용될 준비가 된 것이며, 애플리케이션 컨텍스트가 소멸될 때까지 애플리케이션 컨텍스트에 남아 있다.빈이 DisposableBean 인터페이스를 구현하면 스프링은 destroy()를 호출한다. 마찬가지고 빈이 destroy-method와 함께 선언됬으면 지정 메소드가 호출","categories":[{"name":"slide","slug":"slide","permalink":"https://wickso.me/categories/slide/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://wickso.me/tags/spring/"},{"name":"java","slug":"java","permalink":"https://wickso.me/tags/java/"}]}]}