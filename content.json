{"meta":{"title":"Wicksome Blog","subtitle":null,"description":null,"author":"Yeongjun Kim","url":"https://wickso.me"},"pages":[{"title":"Hello World(and MD Test)","date":"2017-04-28T07:56:46.000Z","updated":"2017-05-02T13:30:34.000Z","comments":true,"path":"md-test/index.html","permalink":"https://wickso.me/md-test/index.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 预处理器很强大，但它只是编写 CSS 的辅助工具。出于对扩展和维护等方面的考虑，在大型项目中有必要使用预处理器构建 CSS；但是对于小型项目，原生的 CSS 可能是一种更好的选择。不要肆意使用预处理器！ Advertisement pica - high quality and fast imageresize in browser. babelfish - developer friendlyi18n with plurals support and easy syntax. You will like those projects! h1 Headingh2 Headingh3 Headingh4 Headingh5 Headingh6 HeadingHorizontal Rules Typographic replacementsEnable typographer option to see result. (c) (C) (r) (R) (tm) (TM) (p) (P) +- test.. test… test….. test?….. test!…. !!!!!! ???? ,, – — “Smartypants, double quotes” and ‘single quotes’ EmphasisThis is bold text This is bold text This is italic text This is italic text Strikethrough Blockquotes Blockquotes can also be nested… …by using additional greater-than signs right next to each other… …or with spaces between arrows. ListsUnordered Create a list by starting a line with +, -, or * Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Very easy! Ordered Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa You can use sequential numbers… …or keep all the numbers as 1. Start numbering with offset: foo bar CodeInline code Indented code // Some comments line 1 of code line 2 of code line 3 of code Block code “fences” Sample text here... Syntax highlighting var foo = function (bar) &#123; return bar++;&#125;;console.log(foo(5)); Tables Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Right aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Linkslink text link with title Autoconverted link https://github.com/nodeca/pica (enable linkify to see) Images Like links, Images also have a footnote style syntax With a reference later in the document defining the URL location: PluginsThe killer feature of markdown-it is very effective support ofsyntax plugins. see how to change output with twemoji. Subscript / Superscript 19th H2O \\++Inserted text++ FootnotesFootnote 1 link[1]. Footnote 2 link[3]. Duplicated footnote reference[4]. AbbreviationsThis is HTML abbreviation example. It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on. *[HTML]: Hyper Text Markup Language Custom containers::: tip here be dragons test ::: st=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yesor No?|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something…|request st-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e{“theme”:”simple”,”scale”:1,”line-width”:2,”line-length”:50,”text-margin”:10,”font-size”:12} var code = document.getElementById(“flowchart-0-code”).value; var options = JSON.parse(document.getElementById(“flowchart-0-options”).value); var diagram = flowchart.parse(code); diagram.drawSVG(“flowchart-0”, options);Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob–&gt;Alice: I am good thanks!{“theme”:”simple”,”scale”:1,”line-width”:2,”line-length”:50,”text-margin”:10,”font-size”:12} var code = document.getElementById(“sequence-0-code”).value; var options = JSON.parse(document.getElementById(“sequence-0-options”).value); var diagram = Diagram.parse(code); diagram.drawSVG(“sequence-0”, options);1.basic footnote content ↩3.paragraph ↩4.footnote content with some markdown ↩"}],"posts":[{"title":"Template Method Pattern","slug":"template-method-pattern","date":"2017-05-02T03:57:22.000Z","updated":"2017-05-02T13:11:13.000Z","comments":true,"path":"2017/05/02/template-method-pattern/","link":"","permalink":"https://wickso.me/2017/05/02/template-method-pattern/","excerpt":"의도연산operation에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다. 구조 활용성 어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때 서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93][1] “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다. 서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.","text":"의도연산operation에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다. 구조 활용성 어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때 서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93][1] “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다. 서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다. 결과 템플릿 메서드는 코드 재사용을 위한 기본 기술이다(특히 클라스 라이브러리 구현 시 중요). 템플릿 메서드는 IoC(Inversion of Control, 제어 역전) 구조를 이끌어 낸다. 즉, 부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만 반대 방향의 호출은 안 된다.Don’t call us, we’ll call you. 할리우드 원칙(Hollywood principle) 템플릿 메서드는 여러 종류의 연산 중 하나를 호출한다. 구체 연산 AbstractClass 구체 연산 기본 연산 factory method hook operation: 필요하다면 서브클래스에서 활장할 수 있는 기본 행동을 제공하는 연산. 기본적으로 아무 내용도 정의하지 않는다. 구현 접근제어자를 이용한다. - 템플릿 메서드에서 호출하는 기본 연산들을 protected로 구현한다. 이렇게 하면 이 연산들은 템플릿 메서드만 호출할 수 있게 된다. 템플릿 메서드는 재정의하면 안되므로 맴버 함수로 만든다(final로 정의하면 재정의 불가능). 기본 연산의 수를 최소화한다. - 템플릿 메서드를 설계할 때 중요한 목표 중 하나는 서브클래스가 오버라이드해야 하는 연산의 수를 최소화하는 것이다. 재정의해야 하는 메서드가 많아질수록 사용자는 불편해진다. 네이밍 규칙을 만든다. - 재정의 연산에 접두어를 추가하여 식별이 잘되도록 할 수 있다. 예를 들어, 매킨토시 응용프로그램의 MapAPP프레임워크[App89][2]의 모든 템플릿 메서드는 Do-로 시작한다. DoCreateDocument, DoRead 예제문서 관리 응용프로그램이 새 문서를 만드는 경우로 예를 들어 보자. 모든 응용프로그램은 파일을 생성하기 전에 파일 존재 확인과 권한 확인을 하며, 특정 응용프로그램은 파일을 열기전에 로그를 출력해야 한다. 이런 경우에 openNewDocument() 템플릿 메서드를 사용할 수 있다. Application.java는 항상 확인해야할 연산(파일 존재 확인, 권한 확인)을 추상 메서드로 정의하고 템플릿 메서드에서 수행한다. Application에서 beforeCreateDocument()는 hook 연산으로 필요에따라 확장해서 사용 가능하다. 이렇게 함으로 추상 연산을 통해 알고리즘의 일부를 정의함으로써, 템플릿 메서드는 각 단계의 순서는 고정하되 각각의 서브클래스는 필요에 따라 이들 단계의 처리를 다양화시킬 수 있다. Application.java(AbstractClass) public abstract class Application &#123; public Document newDcument() &#123; return createDocument(); &#125; public abstract Document createDocument(); // factory method // template method final public Document openNewDocument(String fileName) &#123; if (!existDocument(fileName)) &#123; throw new IllegalStateException(\"The file doesn't exist: \" + fileName); &#125; if (!canOpenDocument(fileName)) &#123; throw new IllegalStateException(\"can't open the document: \" + fileName); &#125; beforeCreateDocument(); // hook 연산 Document document = createDocument(); // template method에서 factory method가 호출된다. document.setFileName(fileName); return document; &#125; protected abstract boolean existDocument(String fileName); protected abstract boolean canOpenDocument(String fileName); protected void beforeCreateDocument() &#123;&#125; // hook: 기본적으로 아무 내용도 정의하지 않는다.&#125; MyApplication.java(ConcreteClass) public class MyApplication extends Application &#123; private static final String BASE_PATH = \"/local/path/base\"; @Override public void beforeCreateDocument() &#123; System.out.println(\"create document\"); &#125; @Override public Document createDocument() &#123; return new WordDocument(); &#125; @Override protected boolean existDocument(String fileName) &#123; return (new File(BASE_PATH + fileName)).exists(); &#125; ...&#125; 아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다. [GOF{kr}:419] - 템플릿 메서드 GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015. 1.William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC ‘93), pages 66–73, Indianapolis, IN, February 1993. ↩2.Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994. ↩","categories":[],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://wickso.me/tags/design-pattern/"},{"name":"java","slug":"java","permalink":"https://wickso.me/tags/java/"},{"name":"befavioral pattern","slug":"befavioral-pattern","permalink":"https://wickso.me/tags/befavioral-pattern/"}]},{"title":"Factory Method Pattern","slug":"factory-method-pattern","date":"2017-04-26T04:32:16.000Z","updated":"2017-05-02T05:23:40.000Z","comments":true,"path":"2017/04/26/factory-method-pattern/","link":"","permalink":"https://wickso.me/2017/04/26/factory-method-pattern/","excerpt":"의도객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다. Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다. 위키백과팩토리 메서드 패턴 구조 활용성 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때","text":"의도객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다. Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다. 위키백과팩토리 메서드 패턴 구조 활용성 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때 예제예를 들어 다양한 종류의 문서를 표현하는 응용프로그램 프레임워크가 있다. 이를 위해서는 일단 두 개의 큰 추상화가 필요하다. 하나는 Creator(응용프로그램) 추상 클래스이고, 다른 하나는 Product(문서) 추상 클래스(혹은 인터페이스)이다.Creator 클래스는 문서의 인스턴스를 ++언제++ 만들지는 알지만, ++어떤 문서++를 만들어야 하는지는 알지 못한다. Product 클래스가 추상 클래스이기 때문에 인스턴스를 가질 수 없기 때문이다. abstract class Creator &#123; public Product newProduct() &#123; return createProduct(); &#125; public abstract Product createProduct(); // factory method&#125;interface Product &#123;&#125; 팩토리 메서드 패턴은 이런 문제에 대한 해법을 제시한다. Document의 서브클래스 중 어느 것을 생성해야 하는지에 대한 정보를 캡슐화하고, 그것을 프레임워크에서 떼어낸다. public class TextProduct implements Product &#123;&#125;public class PhotoProduct implements Product &#123;&#125; TextProduct 클래스와 PhotoProduct 클래스를 팩토리 메서드 패턴을 활용하여 생성한다면 아래와 같은 방법이 있다. 방법 1) 추상 클래스사용자는 특정 응용프로그램에 종속적인 구현을 위해서 두 클래스의 서브 클래스를 정의할 수 있다. Creator 클래스는 Product 객체를 관리하는 책임을 맡고 있으며, 필요에 따라 문서를 생성할 수도 있다. // factory pattern example with abstract classCreator textCreator = new TextCreator();Product p1 = textCreator.newProduct();Creator photoCreator = new PhotoCreator();Product p2 = photoCreator.newProduct(); public class TextCreator extends Creator &#123; @Override public Product createProduct() &#123; return new WordProduct(); &#125;&#125;public class PhotoCreator extends Creator &#123; @Override public Product createProduct() &#123; return new PhotoProduct(); &#125;&#125; public class TextProduct implements Product &#123;&#125;public class PhotoProduct implements Product &#123;&#125; 방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern팩토리 메서드가 매개변수를 받아서 어떤 종류의 제품을 생성할지 만드는 방법도 있다. (추상 팩토리 패턴은 팩토리 메서드를 이용해서 구현할 때가 많다) // Factory pattern example using argumentProduct p1 = Creator1.create(ProductType.TEXT);Product p2 = Creator1.create(ProductType.PHOTO); public enum ProductType &#123; TEXT, PHOTO&#125; public class Creator &#123; static public Product create(ProductType type) &#123; switch (type) &#123; case TEXT: return new ExcelProduct(); case PHOTO: return new ImageProduct(); default: return null; &#125; &#125;&#125; 방법 3) Lazy Initialization 기법인스턴스화하는 접근자 메서드를 통해서만 인스턴스에 접근하는 방법으로, 생성자에서 아무 의미 없는 값으로 인스턴스에 대한 매개변수를 초기화하고, 접근자 메서드가 인스턴스를 반환하도록 할 수 있다. 생성자가 초기화 시키는 것이 아니라 필요한 시점에서 초기화를 수행하기 때문에 이런 기법을 Lazy Initialization이라고 한다. // factory pattern with lazy initializationTextCreator textCreator = new TextCreator();List collection = textCreator.newCollection(); public class TextCreator extends Creator &#123; @Override protected List createCollection() &#123; return new ArrayList&lt;TextProduct&gt;(); &#125;&#125; public abstract class Creator &#123; private List&lt;Product&gt; collection = null; public List newCollection() &#123; // lazy initialization if (collection == null) &#123; collection = createCollection(); &#125; return collection; &#125; // factory method abstract protected List createCollection();&#125; 방법 4) 템플릿 활용팩토리 메서드를 사용하면 생길 수 있는 문제점 중 하나는 Product 클래스 하나를 추가하려 할 때마다 Creator 클래스를 서브클래싱해야 한다는 점이다(방법 1). 이로써 클래스 계통의 부피가 확장되는 문제가 생길 수 있다. 이런 문제를 해결할 수 있는 방법 중 하나는 Creator 클래스를 상속받는 제네릭 클래스를 정의하고 Product 클래스로 매개변수화되도록 만드는 것이다. // factory pattern example whti templateStandardCreator&lt;WordProduct&gt; wordProductCreator = new StandardCreator&lt;&gt;(WordProduct.class);Product p1 = wordProductCreator.newProduct();StandardCreator&lt;ImageProduct&gt; imageProductCreator = new StandardCreator&lt;&gt;(ImageProduct.class);Product p2 = imageProductCreator.newProduct(); /** * Creator Template * @param &lt;T&gt; product type */public class StandardCreator&lt;T extends Product&gt; extends Creator &#123; private Class&lt;T&gt; cls; public StandardCreator(Class&lt;T&gt; cls) &#123; this.cls = cls; &#125; @Override public Product createProduct() &#123; T product = null; try &#123; product = cls.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return product; &#125;&#125; 아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다. [GOF{kr}:419] - 템플릿 메서드 GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.","categories":[],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://wickso.me/tags/design-pattern/"},{"name":"creational pattern","slug":"creational-pattern","permalink":"https://wickso.me/tags/creational-pattern/"},{"name":"java","slug":"java","permalink":"https://wickso.me/tags/java/"}]},{"title":"spring 01","slug":"spring-01","date":"2016-04-06T17:32:16.000Z","updated":"2017-05-03T05:35:40.000Z","comments":true,"path":"2016/04/07/spring-01/","link":"","permalink":"https://wickso.me/2016/04/07/spring-01/","excerpt":"","text":"Spring in Action chapter 1 스프링 속으로 @date 2016.04.07—## readmeSpring in Action 으로 공부하면서 어려웠던 부분, 기억해야 할 것같은 부분 위주로 정리한 ppt이다. 상단 제목의 번호는 필요할 때 책을 참고하고자 동일하게 적어두었다.—## 1.1 자바 개발 간소화자바 복잡도 간소화를 지원하기 위한 주요 전략1. POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive)인 개발2. DI와 인터페이스 지향(interface orientation)을 통한 느슨한 결합도(loose coupling)3. 애스펙트와 공통 규약을 통한 선언적(declarative) 프로그래밍4. 애스팩트와 템플릿(template)을 통한 반복적인 코드 제거비침투적 개발이란, 바탕이 되는 기술을 사용하는 클래스, 인터페이스, API 등을 코드에 직접 나타내지 않는 방법으로 복잡함을 분리할 수 있다.–## 1.1.2 종속객체 주입- 종속객체 주입(DI, Dependency Injection)- 객체는 종속객체를 생성하거나 얻지 않는다. 즉, 종속객체는 종속객체가 필요한 객체에 주입된다.–### 1.1.2-1생성자 주입(constructor injection) public class BraveKnight implements Knight { private Quest quest; public BraveKnight(Quest quest) { // Quest 주입 this.quest = quest; } public void embarkOnQuest() { quest.embark(); } }–### 1.1.2-2BraveNight 테스트 public class BraveKnightTest { @Test public void knightShouldEmbarkOnQuest() { Quest mockQuest = mock(Quest.class); // 모의 Quest 생성 BraveKnight knight = new BraveKnight(mockQuest); // 모의 Quest 주입 knight.embarkOnQuest(); verify(mockQuest, time(1)).embark(); } }강한 결합으로 생성자 안에서 quest를 생성할 때는 테스트가 불가능 했지만 DI를 이용하고 테스트가 가능하다. embarkOnQuest()를 호출한 후에 Mockito에게 Quest의 embark()가 정확히 한 번 호출됐는지 확인한다.–### 1.1.2-3 public class SlayDragonQuest implements Quest { private PrintStream stream; public SlayDragonQuest(PrintStream stream) { this.stream = stream; } public void embark() { stream.println(“Embarking on quest to slay the dragon!”); } }위와 같은 클래스가 있을 때, 어떻게 BraveKnight에게 SlayDragonQuest를 줄 수 있는가? 그리고 어떻게 SlayDragonQuest에게 PrintStrean을 줄 수 있는가?–### 1.1.2-4와이어링(wiring): 애플리케이션 컴포넌트 간의 관계를 정의하는 것(xml or java를 이용한 방법)xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; –### 1.1.2-5java @Configuration public class KnightConfig { @Bean public Knight knight() { return new BraveKnight(quest()); } @Bean public Quest quest() { return new SlayDragonQuest(System.out); } }–### 1.1.2-6실행해 보기application context은 빈에 관한 정의들을 바탕으로 빈들을 엮어 준다. 스프링 애플리케이션 컨텍스트는 애플리케이션을 구성하는 객체의 생성과 와이어링을 전적으로 책임진다.xml: ClassPathXmlApplicationContext()java: AnnotationConfigApplicationContext() public static void main(String[] args) { ClassPathXmlApplicationContext context = // 스프링 컨텍스트 로드 new ClassPathXmlApplicationContext( “META-INF/spring/knights.xml”); Knight k = context.getBean(Knight.class); // 빈 얻기 k.embarkOnQuest(); // 사용 context.close(); }–## 1.1.3 애스펙트 적용AOP(Aspect-Oriented Programming)은 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용할 수 있는 컴포넌트에 담는다. 즉, 소프트웨어 내부의 관심사들을 서로 분리하는 기술이다. 예를 들어 로깅, 트랜잭션 관리, 보안 등의 시스템 서비스(이렇게 여러 컴포넌트에 관련되는 것을 *횡단 관심사(cross-cutting concerns)라고 한다. 이러한 관심사가 각각의 컴포넌트에 퍼지게 되면 다음과 같은 문제점이 있다.1. 관심사를 구현하는 코드가 시스템 전반에 중복되어 걸쳐있어, 변경해야하는 경우 모두 변경해야 한다.2. 컴포넌트의 코드가 본연의 기능과 관련 없응 코드로 지저분해진다.–### 1.1.3-1AOP를 이용하면 응집도가 높고 본연의 관심사에 집중하는 컴포넌트를 만든다. 즉, 애스펙트는 확실히 POJO를 단순화한다. – 1.1.3-2ex) 기사가 원정전,후에 노래가 울려야 할 경우 public class BraveKnight implements Knight { ... public void embarkOuest() { sing.beforeQuest(); // 기사가 이것까지 관리해야할까? quest.embark(); sing.afterQuest(); } } – 1.1.3-3&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; ...&gt; &lt;bean id=&quot;sing&quot; class=&quot;com.test.Sing&quot;&gt; ... &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;sing&quot;&gt; &lt;aop:pointcut id=&quot;embark&quot; expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt; &lt;!-- 포인트커트 정의 --&gt; &lt;aop:before pointcut-ref=&quot;embark&quot; method=&quot;beforeQuest&quot;/&gt; &lt;aop:after pointcut-ref=&quot;embark&quot; method=&quot;afterQuest&quot;/&gt; &lt;/sop:aspect&gt; &lt;/aop:config&gt; &lt;/bean&gt; 1.2 빈은 담는 그릇, 컨테이너스프링 기반 애플리케이션은 spring container 안에서 객체가 태어나고, 자라고, 소멸한다. 그래서 spring container는 객체를 생성하고, 엮어주고, 이들의 전체 생명주기를 관리한다. – 1.2-1스프링에는 여러 컨테이너 구현체가 존재하며, 이들은 크게 두 가지로 분류된다. 빈 팩토리(org.springframework.beans.factory.BeanFactory) 인터페이스에 의해 정의 DI에 대한 기본적인 지원을 제공하는 가장 단순한 컨테이너 애플리케이션 컨텍스트(org.springframework.context.ApplicationContext) 인터페이스에 의해 정의 빈 팩토리를 확장해 애플리케이션 프레임워크 서비스를 제공하는 컨테이너 – 1.2.1 애플리케이션 컨텍스트애플리케이션의 설정을 제공하기 위한 중앙 인터페이스로, 실행중일땐 읽기만 가능하지만, 실행이 지원되면 리로드될 수 있다. AnnotationConfigApplicationContext 하나 이상의 자바 기반 설정 클래스에서 스코프 애플리케이션 컨텍스트를 로드 AnnotationConfigWebApplicationContext 하나 이상의 자바 기반 설정 클래스에서 스프링 웹 애플리케이션 컨텍스트를 로드 ClassPathXmlApplicationContext 클래스패스에 위치한 xml 파일에서 컨텍스트 정의 내용을 로드 FileSystemXmlApplicationContext 파일 경로로 지정된 xml 파일에서 컨텍스트 정의 내용 로드 XmlWebApplicationContext 웹 어플리케이션에 포함된 xml 파일에서 컨텍스트 정의 내용 로드 – 1.2.2 빈의 생명주기 – 1.2.2-1 life-cycle 스프링이 빈 인스턴스화 스프링이 값과 빈의 레퍼런스를 빈의 프로퍼티에 주입 빈이 BeanNameAware를 구현하면 스프링이 빈의 ID를 setBEanName()에 넘김 빈이 BeanFactoryAware를 구현하면 setBEanFactory() 호출하여 빈팩토리 자체를 넘김 빈이 ApplicationContextAware를 구현하면 스프링이 setApplicationContext()를 호출하고 둘러싼 애플리케이션컨텍스트에 대한 참조를 넘김 빈이 BeanPostProcessor 인터페이스를 구현하면 스프링은 postProcessBeforeInitialzation()을 호출 – 1.2.2-2 life-cycle빈이 InitialzingBean 인터페이스를 구현하면 스프링은 afterPropertiesSet() 호출, 빈이 init-method와 함께 선언됐으면 지정한 초기화 메소드가 호출빈이 BeanPostProcessor를 구현하면 스프링은 postProcessAfterInitialization() 호출이 상태가 되면 빈은 애플리케이션에서 사용될 준비가 된 것이며, 애플리케이션 컨텍스트가 소멸될 때까지 애플리케이션 컨텍스트에 남아 있다.빈이 DisposableBean 인터페이스를 구현하면 스프링은 destroy()를 호출한다. 마찬가지고 빈이 destroy-method와 함께 선언됬으면 지정 메소드가 호출","categories":[{"name":"slide","slug":"slide","permalink":"https://wickso.me/categories/slide/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wickso.me/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://wickso.me/tags/spring/"}]}]}