<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 이펙티브자바 2장. 객체 생성과 삭제 - 2 · Wicksome Blog</title><meta name="description" content="chapter 2. Creating and Destroying Objects in effective java"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="canonical" href="https://wickso.me/2017/02/12/creating-and-destroying-objects-2/"><link rel="search" type="application/opensearchdescription+xml" href="https://wickso.me/atom.xml" title="Wicksome Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/categories/slide/" target="_self" class="nav-list-link">SLIDE</a></li><li class="nav-list-item"><a href="https://github.com/wicksome" target="_blank" class="nav-list-link" rel="external nofollow noopener noreferrer">GITHUB</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/yeongjun/" target="_blank" class="nav-list-link" rel="external nofollow noopener noreferrer">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">이펙티브자바 2장. 객체 생성과 삭제 - 2</h1><div class="post-info">2017년 2월 12일<ul class="tags"><li><a href="/tags/java/" title="java" class="tag">java </a></li><li><a href="/tags/effective-java/" title="effective java" class="tag">effective java </a></li></ul></div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-3-private-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계하라">규칙 3</a> - private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라<br><a href="../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-4-객체-생성을-막을-때는-private-생성자를-사용하라">규칙 4</a> - 객체 생성을 막을 때는 private 생성자를 사용하라<br><a href="../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-5-불필요한-객체는-만들지-말라">규칙 5</a> - 불필요한 객체는 만들지 말라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-3-private-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계하라"><a href="#규칙-3-private-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계하라" class="headerlink" title="규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라"></a>규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라</h2><blockquote>
<p><a href="dp-singleton">싱글턴</a>은 객체를 하나만 만들 수 있는 클래스다.</p>
</blockquote>
<h4 id="singleton-구현-방법"><a href="#singleton-구현-방법" class="headerlink" title="singleton 구현 방법"></a>singleton 구현 방법</h4><h6 id="public-static-final-상수before-jdk-15"><a href="#public-static-final-상수-before-JDK-1-5" class="headerlink" title="public static final 상수(before JDK 1.5)"></a><em>public static final</em> 상수(before JDK 1.5)</h6><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>문제점</strong></p>
<ul>
<li>리플렉션으로 private 생성자 호출 가능</li>
<li>생성자에서 에러날 경우 예외처리 불가능 -&gt; static 초기화 블럭으로 해결 가능</li>
</ul>
<h6 id="static-factory-메서드before-jdk-15"><a href="#static-factory-메서드-before-JDK-1-5" class="headerlink" title="static factory 메서드(before JDK 1.5)"></a><em>static factory</em> 메서드(before JDK 1.5)</h6><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> INSTANCE;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>문제점</strong></p>
<ul>
<li>리플렉션으로 private 생성자 호출 가능</li>
<li><p>위 두 방법에서 <a href="#serializable">직렬화</a>가능 클래스로 만드려면 클래스 선언에 <code>implements Serializable</code>을 추가하는 것으로는 부족하다.</p>
<ul>
<li>클래스 선언에 <code>implements Serializable</code> 추가</li>
<li>모든 객체 필드에 <code>transient</code> 선언</li>
<li><p><a href="#item77"><code>readResolve()</code> 추가</a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 동일한 객체가 반환되도록 하는 동시에,</span></div><div class="line">  <span class="comment">// 가짜 객체는 gc가 처리하도록 만든다.</span></div><div class="line">  <span class="keyword">return</span> INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>thread safe하려면 synchronized 적용</p>
  <figure class="highlight"><table><tr><td class="code"><pre><div class="line">  public static synchronized Single getInstance() &#123; ... &#125;</div><div class="line">  ```  </div><div class="line"></div><div class="line">###### Initialization on demand holder idiom</div><div class="line"></div><div class="line">- jvm 의 class loader의 매커니즘과 class의 load 시점을 이용하여 내부 class를 생성시킴으로 thread 간의 동기화 문제를 해결</div><div class="line">- lazy initialization</div><div class="line"></div><div class="line">```java</div><div class="line">public class Singleton &#123;</div><div class="line">  private Singleton() &#123; &#125;</div><div class="line"></div><div class="line">  private static class SingletonHolder &#123;</div><div class="line">          public static final Singleton INSTANCE = new Singleton();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static Singleton getInstance() &#123;</div><div class="line">          return SingletonHolder.INSTANCE;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="enum을-이용하는-방법after-jdk-15"><a href="#enum을-이용하는-방법-after-JDK-1-5" class="headerlink" title="enum을 이용하는 방법(after JDK 1.5)"></a><em>enum</em>을 이용하는 방법(after JDK 1.5)</h6><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Single &#123;</div><div class="line">  INSTANCE;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>직렬화 자동으로 처리된다.</li>
<li>리플렉션 공격에도 안전하다.</li>
<li>Enum 생성은 Thread-safe하지만, 내부 메서드들은 Thread-safe를 보장하지 않는다.</li>
</ul>
<p><em>why?</em></p>
<ul>
<li>선언된 상수 이외의 다른 객체는 존재할 수 없다는 확실한 보장이 생긴다(JVM이 해주는 보장).</li>
<li><code>enum</code> 타입은 <code>Comparable</code> 인터페이스, <code>Serializable</code> 인터페이스가 구현되어 있다.</li>
</ul>
<h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><h6 id="link"><a href="#Link" class="headerlink" title="Link"></a>Link</h6><ul>
<li>java singleton pattern (싱글톤 패턴) - <a href="https://blog.seotory.com/post/2016/03/java-singleton-pattern" rel="external nofollow noopener noreferrer" target="_blank">https://blog.seotory.com/post/2016/03/java-singleton-pattern</a></li>
<li>게으른 홀더를 통한 싱글턴의 동시성 문제 해결 (Initialization on demand holder idiom) - <a href="http://changsuk.me/?p=1433" rel="external nofollow noopener noreferrer" target="_blank">http://changsuk.me/?p=1433</a></li>
<li>Thread-safe Enum Singleton - <a href="http://stackoverflow.com/questions/28369025/thread-safe-enum-singleton" rel="external nofollow noopener noreferrer" target="_blank">http://stackoverflow.com/questions/28369025/thread-safe-enum-singleton</a></li>
</ul>
<h6 id="serializable"><a href="#serializable" class="headerlink" title="serializable"></a>serializable</h6><blockquote>
<p>객체의 내용을 파일에 저장하거나 네트워크로 전송하기 위해서 스트림으로 만드는 작업(바이트 단위로 변환)</p>
</blockquote>
<ul>
<li><code>Serializable</code> 인터페이스 구현</li>
<li>모든 필드 또한 <code>Serializable</code> 인터페이스 구현</li>
<li>제외하고자하는 필드는 <code>transient</code></li>
</ul>
<p><em>example</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">    SerializerTest test = <span class="keyword">new</span> SerializerTest();</div><div class="line">    test.serialization();</div><div class="line">    test.deserialization();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializerTest</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String filePath = <span class="string">"/Users/yeongjun/Desktop/test.ser"</span>;</div><div class="line">  <span class="keyword">private</span> User user;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialization</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    user = <span class="keyword">new</span> User(<span class="string">"yj"</span>, <span class="number">26</span>, <span class="string">"pwd"</span>);</div><div class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(filePath);</div><div class="line">    ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(f); <span class="comment">// 직렬화 클래스</span></div><div class="line">    o.writeObject(user); <span class="comment">// 파라미터로 넘긴 객체를 스트림으로 만들어서 출력하는 메서드</span></div><div class="line">    o.close();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deserialization</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">    FileInputStream f = <span class="keyword">new</span> FileInputStream(filePath);</div><div class="line">    ObjectInputStream o = <span class="keyword">new</span> ObjectInputStream(f); <span class="comment">// 역직렬화 클래스</span></div><div class="line">    user = (User)o.readObject(); <span class="comment">// 입력된 스트림으로부터 객체를 만들어서 반환하는 메서드</span></div><div class="line">    o.close();</div><div class="line">    System.out.println(user.toString());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>; <span class="comment">// 이건 왜?</span></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> String password;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age, String password)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.password = password;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"User&#123;name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">", password='"</span> + password + <span class="string">"\'&#125;"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="규칙-4-객체-생성을-막을-때는-private-생성자를-사용하라"><a href="#규칙-4-객체-생성을-막을-때는-private-생성자를-사용하라" class="headerlink" title="규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라"></a>규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라</h2><ul>
<li>생성자를 생략하면 컴파일러는 자동으로 인자없는 <code>public</code> 생성자를 만든다. 그러므로, 객체 생성을 막기 위해서 <code>private</code> 생성자를 추가한다.</li>
<li><code>AssertionError()</code>를 통해 혹시나 클래스내에서 생성자를 사용할 경우를 방지한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123;		</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>cf.</strong> <em>Code with <a href="https://projectlombok.org/features/experimental/UtilityClass.html" rel="external nofollow noopener noreferrer" target="_blank">Lombok</a></em></p>
<ul>
<li>필드, 메서드를 static으로 변환</li>
<li>private 생성자 추가</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@UtilityClass</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION  = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> VERSION;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="규칙-5-불필요한-객체는-만들지-말라"><a href="#규칙-5-불필요한-객체는-만들지-말라" class="headerlink" title="규칙 5. 불필요한 객체는 만들지 말라"></a>규칙 5. 불필요한 객체는 만들지 말라</h2><ul>
<li>변경 불가능(immutable) 객체는 언제나 재용사할수 있다.(<a href="#item15">규칙 15</a>)</li>
<li><p><em>Bad Practice</em> 코드는 실행될 때마다 <code>String</code> 객체를 만드는 쓸데없는 짓을 한다. loop 도는 만큰 <code>String</code> 객체를 생성한다. <em>Good Practices</em>는 실행할 때마다 객체를 생성하지 않고, 동일한 <code>String</code> 객체를 사용한다. 같은 가상머신에서 실행되는 모든 코드가 해당 객체를 사용한다(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5" rel="external nofollow noopener noreferrer" target="_blank">JLS, 3.10.5</a>).</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</div><div class="line">  <span class="comment">// Bad Practice</span></div><div class="line">  System.out.println(<span class="keyword">new</span> String(<span class="string">"test"</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Good Practice</span></div><div class="line">  System.out.println(<span class="string">"test"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Static Factory Method(<a href="#item1">규칙 1</a>)를 이용하면 불필요한 객체 생성을 피할 수 있다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Boolean.valueOf(String)</div></pre></td></tr></table></figure>
</li>
<li><p>변경 가능한 객체이지만 변경할 일이 없다면 재사용한다.</p>
<p>  <em>AS-IS</em></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date birthDate;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBabyBoomer</span><span class="params">()</span> </span>&#123;</div><div class="line">    Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">"GMT"</span>));</div><div class="line">    gmtCal.set(<span class="number">1946</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    Date boomStart = gmtCal.getTime();</div><div class="line">    gmtCal.set(<span class="number">1965</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    Date boomEnd = gmtCal.getTime();</div><div class="line">    <span class="keyword">return</span> birthDate.compareTo(boomStart) &gt;= <span class="number">0</span> &amp;&amp; birthDate.compareTo(boomEnd) &lt; <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <em>TO-BE</em></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date birthDate;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Date BOOM_START;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Date BOOM_END;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">"GMT"</span>));</div><div class="line">    gmtCal.set(<span class="number">1946</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    BOOM_START = gmtCal.getTime();</div><div class="line">    gmtCal.set(<span class="number">1965</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    BOOM_END = gmtCal.getTime();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBabyBoomer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> birthDate.compareTo(BOOM_START) &gt;= <span class="number">0</span> &amp;&amp; birthDate.compareTo(BOOM_END) &lt; <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  static initialzer을 하지않고 <a href="#item71">lazy initialization</a> 기법을 사용할 수도 있다. 하지만, 추천하지 않는다. 구현이 복잡해질 뿐더러 <em>TO-BE</em>로 개선한 것 이상으로 성능을 높이기 어렵기 때문이다(<a href="#item55">규칙 55</a>).</p>
</li>
<li><p>어댑터 TO-DO</p>
</li>
<li><p>JDK 1.5 이후, 쓸데없는 객체 생성하는 방법 추가 - autoboxing</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Long sum = <span class="number">0L</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class="line">    sum += i;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <code>sum</code>이 <code>long</code>이 아닌 <code>Long</code>으로 선언되어 있기 때문에 더해질때마다 객체가 생성된다(2^31개 생성). 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않도록 유의하라.</p>
</li>
<li><p>직접 관리하는 객체 풀을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다.</p>
<p>  독자적으로 관리되는 객체풀을 만들면,</p>
<ul>
<li>코드의 복잡성</li>
<li>메모리 요구량 증가</li>
<li>성능 떨어짐: 사용해야할 상황 - <strong>데이터베이스</strong></li>
<li>접속 비용이 큼</li>
<li>라이선스 정책에 따라 연결 수가 제한될 수 있음</li>
</ul>
</li>
<li><p>규칙 39는 방어적 복사<sub>defensive copy</sub>에 관한 것.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 방어적 복사 방법</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</div><div class="line">    <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>규칙 5: “재사용이 가능하다면 새로운 객체는 만들지 말라”</li>
<li><a href="#item39">규칙 39</a>: “새로운 객체를 만들어야 한다면 기존 객체는 재사용하지 말라”<br> 방어적 복사가 요구되는 상황에서 객체를 재사용하는 것은 (쓸데없이 같은 객체를 만드는) 비용보다 훨씬 높다는 것에 유의하자. 필요할 때 방어적 복사본을 만들지 못하면 버그나 보안 결함으로 이어진다. 쓸데 없는 객체들은 고작 코드 스타일과 성능에나 영향을 줄 뿐이다.</li>
</ul>
</li>
</ul>
</div></article></div><div class="addthis_inline_share_toolbox"></div><div class="ad"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins style="display:block" data-ad-client="ca-pub-2402079508512433" data-ad-slot="9218385844" data-ad-format="auto" class="adsbygoogle"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></main><footer><div class="paginator"><a href="/2017/02/21/creating-and-destroying-objects-3/" class="prev">PREV</a><a href="/2017/02/10/creating-and-destroying-objects-1/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'wicksome';
var disqus_identifier = '2017/02/12/creating-and-destroying-objects-2/';
var disqus_title = '이펙티브자바 2장. 객체 생성과 삭제 - 2';
var disqus_url = 'https://wickso.me/2017/02/12/creating-and-destroying-objects-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wicksome.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="https://wickso.me">Yeongjun Kim</a>, powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external nofollow noopener noreferrer">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58fee1a404df6aa5"></script><!-- - font awesome--><script src="https://use.fontawesome.com/25a562aa7c.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-43444044-3",'auto');ga('send','pageview');</script></body></html>