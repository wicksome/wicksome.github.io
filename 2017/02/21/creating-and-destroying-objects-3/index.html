<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 이펙티브자바 2장. 객체 생성과 삭제 - 3 · Wicksome Blog</title><meta name="description" content="chapter 2. Creating and Destroying Objects in effective java"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="canonical" href="https://wickso.me/2017/02/21/creating-and-destroying-objects-3/"><link rel="search" type="application/opensearchdescription+xml" href="https://wickso.me/atom.xml" title="Wicksome Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/categories/slide/" target="_self" class="nav-list-link">SLIDE</a></li><li class="nav-list-item"><a href="https://github.com/wicksome" target="_blank" class="nav-list-link" rel="external nofollow noopener noreferrer">GITHUB</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/yeongjun/" target="_blank" class="nav-list-link" rel="external nofollow noopener noreferrer">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">이펙티브자바 2장. 객체 생성과 삭제 - 3</h1><div class="post-info">2017년 2월 21일<ul class="tags"><li><a href="/tags/java/" title="java" class="tag">java </a></li><li><a href="/tags/effective-java/" title="effective java" class="tag">effective java </a></li></ul></div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/05/13/creating-and-destroying-objects-3/#규칙-6-유효기간이-지난-객체-참조는-폐기하라">규칙 6</a> - 유효기간이 지난 객체 참조는 폐기하라<br><a href="../../../../2017/05/13/creating-and-destroying-objects-3/#규칙-7-종료자-사용을-피하라">규칙 7</a> - 종료자 사용을 피하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-6-유효기간이-지난-객체-참조는-폐기하라"><a href="#규칙-6-유효기간이-지난-객체-참조는-폐기하라" class="headerlink" title="규칙 6. 유효기간이 지난 객체 참조는 폐기하라"></a>규칙 6. 유효기간이 지난 객체 참조는 폐기하라</h2><p><em>e.g. 메모리 누수</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Object[] element = <span class="keyword">new</span> Object[<span class="number">16</span>];</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</div><div class="line">    ensureCapacity();</div><div class="line">    elements[size++] = e;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">    <span class="keyword">return</span> elements[--size];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elements.length == size) &#123;</div><div class="line">      elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>스택이 커졌다가 줄어들 때, 인덱스 값이 size보다 큰 곳에 있는 요소들(쓰레기 값)은 GC가 처리하지 못한다. 스택이 그런 객체에 대한 <em>만기 참조<sub>obsolete reference</sub></em>를 제거하지 않기 때문이다. 만기 참조란 다시 이용되지 않을 참조<sub>reference</sub>를 말한다.</p>
<p>자동적으로 쓰레기 객체를 수집하는 언어에서 발생하는 메모리 누수 문제(≒ 의도치 않은 객체 보유<sub>unintentional object retention</sub>)는 찾아내기 어렵다.</p>
<h4 id="해결방안"><a href="#해결방안" class="headerlink" title="해결방안"></a>해결방안</h4><p>만기 참조를 제거하는 가장 좋은 방법은, 해당 참조가 보관된 변수의 유효범위<sub>socpe</sub>를 최대한 좁게 만들어 벗어나게 두는 것이다(<a href="#item45">규칙 45</a>).</p>
<p>위 예제 Stack과 같이 자체적으로 메모리는 관리하는 경우에는, 쓸 일이 없는 객체 참조는 반드시 null로 바꿔준다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">  Object result = elements[--size];</div><div class="line">  elements[size] = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="흔히-메모리-누수가-발견되는-곳"><a href="#흔히-메모리-누수가-발견되는-곳" class="headerlink" title="흔히 메모리 누수가 발견되는 곳"></a>흔히 메모리 누수가 발견되는 곳</h4><ul>
<li>자체적으로 관리하는 메모리가 있는 클래스</li>
<li>캐시<sub>cache</sub>: 객체 참조를 캐시 안에 넣어 놓고 잊어버리는 일이 많기 때문. (수명이 키에 대한 외부 참조의 수명에 따라 결정되는 상황에는 <em>WeakHashMap</em> 활용)</li>
<li>리스너<sub>listener</sub>등의 역호출자<sub>callback</sub> - 콜백을 명시적으로 제거하지 않을 경우, 적절한 조치를 취하기 전까지 메모리는 점유된 상태. 해결방안으로 콜백에 대한 약한 참조<sub>weak reference</sub>만 저장하는 것(WeakHashMap)</li>
</ul>
<hr>
<h2 id="규칙-7-종료자-사용을-피하라"><a href="#규칙-7-종료자-사용을-피하라" class="headerlink" title="규칙 7. 종료자 사용을 피하라"></a>규칙 7. 종료자 사용을 피하라</h2><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize?"></a>finalize?</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Called by the garbage collector on an object when garbage collection</div><div class="line">   * determines that there are no more references to the object.</div><div class="line">   * ...</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>‼️ <strong>종료자<sub>finalizer</sub>는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.</strong> … 어쨌든 종료자 사용은 피하는 것이 원칙이다.</p>
</blockquote>
<ul>
<li>GC가 객체에 대한 참조가 더 이상 없다고 판단할 때 GC로부터 호출된다. 하지만, 즉시 실행되리라는 보장이 전혀 없다(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6" rel="external nofollow noopener noreferrer" target="_blank">JLS, 12.6</a>). <strong>따라서 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안 된다</strong>(e.g. finalize안에서 파일 닫기).</li>
<li>종료자의 실행시점은 GC 알고리즘에 좌우되는데, 이 알고리즘은 JVM 구현마다 크게 다르다.</li>
<li>종료자의 더딘 실행<sub>tardy finalization</sub>은 단순히 이론적인 문제가 아니다. 클래스에 종료자를 붙여 놓으면, 드문 일이지만 객체 메모리 반환이 지연될 수도 있다.</li>
<li>종료자가 실행되지 않은 객체가 남은 상태로 프로그램이 끝나는 일도 충분히 가능하다. 그러므로 <strong>지속성이 보장되어야 하는 중요 상태 정보<sub>critical persistent state</sub>는 종료자로 갱신하면 안 된다.</strong></li>
<li><code>System.gc()</code>나 <code>System.runFinalization()</code> 같은 메서드는 종료자 실행 가능성을 높여주긴 하지만 보장하지 않는다.</li>
<li><code>System.runFinalizersOnExit()</code>, <code>Runtime.runFinalizersOnExit()</code>는 종료자 실행을 보장하지만, 심각한 결함을 갖고 있어 이미 명세에서 deprecated 되었다.</li>
<li><strong>종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.</strong></li>
<li><strong>명시적인 종료 메서드<sub>termination method</sub>를 하나 정의</strong>하고, 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메서드를 호출하도록 하라. 명심할 것은, 종료 여부를 객체 안에 보관해야 한다(유효하지 않은 객체임을 표시하는 private 필드 선언).</li>
<li><strong>명시적 종료 메서드는 보통 try-finally 문과 함께 쓰인다. 객체 종료를 보장하기 위해서다.</strong> Java1.7부터는 try-with-resources문 제공하기 때문에 finally 블록은 사용하지 않아도 된다(<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" rel="external nofollow noopener noreferrer" target="_blank">try-with-resources</a>).</li>
</ul>
<h4 id="사용하기-적합한-곳"><a href="#사용하기-적합한-곳" class="headerlink" title="사용하기 적합한 곳"></a>사용하기 적합한 곳</h4><ul>
<li><p>명시적 종료 메서드 호출을 잊을 경우를 대비하는 안전망<sub>safety net</sub>으로서의 역할.</p>
<p>  <strong>종료자는 반환되지 않은 자원을 발견하게 될 경우 반드시 log를 남겨야 한다.</strong> 클라이언트 코드에 버그가 있는 것이므로, 고치도록 알려야 하기 때문이다. (추가 비용을 감당하면서 구현할 가치가 있는지 신중하게 생각한다)</p>
</li>
<li><p><em>네이티브 피어<sub>native peer: 일반 자바 객체가 네이티브 메서드를 통해 기능 수행을 위임하는 네이티브 객체</sub></em>와 연결된 객체를 다룰 때.</p>
<p>  네이티브 피어는 일반 객체가 아니므로, 객체가 소멸되더라도 GC는 모른다(GC가 알 수 없을 뿐더라 Java peer가 반환될 때 같이 반환할 수도 없다). 네이티브 피어가 중요한 자원을 점유하고 있지 않다고 가정한다면, 종료자는 그런 객체의 반환에 걸맞다. 즉시 종료되어야 하는 자원을 포함하는 경우에는, 명시적인 종료 메서드를 클래스에 추가해야 한다.</p>
</li>
</ul>
<h4 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h4><ul>
<li><p>finalizer chaining이 자동으로 이루어지지 않는다.</p>
<p>  종료자를 구현한 클래스를 상속받은 경우, 하위 클래스의 종료자는 상위클래스의 종료자를 명시적으로 호출해야 한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ...</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 반드시 호출시키기 위해 try-finally 사용</span></div><div class="line">    <span class="keyword">super</span>.finalize();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>더 나은 방법 - 종료 보호자 패턴</strong></p>
<p>  종료되어야 하는 객체의 클래스마다 안에 종료자를 정의하는 대신 익명 클래스를 활용하는 방법. 이 익명 클래스로 만든 객체를 <em>종료 보호자<sub>finalizer guardian</sub></em>라고 한다. Foo 객체의 참조가 사라지는 순간 종료 보호자도 실행 가능한 상태가 된다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 종료 보호자 숙어(Finalizer Fuardian idiom)</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="comment">// 이 객체는 바깥 객체(Foo)를 종료시키는 역할만 한다</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object finalizerFuardian = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finaliza</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">      <span class="comment">// 바깥 Foo 객체를 종료시킴</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div><div class="addthis_inline_share_toolbox"></div><div class="ad"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins style="display:block" data-ad-client="ca-pub-2402079508512433" data-ad-slot="9218385844" data-ad-format="auto" class="adsbygoogle"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></main><footer><div class="paginator"><a href="/2017/03/11/methods-common-to-all-objects-1/" class="prev">PREV</a><a href="/2017/02/12/creating-and-destroying-objects-2/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'wicksome';
var disqus_identifier = '2017/02/21/creating-and-destroying-objects-3/';
var disqus_title = '이펙티브자바 2장. 객체 생성과 삭제 - 3';
var disqus_url = 'https://wickso.me/2017/02/21/creating-and-destroying-objects-3/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wicksome.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="https://wickso.me">Yeongjun Kim</a>, powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external nofollow noopener noreferrer">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58fee1a404df6aa5"></script><!-- - font awesome--><script src="https://use.fontawesome.com/25a562aa7c.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-43444044-3",'auto');ga('send','pageview');</script></body></html>