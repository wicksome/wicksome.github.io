<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 이펙티브자바 5장. 제네릭 - 2 · Wicksome Blog</title><meta name="description" content="chapter 5. Generics in effective java"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="canonical" href="https://wickso.me/2017/06/14/generics-2/"><link rel="search" type="application/opensearchdescription+xml" href="https://wickso.me/atom.xml" title="Wicksome Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/categories/slide/" target="_self" class="nav-list-link">SLIDE</a></li><li class="nav-list-item"><a href="https://github.com/wicksome" target="_blank" class="nav-list-link" rel="external nofollow noopener noreferrer">GITHUB</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/yeongjun/" target="_blank" class="nav-list-link" rel="external nofollow noopener noreferrer">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">이펙티브자바 5장. 제네릭 - 2</h1><div class="post-info">2017년 6월 14일<ul class="tags"><li><a href="/tags/java/" title="java" class="tag">java </a></li><li><a href="/tags/effective-java/" title="effective java" class="tag">effective java </a></li></ul></div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/06/14/generics-2/#26-가능하면-제네릭-자료형으로-만들-것">규칙 26</a> - 가능하면 제네릭 자료형으로 만들 것<br><a href="../../../../2017/06/14/generics-2/#27-가능하면-제네릭-메서드로-만들-것">규칙 27</a> - 가능하면 제네릭 메서드로 만들 것<br><a href="../../../../2017/06/14/generics-2/#28-한정적-와일드카드를-써서-API-유연성을-높여라">규칙 28</a> - 한정적 와일드카드를 써서 API 유연성을 높여라<br><a href="../../../../2017/06/14/generics-2/#29-">규칙 29</a> - 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="26-가능하면-제네릭-자료형으로-만들-것"><a href="#26-가능하면-제네릭-자료형으로-만들-것" class="headerlink" title="26. 가능하면 제네릭 자료형으로 만들 것"></a>26. 가능하면 제네릭 자료형으로 만들 것</h2><p><strong>제네릭화<sub>gernerification</sub></strong></p>
<p>선언부에 type parameter 추가, 관습적으로 자료형을 나타내는 이름 E(규칙 56)</p>
<p><strong>배열을 사용하는 제네릭 자료형에서 발생하는 오류를 피하는 방법</strong></p>
<p>실체화 불가능 자료형으로는 배열을 생성할 수 없다(규칙 25).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack.java:<span class="number">8</span> generic array creation</div><div class="line">    elements = <span class="keyword">new</span> E[DEFAULT_INITIAL_CAPACITY];</div></pre></td></tr></table></figure>
<ol>
<li><p>Object 배열을 만들어서 제네릭 배열 자료형으로 형변환(cast)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack.java:<span class="number">8</span>: warning: [unchecked] unchecked cast</div><div class="line">found   : Object[], required: E[]</div><div class="line">        elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</div></pre></td></tr></table></figure>
<p> cast를 활용하면 컴파일 오류대신 경고가 발생한다. 문법적으로 문제는 없지만, 일반적으로 형 안전성을 보장하는 방법이 아니다.<br> 하지만 해당 형변환이 프로그램의 형 안전성을 해치지 않는다면 무점검 형변환(unchecked cast)을 한다. 무점검 형전황이 안전함을 증명했다면, 경고를 억제하되 범위는 최소한으로 줄여야 한다(규칙 24).</p>
</li>
<li><p>elements의 자료형을 E[]에서 Object[]로 바꾸는 것이다.</p>
<p> 사용하는 곳마다 Object를 E로 cast 해준다.</p>
</li>
</ol>
<p>제네릭 배열 생성 오류를 피하는 방법중 어떤 것을 쓸지는 취향 문제다. 배열을 사용하는 코드가 클래스 이곳저곳에 흩어져 있다면 첫번째 방법으로는 한번만 형변환하면 되지만, 두 번째는 여기저기서 형변환해야 한다. 그래서 첫 번째 방법이 좀 더 보편적으로 쓰인다[Naftalin07, 6.7]</p>
<p><strong>기타</strong></p>
<ul>
<li>형인자 자료형에 primitive type은 사용할 수 없다. 자바 제네릭 자료형 시스템의 근본적 한계 때문이다. 이런 제약을 피하려면 개체화된 기본 자료형(boxed primitive type)을 사용하면 된다(<a href="">규칙 49</a>).</li>
<li>시간 있을 때마다 기존 자료형을 제네릭 자료형으로 변환하라. 기존 클라이언트 코드를 깨지 않ㄷ고도 새로운 사용자에게 더 좋은 API를 제공할 수 있게 될 것이다(<a href="">규칙 23</a>).</li>
<li><p>형인자를 제한하는 자료형: 아래 코드에서 E를 한정적 형인자(bounded type parameter)라 한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;E extends String&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="27-가능하면-제네릭-메서드로-만들-것"><a href="#27-가능하면-제네릭-메서드로-만들-것" class="headerlink" title="27. 가능하면 제네릭 메서드로 만들 것"></a>27. 가능하면 제네릭 메서드로 만들 것</h2><blockquote>
<p>형인자를 선언하는 type parameter list는 메서드의 수정자(modifier)와 반환값 자료형 사이에 둔다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</div><div class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;E&gt;(s1);</div><div class="line">    result.addAll(s2);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>제네릭 메서드를 호출할 때는 형인자는 전달할 필요가 없다. 컴파일러가 메서드에 전해진 인자의 자료형을 보고 형인자의 값을 알아낸다. 이 과정을 자료형 유추(type inference)라 한다.</p>
<h4 id="generic-singleton-pattern"><a href="#Generic-Singleton-pattern" class="headerlink" title="Generic Singleton pattern"></a>Generic Singleton pattern</h4><p><strong>변경이 불가능하지만 많은 자료형에 적용 가능한 객체를 만들어야 할 때 사용.</strong></p>
<p>제네릭은 자료형 삭제(erasure) 과정을 통해 구현되므로(<a href="">규칙 25</a>) 모든 필요한 형인자화(type parameterization) 과정에 동일 객체를 활용할 수 있는데, 그러려면 우선 필요한 형인자화 과정마다 같은 객체를 나눠주는 정적 팩터리 메서드를 자성해야 한다. 이 패턴은 Collections.reverseOrder 같은 함수 객체(<a href="">규칙 23</a>) 구현에 가장 널리 사용되지만, Collections.emptySet과 같은 컬렉션에도 쓰인다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnaryFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T arg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>항등함수: 받은것 그대로 반환하는 함수<br>제네릭 정적 팰터리 메서드를 사용하면 중복되는 형인자를 제거하여 간결한 코드를 만들 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 제네릭 싱글턴 팩터리 패턴</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> UnaryFunction&lt;Object&gt; IDENTIFY_FUNCTION = <span class="keyword">new</span> UnaryFunction&lt;Object&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(Object arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> arg;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// IDENTIFY_FUNCTION은 무상태 객체고 형인자는 비한정 인자이므로(unbounded)</span></div><div class="line"><span class="comment">// 모든 자료형이 같은 객체를 공유해도 안전하다.</span></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryFunction&lt;T&gt; <span class="title">identityFunction</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (UnaryFunction&lt;T&gt;) IDENTIFY_FUNCTION;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="recursive-type-bound"><a href="#Recursive-type-bound" class="headerlink" title="Recursive type bound"></a>Recursive type bound</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;T extends Comarable&lt;T&gt;&gt;</div></pre></td></tr></table></figure>
<p>위 코드처럼 Type parameter의 범위에 자기자신이 포험된 표현으로, 그 범위가 선언되는 것을 말한다.</p>
<hr>
<h2 id="28-한정적-와일드카드를-써서-api-유연성을-높여라"><a href="#28-한정적-와일드카드를-써서-API-유연성을-높여라" class="headerlink" title="28. 한정적 와일드카드를 써서 API 유연성을 높여라"></a>28. 한정적 와일드카드를 써서 API 유연성을 높여라</h2><p><strong>요약</strong></p>
<ul>
<li><code>Comparable</code>과 <code>Comparator</code>는 소비자이다.</li>
<li><p>유연성을 최대화하려면, 객체 생산자<sub>producer</sub>나 소비자<sub>consumer</sub> 구실을 하는 메서드 인자의 자료형은 와일드 카드 자료형으로 해라.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">PECS (Produce - Extends, Consumer - Super)</div></pre></td></tr></table></figure>
</li>
<li><p>클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스 API가 잘못 설계된 탓을 것이다.</p>
</li>
</ul>
<p><em>에러가 발생하는 코드</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">Iterable&lt;Integer&gt; integers = ...;</div><div class="line">numberStack.pushAll(integers); <span class="comment">// throw exception</span></div></pre></td></tr></table></figure>
<p><em>해결방안</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (E e : src) &#123;</div><div class="line">        push(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!isEmpty()) &#123;</div><div class="line">        dst.add(pop());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>모든 자료형은 자기 자신의 <em>하위 자료형</em>이다.</li>
<li>모든 자료형 E는 자기 자신의 상위 자료형이다([JLS, 4.10]).</li>
</ul>
<p><strong>이원성(duality)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// swap메서드를 선언하는 두 가지 방법</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>간단한 두번째 방법이 더 바람직하다.</li>
<li><code>List&lt;?&gt;</code>에는 null 이외의 어떤 값도 넣을 수 없다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    swapHelper(list, i, j);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 와일드카드 자료형을 포착하기 위한 private helper 메서드</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    list.set(i, list.set(j, list.get(i)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="29-형-안전-다형성-컨테이너를-쓰면-어떨지-따져보라"><a href="#29-형-안전-다형성-컨테이너를-쓰면-어떨지-따져보라" class="headerlink" title="29. 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라"></a>29. 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 형 안전 다형성(heterogeneous) 컨테이너 패턴 - API</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavority</span><span class="params">(Class&lt;T&gt; type)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>보통 형인자는 각 키/값에 대해서 하나씩 필요하다. 하지만 <code>Class</code> 객체로 좀 더 유연하게 사용할 수 있다. 그런 class 리터럴을 <em>자료형 토큰(type token)</em>이라 부른다[Bracha04].</p>
<p>Favorites 객체는 형 안전성을 보장한다. 또한 다형성(heterogeneous)을 갖고 있다. 일반적인 맵과 달리, 모든 키의 자료형이 서로 다르다. 따라서 이러한 클래스를 <em>형 안전 다형성 컨테이너(typesafe heterogeneous container)</em>라 부른다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 형 안전 다형성(heterogeneous) 컨테이너 패턴 - 구현</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</div><div class="line">        favorites.put(type, type.cast(instance)); <span class="comment">// 값에 동적형변환을 하는 이유: 형 안전성 확보</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavority</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Favorites 객체는 내부적으로 <code>private Map&lt;Class&lt;?&gt;, Object&gt;</code> 형의 favorites 필드를 이용한다. 그런데 비한정적 와일드카드 자료형을 사용했으니 이 맵에는 아무것도 넣을 수 없을 것 같지만, 와일드카드 자료형이 쓰인 곳은 맵이 아니라 키다. 다형성이 드러나는 곳이 이곳이다.</li>
<li><p>favorites 맵의 값 자료형이 Object인데, 키와 값 사이의 자료형이 일치되는 것을 보장하지 않는다. 하지만 실제로는 자료형이 같다는 것을 알고 있으므로, 저장된 객체를 꺼낼 때 그 사실을 이용할 수 있다. -&gt; 동적 형변환(dynamic cast)</p>
</li>
<li><p>Favorites 클래스의 단점으로 실체화 불가능 자료형(non-reifiable type)에는 쓰일 수 없다(규칙 25). 따라서 <code>String</code>이나 <code>String[]</code>은 저장할 수 있으나 <code>List&lt;String&gt;</code>은 저장할 수 없다. 이유는 <code>List&lt;String&gt;</code>의 Class 객체를 얻을 수 없기 때문이다.</p>
</li>
</ul>
</div></article></div><div class="addthis_inline_share_toolbox"></div><div class="ad"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins style="display:block" data-ad-client="ca-pub-2402079508512433" data-ad-slot="9218385844" data-ad-format="auto" class="adsbygoogle"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></main><footer><div class="paginator"><a href="/2017/05/21/generics-1/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'wicksome';
var disqus_identifier = '2017/06/14/generics-2/';
var disqus_title = '이펙티브자바 5장. 제네릭 - 2';
var disqus_url = 'https://wickso.me/2017/06/14/generics-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wicksome.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="https://wickso.me">Yeongjun Kim</a>, powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external nofollow noopener noreferrer">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58fee1a404df6aa5"></script><!-- - font awesome--><script src="https://use.fontawesome.com/25a562aa7c.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-43444044-3",'auto');ga('send','pageview');</script></body></html>