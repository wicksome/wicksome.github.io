<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wicksome Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wickso.me/"/>
  <updated>2017-06-28T02:27:38.000Z</updated>
  <id>https://wickso.me/</id>
  
  <author>
    <name>Yeongjun Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>이펙티브자바 5장. 제네릭 - 2</title>
    <link href="https://wickso.me/2017/06/14/generics-2/"/>
    <id>https://wickso.me/2017/06/14/generics-2/</id>
    <published>2017-06-14T01:00:00.000Z</published>
    <updated>2017-06-28T02:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/06/14/generics-2/#26-가능하면-제네릭-자료형으로-만들-것">규칙 26</a> - 가능하면 제네릭 자료형으로 만들 것<br><a href="../../../../2017/06/14/generics-2/#27-가능하면-제네릭-메서드로-만들-것">규칙 27</a> - 가능하면 제네릭 메서드로 만들 것<br><a href="../../../../2017/06/14/generics-2/#28-한정적-와일드카드를-써서-API-유연성을-높여라">규칙 28</a> - 한정적 와일드카드를 써서 API 유연성을 높여라<br><a href="../../../../2017/06/14/generics-2/#29-">규칙 29</a> - 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="26-가능하면-제네릭-자료형으로-만들-것"><a href="#26-가능하면-제네릭-자료형으로-만들-것" class="headerlink" title="26. 가능하면 제네릭 자료형으로 만들 것"></a>26. 가능하면 제네릭 자료형으로 만들 것</h2><p><strong>제네릭화<sub>gernerification</sub></strong></p>
<p>선언부에 type parameter 추가, 관습적으로 자료형을 나타내는 이름 E(규칙 56)</p>
<p><strong>배열을 사용하는 제네릭 자료형에서 발생하는 오류를 피하는 방법</strong></p>
<p>실체화 불가능 자료형으로는 배열을 생성할 수 없다(규칙 25).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack.java:<span class="number">8</span> generic array creation</div><div class="line">    elements = <span class="keyword">new</span> E[DEFAULT_INITIAL_CAPACITY];</div></pre></td></tr></table></figure>
<ol>
<li><p>Object 배열을 만들어서 제네릭 배열 자료형으로 형변환(cast)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack.java:<span class="number">8</span>: warning: [unchecked] unchecked cast</div><div class="line">found   : Object[], required: E[]</div><div class="line">        elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</div></pre></td></tr></table></figure>
<p> cast를 활용하면 컴파일 오류대신 경고가 발생한다. 문법적으로 문제는 없지만, 일반적으로 형 안전성을 보장하는 방법이 아니다.<br> 하지만 해당 형변환이 프로그램의 형 안전성을 해치지 않는다면 무점검 형변환(unchecked cast)을 한다. 무점검 형전황이 안전함을 증명했다면, 경고를 억제하되 범위는 최소한으로 줄여야 한다(규칙 24).</p>
</li>
<li><p>elements의 자료형을 E[]에서 Object[]로 바꾸는 것이다.</p>
<p> 사용하는 곳마다 Object를 E로 cast 해준다.</p>
</li>
</ol>
<p>제네릭 배열 생성 오류를 피하는 방법중 어떤 것을 쓸지는 취향 문제다. 배열을 사용하는 코드가 클래스 이곳저곳에 흩어져 있다면 첫번째 방법으로는 한번만 형변환하면 되지만, 두 번째는 여기저기서 형변환해야 한다. 그래서 첫 번째 방법이 좀 더 보편적으로 쓰인다[Naftalin07, 6.7]</p>
<p><strong>기타</strong></p>
<ul>
<li>형인자 자료형에 primitive type은 사용할 수 없다. 자바 제네릭 자료형 시스템의 근본적 한계 때문이다. 이런 제약을 피하려면 개체화된 기본 자료형(boxed primitive type)을 사용하면 된다(<a href="">규칙 49</a>).</li>
<li>시간 있을 때마다 기존 자료형을 제네릭 자료형으로 변환하라. 기존 클라이언트 코드를 깨지 않ㄷ고도 새로운 사용자에게 더 좋은 API를 제공할 수 있게 될 것이다(<a href="">규칙 23</a>).</li>
<li><p>형인자를 제한하는 자료형: 아래 코드에서 E를 한정적 형인자(bounded type parameter)라 한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;E extends String&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="27-가능하면-제네릭-메서드로-만들-것"><a href="#27-가능하면-제네릭-메서드로-만들-것" class="headerlink" title="27. 가능하면 제네릭 메서드로 만들 것"></a>27. 가능하면 제네릭 메서드로 만들 것</h2><blockquote>
<p>형인자를 선언하는 type parameter list는 메서드의 수정자(modifier)와 반환값 자료형 사이에 둔다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</div><div class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;E&gt;(s1);</div><div class="line">    result.addAll(s2);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>제네릭 메서드를 호출할 때는 형인자는 전달할 필요가 없다. 컴파일러가 메서드에 전해진 인자의 자료형을 보고 형인자의 값을 알아낸다. 이 과정을 자료형 유추(type inference)라 한다.</p>
<h4 id="generic-singleton-pattern"><a href="#Generic-Singleton-pattern" class="headerlink" title="Generic Singleton pattern"></a>Generic Singleton pattern</h4><p><strong>변경이 불가능하지만 많은 자료형에 적용 가능한 객체를 만들어야 할 때 사용.</strong></p>
<p>제네릭은 자료형 삭제(erasure) 과정을 통해 구현되므로(<a href="">규칙 25</a>) 모든 필요한 형인자화(type parameterization) 과정에 동일 객체를 활용할 수 있는데, 그러려면 우선 필요한 형인자화 과정마다 같은 객체를 나눠주는 정적 팩터리 메서드를 자성해야 한다. 이 패턴은 Collections.reverseOrder 같은 함수 객체(<a href="">규칙 23</a>) 구현에 가장 널리 사용되지만, Collections.emptySet과 같은 컬렉션에도 쓰인다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnaryFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T arg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>항등함수: 받은것 그대로 반환하는 함수<br>제네릭 정적 팰터리 메서드를 사용하면 중복되는 형인자를 제거하여 간결한 코드를 만들 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 제네릭 싱글턴 팩터리 패턴</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> UnaryFunction&lt;Object&gt; IDENTIFY_FUNCTION = <span class="keyword">new</span> UnaryFunction&lt;Object&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(Object arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> arg;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// IDENTIFY_FUNCTION은 무상태 객체고 형인자는 비한정 인자이므로(unbounded)</span></div><div class="line"><span class="comment">// 모든 자료형이 같은 객체를 공유해도 안전하다.</span></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryFunction&lt;T&gt; <span class="title">identityFunction</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (UnaryFunction&lt;T&gt;) IDENTIFY_FUNCTION;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="recursive-type-bound"><a href="#Recursive-type-bound" class="headerlink" title="Recursive type bound"></a>Recursive type bound</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;T extends Comarable&lt;T&gt;&gt;</div></pre></td></tr></table></figure>
<p>위 코드처럼 Type parameter의 범위에 자기자신이 포험된 표현으로, 그 범위가 선언되는 것을 말한다.</p>
<hr>
<h2 id="28-한정적-와일드카드를-써서-api-유연성을-높여라"><a href="#28-한정적-와일드카드를-써서-API-유연성을-높여라" class="headerlink" title="28. 한정적 와일드카드를 써서 API 유연성을 높여라"></a>28. 한정적 와일드카드를 써서 API 유연성을 높여라</h2><p><strong>요약</strong></p>
<ul>
<li><code>Comparable</code>과 <code>Comparator</code>는 소비자이다.</li>
<li><p>유연성을 최대화하려면, 객체 생산자<sub>producer</sub>나 소비자<sub>consumer</sub> 구실을 하는 메서드 인자의 자료형은 와일드 카드 자료형으로 해라.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">PECS (Produce - Extends, Consumer - Super)</div></pre></td></tr></table></figure>
</li>
<li><p>클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스 API가 잘못 설계된 탓을 것이다.</p>
</li>
</ul>
<p><em>에러가 발생하는 코드</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">Iterable&lt;Integer&gt; integers = ...;</div><div class="line">numberStack.pushAll(integers); <span class="comment">// throw exception</span></div></pre></td></tr></table></figure>
<p><em>해결방안</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (E e : src) &#123;</div><div class="line">        push(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!isEmpty()) &#123;</div><div class="line">        dst.add(pop());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>모든 자료형은 자기 자신의 <em>하위 자료형</em>이다.</li>
<li>모든 자료형 E는 자기 자신의 상위 자료형이다([JLS, 4.10]).</li>
</ul>
<p><strong>이원성(duality)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// swap메서드를 선언하는 두 가지 방법</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>간단한 두번째 방법이 더 바람직하다.</li>
<li><code>List&lt;?&gt;</code>에는 null 이외의 어떤 값도 넣을 수 없다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    swapHelper(list, i, j);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 와일드카드 자료형을 포착하기 위한 private helper 메서드</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    list.set(i, list.set(j, list.get(i)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="29-형-안전-다형성-컨테이너를-쓰면-어떨지-따져보라"><a href="#29-형-안전-다형성-컨테이너를-쓰면-어떨지-따져보라" class="headerlink" title="29. 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라"></a>29. 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 형 안전 다형성(heterogeneous) 컨테이너 패턴 - API</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavority</span><span class="params">(Class&lt;T&gt; type)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>보통 형인자는 각 키/값에 대해서 하나씩 필요하다. 하지만 <code>Class</code> 객체로 좀 더 유연하게 사용할 수 있다. 그런 class 리터럴을 <em>자료형 토큰(type token)</em>이라 부른다[Bracha04].</p>
<p>Favorites 객체는 형 안전성을 보장한다. 또한 다형성(heterogeneous)을 갖고 있다. 일반적인 맵과 달리, 모든 키의 자료형이 서로 다르다. 따라서 이러한 클래스를 <em>형 안전 다형성 컨테이너(typesafe heterogeneous container)</em>라 부른다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 형 안전 다형성(heterogeneous) 컨테이너 패턴 - 구현</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</div><div class="line">        favorites.put(type, type.cast(instance)); <span class="comment">// 값에 동적형변환을 하는 이유: 형 안전성 확보</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavority</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Favorites 객체는 내부적으로 <code>private Map&lt;Class&lt;?&gt;, Object&gt;</code> 형의 favorites 필드를 이용한다. 그런데 비한정적 와일드카드 자료형을 사용했으니 이 맵에는 아무것도 넣을 수 없을 것 같지만, 와일드카드 자료형이 쓰인 곳은 맵이 아니라 키다. 다형성이 드러나는 곳이 이곳이다.</li>
<li><p>favorites 맵의 값 자료형이 Object인데, 키와 값 사이의 자료형이 일치되는 것을 보장하지 않는다. 하지만 실제로는 자료형이 같다는 것을 알고 있으므로, 저장된 객체를 꺼낼 때 그 사실을 이용할 수 있다. -&gt; 동적 형변환(dynamic cast)</p>
</li>
<li><p>Favorites 클래스의 단점으로 실체화 불가능 자료형(non-reifiable type)에는 쓰일 수 없다(규칙 25). 따라서 <code>String</code>이나 <code>String[]</code>은 저장할 수 있으나 <code>List&lt;String&gt;</code>은 저장할 수 없다. 이유는 <code>List&lt;String&gt;</code>의 Class 객체를 얻을 수 없기 때문이다.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/06/14/generics-2/#26-가능하면-제네릭-자료형으로-만들-것&quot;&gt;규칙 26&lt;/a&gt; - 가능하면 제네릭 자료형으로 만들 것&lt;br&gt;&lt;a href=&quot;../../../../2017/06/14/generics-2/#27-가능하면-제네릭-메서드로-만들-것&quot;&gt;규칙 27&lt;/a&gt; - 가능하면 제네릭 메서드로 만들 것&lt;br&gt;&lt;a href=&quot;../../../../2017/06/14/generics-2/#28-한정적-와일드카드를-써서-API-유연성을-높여라&quot;&gt;규칙 28&lt;/a&gt; - 한정적 와일드카드를 써서 API 유연성을 높여라&lt;br&gt;&lt;a href=&quot;../../../../2017/06/14/generics-2/#29-&quot;&gt;규칙 29&lt;/a&gt; - 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 5장. 제네릭 - 1</title>
    <link href="https://wickso.me/2017/05/21/generics-1/"/>
    <id>https://wickso.me/2017/05/21/generics-1/</id>
    <published>2017-05-21T01:00:00.000Z</published>
    <updated>2017-08-05T08:26:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/05/21/generics-1/#23-새-코드에는-무인자-제네릭-자료형을-사용하지-마라">규칙 23</a> - 새 코드에는 무인자 제네릭 자료형을 사용하지 마라<br><a href="../../../../2017/05/21/generics-1/#24-무점검-경고-unchecked-warning-를-제거하라">규칙 24</a> - 무점검 경고(unchecked warning)를 제거하라<br><a href="../../../../2017/05/21/generics-1/#25-배열-대신-리스트를-써라">규칙 25</a> - 배열 대신 리스트를 써라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h4 id="제네릭-관련-규칙-목록"><a href="#제네릭-관련-규칙-목록" class="headerlink" title="제네릭 관련 규칙 목록"></a>제네릭 관련 규칙 목록</h4><table>
<thead>
<tr>
<th>용어</th>
<th>예</th>
<th>규칙</th>
</tr>
</thead>
<tbody>
<tr>
<td>형인자 자료형<sub>parameterized type</sub></td>
<td><code>List&lt;String&gt;</code></td>
<td>23</td>
</tr>
<tr>
<td>실 형인자<sub>actual type parameter</sub></td>
<td><code>String</code></td>
<td>23</td>
</tr>
<tr>
<td>제네릭 자료형<sub>generic type</sub></td>
<td><code>List&lt;E&gt;</code></td>
<td>23, 26</td>
</tr>
<tr>
<td>형식 형인자<sub>formal type parameter</sub></td>
<td><code>E</code></td>
<td>23</td>
</tr>
<tr>
<td>비한정적 와일드 카드 자료형<sub>unbounded wildcard type</sub></td>
<td><code>List&lt;?&gt;</code></td>
<td>23</td>
</tr>
<tr>
<td>무인자 자료형<sub>row type</sub></td>
<td><code>List</code></td>
<td>23</td>
</tr>
<tr>
<td>한정적 형인자<sub>bounded type parameter</sub></td>
<td><code>&lt;E extends Number&gt;</code></td>
<td>276</td>
</tr>
<tr>
<td>재귀적 형 한정<sub>recursive type bound</sub></td>
<td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td>
<td>27</td>
</tr>
<tr>
<td>한정적 와일드카드 자료형<sub>bounded wildcard type</sub></td>
<td><code>List&lt;? extends Number&gt;</code></td>
<td>28</td>
</tr>
<tr>
<td>제네릭 메서드<sub>generic method</sub></td>
<td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td>
<td>27</td>
</tr>
<tr>
<td>자료형 토큰<sub>type token</sub></td>
<td><code>String.class</code></td>
<td>29</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="23-새-코드에는-무인자-제네릭-자료형을-사용하지-마라"><a href="#23-새-코드에는-무인자-제네릭-자료형을-사용하지-마라" class="headerlink" title="23. 새 코드에는 무인자 제네릭 자료형을 사용하지 마라"></a>23. 새 코드에는 무인자 제네릭 자료형을 사용하지 마라</h2><blockquote>
<p>Java 1.5부터 사용</p>
</blockquote>
<h4 id="제네릭generic-클래스인터페이스-제네릭-자료형generic-type"><a href="#제네릭generic-클래스-인터페이스-제네릭-자료형generic-type" class="headerlink" title="제네릭generic 클래스/인터페이스 = 제네릭 자료형generic type"></a>제네릭<sub>generic</sub> 클래스/인터페이스 = 제네릭 자료형<sub>generic type</sub></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>선언부에 형인자<sub>type parameter</sub>가 포함된 클래스나 인터페이스를 말한다[JLS, 8.1.2, 9.1.2].</li>
<li>“E의 리스트”라고 읽는다.</li>
</ul>
<h4 id="형인자-자료형parameterized-type"><a href="#형인자-자료형parameterized-type" class="headerlink" title="형인자 자료형parameterized type"></a>형인자 자료형<sub>parameterized type</sub></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; stringList = ...;</div></pre></td></tr></table></figure>
<ul>
<li>각 제네릭 자료형은 <em>형인자 자료형</em> 집합을 정의한다.</li>
<li>이 집합은 이름 뒤에 &lt; 와 &gt; 기호로 감싼 <em>실 형인자</em> 목록이 붙은 클래스나 인터페이스 들로 구성되는데, 이 실 인자들은 제네릭 자료형의 <em>형식 형인자</em> 각각에 대응된다[JLS, 4.4, 4.5].</li>
<li>컴파일 할 때 어떤 경고도 뜨지 않아야(또는, suppressing 경고가 없어야 - 규칙 24 참조) 한다.</li>
</ul>
<h4 id="무인자-자료형raw-type"><a href="#무인자-자료형raw-type" class="headerlink" title="무인자 자료형raw type"></a>무인자 자료형<sub>raw type</sub></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List stringList = ...;</div></pre></td></tr></table></figure>
<ul>
<li>무인자 자료형은 실 형인자 없이 사용되는 제네릭 자료형이다[JLS, 4.8].</li>
<li>위 코드에서 <code>List</code>가 무인자 자료형(stringList는 String 객체만 보관되는데 형인자 자료형을 정의하지 않음)  <div class="tip"><br>      <b><code>List</code> vs <code>List&lt;Object&gt;</code></b><br>      <ul><br>          <li><code>List</code>: 형 검사 절차를 완전히 생략</li><br>          <li><code>List&lt;Object&gt;</code>: 아무 객체나 넣을 수 있다는 것을 컴파일에게 알림</li><br>      </ul><br>  </div></li>
<li><strong>이렇게 사용하지 말자</strong>(엉뚱한 자료형의 객체를 넣어도 컴파일 시에는 문제가 없다).</li>
<li>무인자 자료형을 쓰면 형 안전성이 사라지고, 제네릭의 장점 중 하나인 표현력<sub>expreesiveness</sub> 측면에서 손해를 보게 된다.<ul>
<li>이전 호환성<sub>migration compatibility</sub>으로 알려지니 이 요구사항 때문에 무인자 자료형을 지원할 뿐</li>
</ul>
</li>
</ul>
<h4 id="비한정적-와일드카드-자료형unbounded-wildcard-type"><a href="#비한정적-와일드카드-자료형unbounded-wildcard-type" class="headerlink" title="비한정적 와일드카드 자료형unbounded wildcard type"></a>비한정적 와일드카드 자료형<sub>unbounded wildcard type</sub></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numElementsInCommon</span><span class="params">(Set&lt;?&gt; s1, Set&lt;?&gt; s2)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Object o1: s1)</div><div class="line">        <span class="keyword">if</span> (s2.contains(o1))</div><div class="line">            result++;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>제네릭 자료형을 쓰고 싶으나 실제 형 인자가 무엇인지 모르거나 신경 쓰고 싶지 않을 때 ‘?’ 사용</li>
<li>그러나, Collection&lt;?&gt;에는 null 이외의 어떤 원소도 넣을 수 없다<ul>
<li>(옮긴이) 어떤 자료형의 객체를 담는 컬렉션인지 알 방법이 없기 때문이다.</li>
<li>TODO: 자세한 내용 확인해볼 것</li>
</ul>
</li>
</ul>
<h4 id="예외"><a href="#예외" class="headerlink" title="예외"></a>예외</h4><p>제네릭 자료형 정보가 프로그램이 실행될 때는 지워지기 때문에(타입소거<sub>type erasure</sub>) 생긴 예외들(규칙 25)</p>
<p><strong>클래스 리터럴<sub>class literal</sub>에는 반드시 무인자 자료형을 사용해야 한다.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 가능</span></div><div class="line">List.class</div><div class="line">String[].class <span class="comment">// 배열 자료형 가능</span></div><div class="line"><span class="keyword">int</span>.class <span class="comment">// 기본 자료형 가능</span></div><div class="line"></div><div class="line"><span class="comment">// 불가능</span></div><div class="line">List&lt;String&gt;.class</div><div class="line">List&lt;?&gt;.class</div></pre></td></tr></table></figure>
<ul>
<li>자바 표준에 따르면, 클래스 리터럴에는 형인자 자료형을 쓸 수 없다[JLS, 15.8.2].</li>
</ul>
<p><strong>제네릭 자료형에 instanceof 연산자를 적용할 때는 다음과 같이 하는 것이 좋다.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set) &#123;     <span class="comment">// 무인자 자료형</span></div><div class="line">    Set&lt;?&gt; m = (Set&lt;?&gt;) o;  <span class="comment">// 와일드카드 자료형</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>실행시 타입소거되기 때문에, instanceof 연산자를 비한정적 와일드 카드 자료형이 이외의 형인자 자료형에 적용할 수 없다.</li>
<li>무인자 자료형 대신 비한정적 와일드카드 자료형을 쓴다고 해서 instanceof 연산자가 다르게 동작하는 것은 아니다.</li>
<li>따라서 &lt;?&gt;를 붙혀봐야 코드만 지저분해질 뿐이다.</li>
</ul>
<hr>
<h2 id="24-무점검-경고unchecked-warning를-제거하라"><a href="#24-무점검-경고-unchecked-warning-를-제거하라" class="headerlink" title="24. 무점검 경고(unchecked warning)를 제거하라"></a>24. 무점검 경고(unchecked warning)를 제거하라</h2><blockquote>
<p>무점검 경고<sub>unchecked warning</sub>는 중요하다. 무시하지 마라.</p>
</blockquote>
<ul>
<li>모든 무점검 경고는 가능하다면 없애야 한다.<ul>
<li>전부 없애고 나면 코드의 형 안전서이 보장되는 것</li>
<li>실행 도중 ClassCastException이 발생하지 않을 것</li>
</ul>
</li>
<li>제거할 수 없는 경고 메시지는 형 안전성이 확실할 때만 @SupressWarnings(“unchecked”) 어노테이션을 사용해 억제한다<ul>
<li>SupressWarnings 어노테이션은 가능한 작은 범위에 적용하라.</li>
<li>SupressWarnings 어노테이션은 return 문에는 붙일 수 없는데, 선언문이 아니기 떄문이다[<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7" rel="external nofollow noopener noreferrer" target="_blank">JLS, 9.7</a>].</li>
</ul>
</li>
<li>@SupressWarnings(“unchecked”) 어노테이션을 사용할 때마다, 왜 형 안정성을 위반하지 않는지 밝히는 주석을 반드시 붙여라</li>
</ul>
<hr>
<h2 id="25-배열-대신-리스트를-써라"><a href="#25-배열-대신-리스트를-써라" class="headerlink" title="25. 배열 대신 리스트를 써라"></a>25. 배열 대신 리스트를 써라</h2><h4 id="배열-vs-제네릭-자료형"><a href="#배열-vs-제네릭-자료형" class="headerlink" title="배열 vs 제네릭 자료형"></a>배열 vs 제네릭 자료형</h4><ul>
<li>배열은 <em>공변 자료형<sub>covariant</sub></em>: <code>class Sub extends Super {}</code>일 때, <code>Sub[]</code>도 <code>Super[]</code>의 하위 자료형이다.</li>
<li>제네릭은 <em>불변 자료형<sub>invariant</sub></em>: <code>List&lt;Sub&gt;</code>은 <code>List&lt;Super&gt;</code>의 하위 자료형이 될 수 없다.</li>
</ul>
<p>아래 코드와 같이, 배열의 경우에는 문법적으로는 문제가 없어 실행중에 예외가 발생하고, 제네릭은 컴파일이 되지 않는다. 즉, 제네릭보다 배열이 취약하다(컴파일시에 문제를 발견하는 편이 더 낫다).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 실행중에 예외 발생</span></div><div class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</div><div class="line">objectArray[<span class="number">0</span>] = <span class="string">"I dont's fit in"</span>; <span class="comment">// ArrayStoreException 발생</span></div><div class="line"></div><div class="line"><span class="comment">// 컴파일 되지 않는 코드</span></div><div class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;(); <span class="comment">// 자료형 불일치</span></div><div class="line">ol.add(<span class="string">"I don't fit in"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>배열은 <em>실체화<sub>reification</sub></em> 되는 자료형이다[<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.7" rel="external nofollow noopener noreferrer" target="_blank">JLS, 4.7</a>].<ul>
<li>즉, 배열의 각 원소의 자료형은 실행시간에 결정</li>
</ul>
</li>
<li>제네릭은 삭제<sub>erasure</sub> 과정을 통해 구현된다[<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6" rel="external nofollow noopener noreferrer" target="_blank">JLS, 4.6</a>].</li>
</ul>
<h4 id="generic-array-creation-오류"><a href="#generic-array-creation-오류" class="headerlink" title="generic array creation 오류"></a>generic array creation 오류</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> List&lt;E&gt;[]</div><div class="line"><span class="keyword">new</span> List&lt;String&gt;[]</div><div class="line"><span class="keyword">new</span> E[]</div></pre></td></tr></table></figure>
<p>위 코드는 전부 컴파일되지 않는다. 컴파일하려고 하면 <code>getneric array creation</code> 오류가 발생할 것이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/05/21/generics-1/#23-새-코드에는-무인자-제네릭-자료형을-사용하지-마라&quot;&gt;규칙 23&lt;/a&gt; - 새 코드에는 무인자 제네릭 자료형을 사용하지 마라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/21/generics-1/#24-무점검-경고-unchecked-warning-를-제거하라&quot;&gt;규칙 24&lt;/a&gt; - 무점검 경고(unchecked warning)를 제거하라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/21/generics-1/#25-배열-대신-리스트를-써라&quot;&gt;규칙 25&lt;/a&gt; - 배열 대신 리스트를 써라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 4장. 클래스와 인터페이스 - 3</title>
    <link href="https://wickso.me/2017/05/15/classes-and-interfaces-3/"/>
    <id>https://wickso.me/2017/05/15/classes-and-interfaces-3/</id>
    <published>2017-05-15T01:20:00.000Z</published>
    <updated>2017-05-17T03:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/05/15/classes-and-interfaces-3/#19-인터페이스는-자료형을-정의할-때만-사용하라">규칙 19</a> - 인터페이스는 자료형을 정의할 때만 사용하라<br><a href="../../../../2017/05/15/classes-and-interfaces-3/#20-태그-달린-클래스-대신-클래스-계층을-활용하라">규칙 20</a> - 태그 달린 클래스 대신 클래스 계층을 활용하라<br><a href="../../../../2017/05/15/classes-and-interfaces-3/#21-전략을-표현하고-싶을-때는-함수-객체를-사용하라">규칙 21</a> - 전략을 표현하고 싶을 때는 함수 객체를 사용하라<br><a href="../../../../2017/05/15/classes-and-interfaces-3/#22-멤버-클래스는-가능하면-static으로-선언하라">규칙 22</a> - 멤버 클래스는 가능하면 static으로 선언하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="19-인터페이스는-자료형을-정의할-때만-사용하라"><a href="#19-인터페이스는-자료형을-정의할-때만-사용하라" class="headerlink" title="19. 인터페이스는 자료형을 정의할 때만 사용하라"></a>19. 인터페이스는 자료형을 정의할 때만 사용하라</h2><ul>
<li><p><strong>상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다.</strong> 클래스가 어떤 상수를 어떻게 사용하느냐 하는 것은 구현 세부사항이다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhysicalConstants</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> AVOGADROS_NUMBER = <span class="number">6.02214199e23</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>상수를 API 일부로 공개하고 싶을 때는 더 좋은 방법이 있다.</p>
<ul>
<li>해당 상수가 이미 존재하는 클래스나 인터페이스에 강하게 연결되어 있을 때는 해당 클래스/인터페이스에 추가한다.</li>
<li>enum 자료형의 멤버가 되어야 바람직할 때는 enum 자료형과 함께 공개한다.</li>
<li>객체 생성이 불가능한 유틸리티 클래스에 넣어서 공개한다.</li>
</ul>
</li>
<li>인터페이스는 자료형을 정의할 때만 사용해야 한다. 특정 상수를 API의 일부로 공개할 목적으로는 적절치 않다.</li>
</ul>
<hr>
<h2 id="20-태그-달린-클래스-대신-클래스-계층을-활용하라"><a href="#20-태그-달린-클래스-대신-클래스-계층을-활용하라" class="headerlink" title="20. 태그 달린 클래스 대신 클래스 계층을 활용하라"></a>20. 태그 달린 클래스 대신 클래스 계층을 활용하라</h2><h4 id="tagged-class"><a href="#Tagged-Class" class="headerlink" title="Tagged Class"></a>Tagged Class</h4><blockquote>
<p>두 가지 이상의 기능을 가지고 있고, 그중 어떤 기능을 제공하는지 표시하는 tag가 달린 클래스</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</div><div class="line">    <span class="keyword">enum</span> Shape &#123; RECTANGLE, CIRCLE &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 태그 필드</span></div><div class="line">    <span class="keyword">final</span> Shape shape;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> length;</div><div class="line">    <span class="keyword">double</span> width;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> radius;</div><div class="line"></div><div class="line">    <span class="comment">// 원을 만드는 생성자</span></div><div class="line">    Figure(<span class="keyword">double</span> radius) &#123;</div><div class="line">        shape = Shape.CIRCLE;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 사각형을 만드는 생성자</span></div><div class="line">    Figure(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</div><div class="line">        shape = Shape.RECTANGLE;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span>(shape) &#123;</div><div class="line">          <span class="keyword">case</span> RECTANGLE:</div><div class="line">        	<span class="keyword">return</span> length * width;</div><div class="line">          <span class="keyword">case</span> CIRCLE:</div><div class="line">        	<span class="keyword">return</span> Math.PI * (radius * radius);</div><div class="line">          <span class="keyword">default</span>:</div><div class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>문제점</strong></p>
<ul>
<li>수정할 때마다 <code>switch</code>문에 새로운 <code>case</code>를 올바르게 넣어야 한다.</li>
<li>객체의 자료형만 봐서 그 객체가 무슨 기능을 제공하는지 알 수 없다.</li>
<li>boilerplate code가 늘어난다.</li>
<li><strong>오류 발생 가능성이 높아지고, 효율적이지 않다.</strong></li>
</ul>
<h4 id="개선-코드"><a href="#개선-코드" class="headerlink" title="개선 코드"></a>개선 코드</h4><p><em>e.g. 클래스 계층으로 변환한 결과(<a href="#item14">규칙 14</a>)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">double</span> radius;</div><div class="line"></div><div class="line">    Circle(<span class="keyword">double</span> radius) &#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.PI * (radius * radius);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// public 클래스인 경우(규칙 14)</span></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">double</span> length;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">double</span> width;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length * width; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>태그 기반 클래스 사용은 피하라.</li>
<li>태그 기반 클래스를 보게 된다면, 리팩토링을 통해 클래스 계층으로 변환할 방법은 없는지 고민하자.</li>
</ul>
<h2 id="21-전략을-표현하고-싶을-때는-함수-객체를-사용하라"><a href="#21-전략을-표현하고-싶을-때는-함수-객체를-사용하라" class="headerlink" title="21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라"></a>21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라</h2><blockquote>
<p>전략을 표현하고 싶을 때는 함수 객체<sub>function object</sub>를 사용하라<br>함수 객체의 주된 용도는 전략 패턴<sub>Strategy pattern</sub>을 구현하는 것.</p>
</blockquote>
<p><strong>strategy pattern</strong></p>
<ul>
<li>인자로 함수를 넘겨줘서 그 함수를 통해 실행 전략을 세우는 방법. 예를 들어 정렬을 한다고 할때, 어떻게 정렬하는가는 넘겨주는 것이 전략패턴.</li>
<li>Java는 함수를 넘겨 줄수 없으나, 함수를 가지고 있는 객체(=함수 객체)를 넘겨주면 됨</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 전략 인터페이스</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(T t1, T t2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>문자 길이로 하고자 할 때, 익명 클래스로 구현할 수 있으나 매번 필요없는 인스턴스를 생성함</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Arrays.sort(stringArray, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s1)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> s1.length() - s2.length();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>그렇다면, 싱글턴으로 만들어서 사용하는 방법. 의도가 뚜렷한 이름을 정할 수 있는 것도 장점.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Arrays.sort(stringArray, StringLengthComparator.INSTANCE);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringLengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringLengthComparator INSTANCE = <span class="keyword">new</span> StringLengthComparator();</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StringLengthComparator</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s1)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> s1.length() - s2.length();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>java 8 lamdba를 이용하면 코드를 좀 더 줄일 수 있음</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;String&gt; stringLengthComparator = (String s1, String s2) -&gt; s1.length - s2.length;</div><div class="line">Arrays.sort(stringArray, stringLengthComparator);</div></pre></td></tr></table></figure>
<p>전략 인터페이스(<code>Comparator</code>)는 실행 가능 전략 객체들(<code>StringLengthComparator</code>)의 자료형 구실을 한다. 따라서 실행 가능 전략 클래스(<code>StringLengthComparator</code>)는 굳이 public으로 만들어 공개할 필요가 없다. 대신, 전략 인터페이스가 자료형인 public static 필드들을 갖는 “호스트 클래스(host class)”를 정의하는 것도 방법이다. 실행 가능 전략 클래스는 호스트 클래스의 private 중첩 클래스(nested class)로 정의하면 된다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR = (String s1, String s2) -&gt; s1.length - s2.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>String</code> 클래스는 <code>CASE_INSENCITIVE_ORDER</code>라는 필드로 문자열 비교자를 공개함</p>
<hr>
<h2 id="22-멤버-클래스는-가능하면-static으로-선언하라"><a href="#22-멤버-클래스는-가능하면-static으로-선언하라" class="headerlink" title="22. 멤버 클래스는 가능하면 static으로 선언하라"></a>22. 멤버 클래스는 가능하면 static으로 선언하라</h2><h4 id="중첩클래스nested-class-의-종류"><a href="#중첩클래스nested-class-의-종류" class="headerlink" title="중첩클래스nested class 의 종류"></a>중첩클래스<sub>nested class</sub> 의 종류</h4><blockquote>
<p>다른 클래스 안에 정의된 클래스</p>
</blockquote>
<ul>
<li>Static Member Class</li>
<li>Nonstatic Member Class</li>
<li>Anonymous Class</li>
<li>Local Class</li>
</ul>
<h4 id="static-member-class"><a href="#Static-Member-Class" class="headerlink" title="Static Member Class"></a>Static Member Class</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; PrivateStaticMemberClass.print(); &#125; <span class="comment">// (1)</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateStaticMemberClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">            ExternalClass e = <span class="keyword">new</span> ExternalClass();</div><div class="line">            System.out.println(e.value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMemberClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"public"</span>); &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main</span></div><div class="line"><span class="comment">// ExternalClass.PrivateStaticMemberClass.print(); (1) 불가능</span></div><div class="line">ExternalClass.StaticMemberClass.print(); <span class="comment">// (2)</span></div><div class="line">(<span class="keyword">new</span> ExternalClass()).print();</div></pre></td></tr></table></figure>
<ul>
<li>External Class의 모든 맴버에 접근 가능(private 포함)</li>
<li>Static Member Class가 <code>private</code>이라면 External Class에서만 접근 가능 (1)</li>
<li>External Class의 정적맴버 (2)</li>
</ul>
<h4 id="nonstatic-member-class"><a href="#NonStatic-Member-Class" class="headerlink" title="NonStatic Member Class"></a>NonStatic Member Class</h4><ul>
<li>External Class와 독립적으로 존재할 수 있도록 하려면 반드시 <code>static</code>으로 선언</li>
<li>문법으로는 <code>static</code> 여부 차이. 그러나 다르다.</li>
<li><p>External Class와 자동적으로 연결된다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> externalClassValue;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExternalClass</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; <span class="keyword">this</span>.externalClassValue = value; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getExternalClassValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> externalClassValue; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(externalClassValue);</div><div class="line">        NonStaticMemberClass nsmc = <span class="keyword">new</span> NonStaticMemberClass(); <span class="comment">// (3)</span></div><div class="line">        nsmc.setExternalClassValue(<span class="number">3</span>);</div><div class="line">        System.out.println(externalClassValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NonStaticMemberClass</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> nonStaticMemberClassValue;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setExternalClassValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">            ExternalClass.<span class="keyword">this</span>.externalClassValue = value; <span class="comment">// (2)</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main</span></div><div class="line">ExternalClass t = <span class="keyword">new</span> ExternalClass(<span class="number">2</span>);</div><div class="line">t.new NonStaticMemberClass().setExternalClassValue(<span class="number">4</span>); <span class="comment">// (3) 직접 연결도 가능</span></div><div class="line">t.print();</div></pre></td></tr></table></figure>
  <figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 출력결과</span></div><div class="line">4</div><div class="line">3</div></pre></td></tr></table></figure>
<ul>
<li>NonStatic Member Class 안에서 External Class의 메서드 호출 가능 (1)</li>
<li>qualified this로 External Class 객체에 대한 참조 획득 가능 (2)</li>
<li>NonStatic Member Class와 External Class의 연결은 NonStatic Member Class의 객체가 생성될때 확립 (3)</li>
</ul>
</li>
<li><p>Adapter를 정의할 때 많이 사용(External Class를 다른 클래스 객체인 것처럼 보이게하는 용도)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIterator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="anonymous-class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h4><ul>
<li>함수 객체를 정의할 때 널리 쓰인다</li>
<li>표현식 중간에 등장하므로, 10줄 이하로 짧게 작성되어야 한다. 아니면 코드 가독성이 떨어진다</li>
<li><p>nonstatic context 안에서 사용될 때만 External 객체를 갖는다</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> externalClassValue = <span class="number">2</span>;</div><div class="line">    <span class="keyword">private</span> AnonymousClass ac;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAnonymousClassTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        ac = <span class="keyword">new</span> AnonymousClass() &#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">                <span class="keyword">this</span>.value = value;</div><div class="line">                System.out.printf(<span class="string">"Anonymous Class Test %d %d"</span>,</div><div class="line">                ExternalClass.<span class="keyword">this</span>.externalClassValue, <span class="keyword">this</span>.value);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        ac.print(<span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExternalClass t = <span class="keyword">new</span> ExternalClass();</div><div class="line">        t.printAnonymousClassTest();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="local-class"><a href="#Local-Class" class="headerlink" title="Local Class"></a>Local Class</h4><ul>
<li>지역 변수 선언되는 곳에 선언된 클래스</li>
<li><p>static 맴버 불가능, nonstatic context에서만 External Class의 맴버 접근 가능</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> externalClassValue = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLocalClassTest</span><span class="params">()</span> </span>&#123; <span class="comment">// non static context</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalClass</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">      <span class="comment">// private static value; 불가능</span></div><div class="line"></div><div class="line">      LocalClass(<span class="keyword">int</span> value) &#123; <span class="keyword">this</span>.value = value; &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; System.out.println(externalClassValue); &#125; <span class="comment">// External 객체 접근 가능</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LocalClass lc = <span class="keyword">new</span> LocalClass(<span class="number">1</span>);</div><div class="line">    lc.print();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="요약-알아둘-것"><a href="#요약-알아둘-것" class="headerlink" title="요약, 알아둘 것"></a>요약, 알아둘 것</h4><ul>
<li>중첩 클래스를 메서드 밖에서 사용할 수 있어야 하거나, 메서드 안에 놓기에 너무 길 경우 맴버 클래스로 정의</li>
<li>맴버 클래스의 객체들이 External Class의 객체들에 대한 참조를 가져야 하는 경우에서만 NonStatic Member Class로 정의</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/05/15/classes-and-interfaces-3/#19-인터페이스는-자료형을-정의할-때만-사용하라&quot;&gt;규칙 19&lt;/a&gt; - 인터페이스는 자료형을 정의할 때만 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/15/classes-and-interfaces-3/#20-태그-달린-클래스-대신-클래스-계층을-활용하라&quot;&gt;규칙 20&lt;/a&gt; - 태그 달린 클래스 대신 클래스 계층을 활용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/15/classes-and-interfaces-3/#21-전략을-표현하고-싶을-때는-함수-객체를-사용하라&quot;&gt;규칙 21&lt;/a&gt; - 전략을 표현하고 싶을 때는 함수 객체를 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/15/classes-and-interfaces-3/#22-멤버-클래스는-가능하면-static으로-선언하라&quot;&gt;규칙 22&lt;/a&gt; - 멤버 클래스는 가능하면 static으로 선언하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>Template Method Pattern</title>
    <link href="https://wickso.me/2017/05/02/template-method-pattern/"/>
    <id>https://wickso.me/2017/05/02/template-method-pattern/</id>
    <published>2017-05-02T03:57:22.000Z</published>
    <updated>2017-05-21T11:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="의도"><a href="#의도" class="headerlink" title="의도"></a>의도</h2><p>연산<sub>operation</sub>에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다.</p>
<h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p><img src="http://www.cs.unc.edu/~stotts/GOF/hires/Pictures/tmethod.gif" alt="Template Method Pattern"></p>
<h2 id="활용성"><a href="#활용성" class="headerlink" title="활용성"></a>활용성</h2><ul>
<li>어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때</li>
<li>서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93]<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC '93), pages 66–73, Indianapolis, IN, February 1993.
">[1]</span></a></sup> “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다.</li>
<li>서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.</li>
</ul>
<a id="more"></a>
<h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><ul>
<li>템플릿 메서드는 코드 재사용을 위한 기본 기술이다(특히 클라스 라이브러리 구현 시 중요).</li>
<li>템플릿 메서드는 IoC(Inversion of Control, 제어 역전) 구조를 이끌어 낸다. 즉, 부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만 반대 방향의 호출은 안 된다.<blockquote><p>Don’t call us, we’ll call you.</p>
<footer><strong>할리우드 원칙(Hollywood principle)</strong></footer></blockquote></li>
<li>템플릿 메서드는 여러 종류의 연산 중 하나를 호출한다.<ul>
<li>구체 연산</li>
<li>AbstractClass 구체 연산</li>
<li>기본 연산</li>
<li>factory method</li>
<li>hook operation: 필요하다면 서브클래스에서 활장할 수 있는 기본 행동을 제공하는 연산. 기본적으로 아무 내용도 정의하지 않는다.</li>
</ul>
</li>
</ul>
<h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><ul>
<li><strong>접근제어자를 이용한다.</strong> - 템플릿 메서드에서 호출하는 기본 연산들을 protected로 구현한다. 이렇게 하면 이 연산들은 템플릿 메서드만 호출할 수 있게 된다. 템플릿 메서드는 재정의하면 안되므로 맴버 함수로 만든다(final로 정의하면 재정의 불가능).</li>
<li><strong>기본 연산의 수를 최소화한다.</strong> - 템플릿 메서드를 설계할 때 중요한 목표 중 하나는 서브클래스가 오버라이드해야 하는 연산의 수를 최소화하는 것이다. 재정의해야 하는 메서드가 많아질수록 사용자는 불편해진다.</li>
<li><strong>네이밍 규칙을 만든다.</strong> - 재정의 연산에 접두어를 추가하여 식별이 잘되도록 할 수 있다. 예를 들어, 매킨토시 응용프로그램의 MapAPP프레임워크[App89]<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994.
">[2]</span></a></sup>의 모든 템플릿 메서드는 <code>Do-</code>로 시작한다. <code>DoCreateDocument</code>, <code>DoRead</code></li>
</ul>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>문서 관리 응용프로그램이 새 문서를 만드는 경우로 예를 들어 보자. 모든 응용프로그램은 파일을 생성하기 전에 파일 존재 확인과 권한 확인을 하며, 특정 응용프로그램은 파일을 열기전에 로그를 출력해야 한다.</p>
<p>이런 경우에 <code>openNewDocument()</code> 템플릿 메서드를 사용할 수 있다. <code>Application.java</code>는 항상 확인해야할 연산(파일 존재 확인, 권한 확인)을 추상 메서드로 정의하고 템플릿 메서드에서 수행한다. Application에서 <code>beforeCreateDocument()</code>는 hook 연산으로 필요에따라 확장해서 사용 가능하다. 이렇게 함으로</p>
<p>추상 연산을 통해 알고리즘의 일부를 정의함으로써, 템플릿 메서드는 각 단계의 순서는 고정하되 각각의 서브클래스는 필요에 따라 이들 단계의 처리를 다양화시킬 수 있다.</p>
<p><em>Application.java(AbstractClass)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">newDcument</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> createDocument(); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Document <span class="title">createDocument</span><span class="params">()</span></span>; <span class="comment">// factory method</span></div><div class="line"></div><div class="line">  <span class="comment">// template method</span></div><div class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> Document <span class="title">openNewDocument</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!existDocument(fileName)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The file doesn't exist: "</span> + fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!canOpenDocument(fileName)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"can't open the document: "</span> + fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    beforeCreateDocument(); <span class="comment">// hook 연산</span></div><div class="line">    Document document = createDocument(); <span class="comment">// template method에서 factory method가 호출된다.</span></div><div class="line">    document.setFileName(fileName);</div><div class="line">    <span class="keyword">return</span> document;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String fileName)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">canOpenDocument</span><span class="params">(String fileName)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeCreateDocument</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// hook: 기본적으로 아무 내용도 정의하지 않는다.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>MyApplication.java(ConcreteClass)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PATH = <span class="string">"/local/path/base"</span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCreateDocument</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"create document"</span>); &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">createDocument</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> WordDocument(); &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> File(BASE_PATH + fileName)).exists();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>[<a href="http://wiki.c2.com/?GangOfFour" rel="external nofollow noopener noreferrer" target="_blank">GOF</a>{kr}:419] - 템플릿 메서드</li><br>        <li>GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.</li><br>    </ul><br></div>

<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC ‘93), pages 66–73, Indianapolis, IN, February 1993.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994.<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;의도&quot;&gt;&lt;a href=&quot;#의도&quot; class=&quot;headerlink&quot; title=&quot;의도&quot;&gt;&lt;/a&gt;의도&lt;/h2&gt;&lt;p&gt;연산&lt;sub&gt;operation&lt;/sub&gt;에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다.&lt;/p&gt;
&lt;h2 id=&quot;구조&quot;&gt;&lt;a href=&quot;#구조&quot; class=&quot;headerlink&quot; title=&quot;구조&quot;&gt;&lt;/a&gt;구조&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.cs.unc.edu/~stotts/GOF/hires/Pictures/tmethod.gif&quot; alt=&quot;Template Method Pattern&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;활용성&quot;&gt;&lt;a href=&quot;#활용성&quot; class=&quot;headerlink&quot; title=&quot;활용성&quot;&gt;&lt;/a&gt;활용성&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때&lt;/li&gt;
&lt;li&gt;서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93]&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-right hint--error hint--large&quot; aria-label=&quot;William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC &#39;93), pages 66–73, Indianapolis, IN, February 1993.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다.&lt;/li&gt;
&lt;li&gt;서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="design pattern" scheme="https://wickso.me/tags/design-pattern/"/>
    
      <category term="befavioral pattern" scheme="https://wickso.me/tags/befavioral-pattern/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 4장. 클래스와 인터페이스 - 2</title>
    <link href="https://wickso.me/2017/04/12/classes-and-interfaces-2/"/>
    <id>https://wickso.me/2017/04/12/classes-and-interfaces-2/</id>
    <published>2017-04-12T01:00:00.000Z</published>
    <updated>2017-04-12T01:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/04/15/classes-and-interfaces-2/#16-계승하는-대신-구성하라">규칙 16</a> - 계승하는 대신 구성하라<br><a href="../../../../2017/04/15/classes-and-interfaces-2/#17-계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라">규칙 17</a> - 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라<br><a href="../../../../2017/04/15/classes-and-interfaces-2/#18-추상-클래스-대신-인터페이스를-사용하라">규칙 18</a> - 추상 클래스 대신 인터페이스를 사용하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="16-계승하는-대신-구성하라"><a href="#16-계승하는-대신-구성하라" class="headerlink" title="16. 계승하는 대신 구성하라"></a>16. 계승하는 대신 구성하라</h2><p>TODO</p>
<hr>
<h2 id="17-계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라"><a href="#17-계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라" class="headerlink" title="17. 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라"></a>17. 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라</h2><ul>
<li>재정의 가능 메서드를 내부적으로 어떻게 사용하는지 반드시 문서에 남겨라.<ul>
<li>관습적으로, 재정의 가능 메서드를 어떤 식으로 호출하는지는 메서드 주석문 마지막에 명시한다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="18-추상-클래스-대신-인터페이스를-사용하라"><a href="#18-추상-클래스-대신-인터페이스를-사용하라" class="headerlink" title="18. 추상 클래스 대신 인터페이스를 사용하라"></a>18. 추상 클래스 대신 인터페이스를 사용하라</h2><ul>
<li>이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다.</li>
<li><p>인터페이스는 믹스인<sub>mixin</sub>을 정의하는 데 이상적이다.</p>
<blockquote>
<p>믹스인은 클래스가 “주 자료형<sub>primary type</sub>“ 이외에 추가로 구현할 수 있는 자료형으로, 어떤 선택적 기능을 제공한다는 사실을 선언하기 위해 쓰인다. (e.g. Comparable)</p>
</blockquote>
</li>
<li><p>인터페이스는 비 계층적인(nonhierarchical) 자료형 프레임워크를 만들 수 있도록 한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingerSongwriter</span> <span class="keyword">extends</span> <span class="title">Singer</span>, <span class="title">Songwriter</span> </span>&#123;</div><div class="line">  <span class="function">AudioClip <span class="title">strum</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">actSensitive</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>인터페이스를 쓰지 않으려면 필요한 속성 조합마다 별도의 클래스를 만들어 거대한 클래스 계층을 만들어야 한다. 필요한 속성이 n개가 있다면 지원해야 하는 조합의 가짓수는 2<sup>n</sup>개에 달한 것이다. 이런 문제는 <em>조합 폭증<sub>combinatorial explosion</sub></em>이라는 이름으로 알려져 있다.</li>
</ul>
</li>
<li>인터페이스를 사용하면 <em>포장 클래스 숙어<sub>wrapper class idiom</sub></em>를 통해(<a href="#item16">규칙 16</a>) 안전하면서도 강력한 기능 개선이 가능하다.</li>
<li><em>추상 골격 구현 클래스<sub>abstract skeletal implementation</sub></em>를 중요 인터페이스마다 두면, 인터페이스의 장점과 추상 클래스의 장점을 결합할 수 있다.<ul>
<li>인터페이스로는 자료형을 정의하고, 구현하는 일은 골격 구현 클래스에 맡기면 된다.</li>
<li>관습적으로 골격 구현 클래스의 이름은 Abstract<em>Interface</em>와 같이 정한다.<br>  (e.g. Collection Framework에는 인터페이스별로 골격 구현 클래스들이 하나씩 제공된다. <code>AbstractCollection</code>, <code>AbstractSet</code>, <code>AbstractList</code>, <code>AbstractMap</code>)</li>
<li>골격 구현 클래스를 적절히 정의하기만 하면, 프로그래머는 쉽게 인터페이스를 구현할 수 있다.</li>
</ul>
</li>
<li>추상클래스의 장점으로 인터페이스보다 추상 클래스가 발전시키기 쉽다. 하지만 java 1.8에서는 인터페이스에 default 메서드를 추가할 수 있다(하지만 인터페이스당 한 개의 default 메서드).</li>
<li>인터페이스가 공개되고 널리 구현된 다음에는, 인터페이스 수정이 거의 불가능하다. 그러므로, public 인터페이스는 극도로 주의해서 설계해야 하며 실제로 여러 구현을 만들어 보면서 광범위하게 테스트해야 한다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/04/15/classes-and-interfaces-2/#16-계승하는-대신-구성하라&quot;&gt;규칙 16&lt;/a&gt; - 계승하는 대신 구성하라&lt;br&gt;&lt;a href=&quot;../../../../2017/04/15/classes-and-interfaces-2/#17-계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라&quot;&gt;규칙 17&lt;/a&gt; - 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라&lt;br&gt;&lt;a href=&quot;../../../../2017/04/15/classes-and-interfaces-2/#18-추상-클래스-대신-인터페이스를-사용하라&quot;&gt;규칙 18&lt;/a&gt; - 추상 클래스 대신 인터페이스를 사용하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 4장. 클래스와 인터페이스 - 1</title>
    <link href="https://wickso.me/2017/03/29/classes-and-interfaces-1/"/>
    <id>https://wickso.me/2017/03/29/classes-and-interfaces-1/</id>
    <published>2017-03-29T01:00:00.000Z</published>
    <updated>2017-05-21T11:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/03/29/classes-and-interfaces-1/#13-클래스와-맴버의-접근-권한을-최소화하라">규칙 13</a> - 클래스와 맴버의 접근 권한을 최소화하라<br><a href="../../../../2017/03/29/classes-and-interfaces-1/#14-public-클래스-안에는-public-필드를-두지-말고-접근자-메서드를-사용하라">규칙 14</a> - public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라<br><a href="../../../../2017/03/29/classes-and-interfaces-1/#15-변경-가능성을-최소화하라">규칙 15</a> - 변경 가능성을 최소화하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="13-클래스와-맴버의-접근-권한을-최소화하라"><a href="#13-클래스와-맴버의-접근-권한을-최소화하라" class="headerlink" title="13. 클래스와 맴버의 접근 권한을 최소화하라"></a>13. 클래스와 맴버의 접근 권한을 최소화하라</h2><ul>
<li>소프트웨어 설계의 기본적인 원칙 중 하나 - 정보 은닉<sub>information hiding</sub>, 캡슐화<sub>encapsulation</sub></li>
<li>접근 권한은 가능한 낮춰라.</li>
<li>public static final 필드를 제외한 어떤 필드도 public 필드로 선언하지 마라</li>
<li>public static final 필드가 참조하는 객체는 변경 불가능 객체로 만들어라</li>
</ul>
<h4 id="정보-은닉-캡슐화"><a href="#정보-은닉-캡슐화" class="headerlink" title="정보 은닉, 캡슐화"></a>정보 은닉, 캡슐화</h4><ul>
<li>시스템을 구성하는 모듈 사이의 <em>의존성을 낮춤<sub>decouple</sub></em></li>
<li>성능을 보장하는 것은 아니지만, 효과적인 성능 튜닝을 가능하게 한다. 어떤 모듈이 성능 문제를 일으키는지 프로파일링<sub>profiling</sub> 하기 용이하기 때문(<a href="#item55">규칙 55</a>)</li>
<li>소프트웨어의 재사용 가능성을 높인다.</li>
<li>대규모 시스템 개발 과정의 리스트를 낮춘다.</li>
<li>접근 제어<sub>access control</sub> 메커니즘은 클래스와 인터페이스, 그리고 그 멤버들의 접근 권한<sub>accessibility</sub>을 규정한다(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.6" rel="external nofollow noopener noreferrer" target="_blank">JLS, 6.6</a>)</li>
<li><strong>각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들라는 것</strong> - 가장 낮은 접근 권한 설정</li>
<li><strong>객체 필드<sub>instance field</sub>는 절대로 public으로 선언하면 안 된다</strong>(<a href="#item14">규칙 14</a>).</li>
<li><strong>변경 가능 public 필드를 가진 클래스는 다중 스레드에 안전하지 않다.</strong></li>
<li>예외적으로 어떤 상수들이 클래스로 추상화된 결과물의 핵심적 부분을 구성한다고 판단되는 경우, 해당 상수들을 <code>public static final</code> 필드들로 선언하여 공개할 수 있다. 이런 필드들은 관습적으로 대문자로 구성된 이름을 가지며, 이름을 구성하는 단어들은 밑줄 기호로 구분한다(<a href="#item56">규칙 56</a>). 이런 필드들은 반드시 기본 자료형 값들을 갖거나, 변경 불가능 객체를 참조해야 한다(<a href="#item15">규칙 15</a>).</li>
<li><p>길이가 0 아닌 배열은 언제나 변경 가능하므로, <strong>public static final 배열 필드를 두거나, 배열 필드를 반환하는 접근자<sub>accessor</sub>를 정의하면 안 된다.</strong> - 보안문제 유발</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AS-IS: 보안 문제를 초래할 수 있는 코드</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VAUES = &#123;...&#125;;</div><div class="line"></div><div class="line"><span class="comment">// TO-BE: (1) 변경 불가능 public 리스트 사용</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</div><div class="line"></div><div class="line"><span class="comment">// TO-BE: (2) 복사해서 반환하는 메서드 추가</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</div><div class="line">  <span class="keyword">return</span> PRIVATE_VALUES.clone();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="14-public-클래스-안에는-public-필드를-두지-말고-접근자-메서드를-사용하라"><a href="#14-public-클래스-안에는-public-필드를-두지-말고-접근자-메서드를-사용하라" class="headerlink" title="14. public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라"></a>14. public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라</h2><ul>
<li><strong>getter/setter(접근자 메서드)를 사용하자</strong><ul>
<li>캡슐화의 이점</li>
<li>불변식 가능</li>
<li>필드 사용시 다른 동작 가능</li>
<li>(+) boilerplate code를 줄이기 위해서 lombok의 <code>@Data</code>, <code>@Value</code> 활용</li>
</ul>
</li>
<li>원칙을 어긴 Java 클래스 - <code>Point.class</code>, <code>Dimension.class</code><ul>
<li>이런 클래스는 참고하지 않는 것이 좋다.</li>
<li>Dimension 클래스가 내부 표현을 공개한 것은 아직까지도 해결되지 않고 있는 심각한 성능 문제 때문이다(<a href="#item55">규칙 55</a>에 설명).</li>
</ul>
</li>
</ul>
<hr>
<h2 id="15-변경-가능성을-최소화하라"><a href="#15-변경-가능성을-최소화하라" class="headerlink" title="15. 변경 가능성을 최소화하라"></a>15. 변경 가능성을 최소화하라</h2><h4 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h4><ul>
<li>Mutable Class로 만들 타당한 이유가 없다면, 반드시 Immutable Class로 만들어야 한다<ul>
<li>모든 getter 마다 그에 대응하는 setter를 두는 것은 피하라</li>
<li>유일한 장점은 특정 상황에서 성능 문제가 생길 수 있다는 것이다</li>
<li>작은 객체는 반드시 immutable로 만들어라</li>
</ul>
</li>
<li>Immutable Class로 만들 수 없다면, 변경 가능성을 최대한 제한하라</li>
<li>특별한 이유가 없다면 모든 필드는 final로 선언하라<ul>
<li>특별한 이유가 없다면, 생성자 이외에 public 초기화 메서드나 정적 팩터리 메서드를 제공하지 마라</li>
<li>재 초기화 메서드도 제공하지 마라. 코드 복잡성만 늘어나고, 성능 향상에 도움 되는 경우는 거의 없다</li>
</ul>
</li>
</ul>
<h4 id="변경-불가능immutable-클래스-생성-규칙"><a href="#변경-불가능immutable-클래스-생성-규칙" class="headerlink" title="변경 불가능immutable 클래스 생성 규칙"></a>변경 불가능<sub>immutable</sub> 클래스 생성 규칙</h4><ul>
<li>객체 상태를 변경하는 메서드(수정자<sub>mutator</sub> 메서드 등)를 제공하지 않는다.</li>
<li>계승할(상속 받을) 수 없도록 한다. - e.g. <code>public final class { ... }</code></li>
<li>모든 필드는 final로 선언한다.<ul>
<li>프로그래머의 의도가 분명해짐</li>
<li>자바 <em>메모리 모델</em>에 명시된 바와 같이[<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5" rel="external nofollow noopener noreferrer" target="_blank">JLS, 17.5</a>], 새로 생성된 객체에 대한 참조가 동기화 없이 다른 스레드로 전달되어도 안전</li>
</ul>
</li>
<li>모든 필드를 private로 선언한다.</li>
<li>변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다.<ul>
<li>변경 가능 객체에 대한 참조를 클라이언트는 획득할 수 없어야 한다.</li>
<li>그런 필드는 클라이언트가 제공하는 객체로 초기화해서는 안되고, 접근자<sub>accessor</sub> 또한 그런 필드를 반환해서는 안 된다.</li>
<li>생성자나 접근다, readObject 메서드(<a href="#item76">규칙 76</a>)안에서는 <em>방어적 복사본<sub>defensive copy</sub></em>을 만들어야 한다(<a href="#item39">규칙 39</a>).</li>
</ul>
</li>
</ul>
<h4 id="immutable-object-특징"><a href="#Immutable-Object-특징" class="headerlink" title="Immutable Object 특징"></a>Immutable Object 특징</h4><ul>
<li><strong>변경 불가능 객체는 단순하다. 생성될 때 부여된 한 가지 상태만 갖는다.</strong></li>
<li><strong>변경 불가능 객체는 스레드에 안전(thread-safe)할 수밖에 없다. 어떤 동기화도 필요 없으며,</strong> 여러 스레드가 동시에 사용해도 상태가 훼손될 일이 없다.</li>
<li><strong>변경 불가능 객체는 자유롭게 공유할 수 있다.</strong> 방어적 복사본(<a href="#item39">규칙 39</a>)을 만들 필요가 없단 뜻이기도 하다.</li>
<li><strong>변경 불가능 객체는 그 내부도 공유할 수 있다.</strong></li>
<li><strong>변경 불가능 객체는 다른 객체의 구성요소로도 훌륭하다.</strong></li>
<li><strong>변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다.</strong> 따라서 객체 생성 비용이 높을 가능성이 있다.</li>
</ul>
<h4 id="immutable-object-생성하는-다른-방법"><a href="#Immutable-Object-생성하는-다른-방법" class="headerlink" title="Immutable Object 생성하는 다른 방법"></a>Immutable Object 생성하는 다른 방법</h4><p>모든 생성자를 private이나 package-private로 선언하고 public 생성자 대신 public 정적 팩터리 제공(<a href="#item1">규칙 1</a>) - 장점은 규칙 1 확인</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/03/29/classes-and-interfaces-1/#13-클래스와-맴버의-접근-권한을-최소화하라&quot;&gt;규칙 13&lt;/a&gt; - 클래스와 맴버의 접근 권한을 최소화하라&lt;br&gt;&lt;a href=&quot;../../../../2017/03/29/classes-and-interfaces-1/#14-public-클래스-안에는-public-필드를-두지-말고-접근자-메서드를-사용하라&quot;&gt;규칙 14&lt;/a&gt; - public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/03/29/classes-and-interfaces-1/#15-변경-가능성을-최소화하라&quot;&gt;규칙 15&lt;/a&gt; - 변경 가능성을 최소화하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 3장. 모든 객체의 공통 메서드 - 2</title>
    <link href="https://wickso.me/2017/03/22/methods-common-to-all-objects-2/"/>
    <id>https://wickso.me/2017/03/22/methods-common-to-all-objects-2/</id>
    <published>2017-03-22T01:00:00.000Z</published>
    <updated>2017-05-21T11:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/03/22/methods-common-to-all-objects-2/#규칙-11-clone을-재정의할-때는-신중하라">규칙 11</a> - clone을 재정의할 때는 신중하라<br><a href="../../../../2017/03/22/methods-common-to-all-objects-2/#규칙-12-Comparable-구현을-고려하라">규칙 12</a> - Comparable 구현을 고려하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-11-clone을-재정의할-때는-신중하라"><a href="#규칙-11-clone을-재정의할-때는-신중하라" class="headerlink" title="규칙 11. clone을 재정의할 때는 신중하라"></a>규칙 11. clone을 재정의할 때는 신중하라</h2><h4 id="cloneable-인터페이스"><a href="#Cloneable-인터페이스" class="headerlink" title="Cloneable 인터페이스"></a>Cloneable 인터페이스</h4><ul>
<li>어떤 객체가 clone을 허용한다는 사실을 알리는 데 쓰려고 고안된 <em>mixin 인터페이스</em>(<a href="#item18">규칙 18</a>)<ul>
<li>clone 메서드가 없으며, Object의 clone 메서드는 potected로 선언되어 있다.</li>
</ul>
</li>
<li>protected로 선언된 Object의 clone 메서드가 어떻게 동작할지 정한다.<ul>
<li>어떤 클래스가 Cloneable을 구현하면, Object의 clone 메서드는 해당 객체를 필드 단위로 복사한 객체를 반환</li>
<li>어떤 클래스가 Cloneable을 구현하지 않으면 CloneNotSupportedExceptiond을 던짐</li>
</ul>
</li>
<li>인터페이스를 괴상하게 이용한 사례<ul>
<li>일반적으로 인터페이스를 구현한다는 것은 클래스가 무슨 일을 할 수 있는지 클라이언트에게 알리는 것</li>
<li>Clonealed은 상위 클래스의 protected 맴버가 어떻게 동작할지 규정하는 용도</li>
</ul>
</li>
<li>Cloneable을 구현해서 어떤 결과를 얻으려면, 해당 클래스뿐 아니라 그 모든 상위 클래스들은 복잡한 데다 강제할 수 없고(unenforceable) 문서도 부족한 프로토콜을 따라야 한다. 그리고 그렇게 하면 언어 외적인(ectralinguistic) 객체 생성 메커니즘이 탄생한다. 생성자 호출 없이도 객체를 생성할 수 있게 되는 것이다.</li>
</ul>
<h4 id="javalangobjectclone-일반-규약"><a href="#java-lang-Object-clone-일반-규약" class="headerlink" title="java.lang.Object.clone() 일반 규약"></a>java.lang.Object.clone() 일반 규약</h4><ul>
<li>객체의 복사본을 만들어서 반환</li>
<li>“복사”의 정확한 의미는 클래스마다 다르며, 일반적으로 다음과 같은 조건이 충족되어야 한다.<ul>
<li>True: <code>x.clone() != x</code></li>
<li>True 그러나 반드시 True여야 하는 것은 아님:<ul>
<li>① <code>x.clone().getClass() == x.getClass()</code></li>
<li><code>x.cline().equals(x)</code></li>
</ul>
</li>
</ul>
</li>
<li>내부 자료구조까지 복사해야 될 수도 있다.</li>
<li>② 어떤 생성자도 호출되지 않는다.</li>
</ul>
<h4 id="clone-규약의-문제점"><a href="#clone-규약의-문제점" class="headerlink" title="clone() 규약의 문제점"></a>clone() 규약의 문제점</h4><ul>
<li>② 규정은 너무 심하다.<ul>
<li>clone이 만드는 복사본의 내부 객체는 생성자로 만들 수도 있다.</li>
<li>클래스가 final로 선언되어 있다면, 생성자로 만든 객체를 반환하도록 clone을 구현할 수도 있다.</li>
</ul>
</li>
<li>① 규정은 너무 느슨하다.</li>
</ul>
<h4 id="중점"><a href="#중점" class="headerlink" title="중점?"></a>중점?</h4><ul>
<li>비-final 클래스에 clone을 재정의할 때는 반드시 super.clone을 호출해 얻은 객체를 반환해야 한다.</li>
<li>실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다.</li>
<li>라이브러리가 할 수 있는 일을 클라이언트에게 미루지 말라.</li>
<li>사실상, clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식<sub>invariant</sub>도 제대로 만족시켜야 한다.</li>
<li>clone의 아키텍처는 변경 가능한 객체를 참조하는 final 필드의 일반적 용볍과 호환되지 않는다.</li>
<li>객체를 복사할 대안을 제공하거나, 아예 복제 기능을 제공하지 않는 것이 낫다.</li>
<li>객체 복제를 지원하는 좋은 방법은 <em>복사 생성자<sub>copy constructor</sub></em>나 <em>복사 팩터리<sub>copy factory</sub></em>를 제공하는 것이다.</li>
</ul>
<hr>
<h2 id="규칙-12-comparable-구현을-고려하라"><a href="#규칙-12-Comparable-구현을-고려하라" class="headerlink" title="규칙 12. Comparable 구현을 고려하라"></a>규칙 12. Comparable 구현을 고려하라</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>compareTo()</code>는 <em>Comparable</em> 인터페이스에 포함된 유일한 메서드. equals()와 비슷하지만, 단순한 동치성 검사 이외에 순서 비교가 가능하며, 좀 더 일반적.</li>
<li>Comparable 인터페이스를 구현하는 클래의 객체들은 <em>자연적 순서<sub>natural ordering</sub></em>를 갖게 됨 - <code>Arrays.sort(a)</code>로 정렬 가능</li>
<li><p><code>compateTo()</code>의 일반 규약(equals와 비슷)</p>
<ul>
<li>객체와 인자로 주어진 객체 비교</li>
<li>이 객체의 값이 인자로 주어진 객체보자 작으면 음수, 같으면 0, 크면 양수</li>
<li>인자로 전달된 객체의 자료형이 이 객체와 비교 불가능할 경우 <em>ClassCastException</em> 예외 던짐</li>
<li>모든 x와 y에 대해 <code>sgn(x.compareTo(y)) == -sgn(y.compareTo(x))</code>가 만족되도록 해야 한다. (<code>y.compareTo(x)</code>가 예외를 발생시킨다면 <code>x.compareTo(y)</code>도 그래야 하고, 그 역도 성립해야 한다.)</li>
<li>추이성<sub>transitivity</sub>이 만족되도록 해야 한다. 즉, <code>(x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)</code>이면 <code>x.compareTo(z) &gt; 0</code>이어야 한다.</li>
<li><code>x.compareTo(y) == 0</code> 이면 <code>sgn(x.compareTo(z)) === sgn(y.compareTo(z))</code>이다.</li>
<li><p>강력히 추천하지만 절대적 요구사항은 아닌 조건 하나는 <code>(x.compareTo(y) == 0) == (x.equals(y))</code>이다. 이 조건을 만족하지 않는 클래스는 반드시 그 사실을 명시해야 한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 주의: 이 클래스의 객체들은 equals에 부합하지 않는 자연적 순서를 따른다.</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>규약을 준수하지 않는 클래스는 비교 연산에 기반한 클래스들을 오동작시킬 수 있다. - TreeSet·TreeMap 같은 sorted collection, Arrays·Collections 같은 유틸리티 클래스, 탐색과 정렬 알고리즘을 포함하는 클래스</p>
</li>
<li>compareTo()의 필드 비교 방식은 동치성 검사라기보단 순서 비교다.</li>
<li>클래스에 선언된 중요 필드가 여러 개인 경우, 필드 비교 순서가 중요하다. 가장 중요한 필드부터 시작해서 차례로 비교해야 한다.</li>
<li>compareTo()를 구현하면서 값 비교할때 오버플로우를 조심 -&gt; 이런 문제는 대부분 정상동작하기 때문에 디버깅하기 어렵다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/03/22/methods-common-to-all-objects-2/#규칙-11-clone을-재정의할-때는-신중하라&quot;&gt;규칙 11&lt;/a&gt; - clone을 재정의할 때는 신중하라&lt;br&gt;&lt;a href=&quot;../../../../2017/03/22/methods-common-to-all-objects-2/#규칙-12-Comparable-구현을-고려하라&quot;&gt;규칙 12&lt;/a&gt; - Comparable 구현을 고려하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 3장. 모든 객체의 공통 메서드 - 1</title>
    <link href="https://wickso.me/2017/03/11/methods-common-to-all-objects-1/"/>
    <id>https://wickso.me/2017/03/11/methods-common-to-all-objects-1/</id>
    <published>2017-03-11T01:00:00.000Z</published>
    <updated>2017-05-21T11:40:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/03/11/methods-common-to-all-objects-1/#규칙-8-equals를-재정의할-때는-일반-규약을-따르라">규칙 8</a> - equals를 재정의할 때는 일반 규약을 따르라<br><a href="../../../../2017/03/11/methods-common-to-all-objects-1/#규칙-9-equals-메서드를-재정의하는-클래스는-반드시-hashCode-메서드도-재정의-해야-한다">규칙 9</a> - equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야 한다<br><a href="../../../../2017/03/11/methods-common-to-all-objects-1/#규칙-10-toString은-항상-재정의하라">규칙 10</a> - toString은 항상 재정의하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-8-equals를-재정의할-때는-일반-규약을-따르라"><a href="#규칙-8-equals를-재정의할-때는-일반-규약을-따르라" class="headerlink" title="규칙 8. equals를 재정의할 때는 일반 규약을 따르라"></a>규칙 8. equals를 재정의할 때는 일반 규약을 따르라</h2><h4 id="override-상황"><a href="#Override-상황" class="headerlink" title="Override 상황"></a>Override 상황</h4><h6 id="override-하지-않는-경우"><a href="#Override-하지-않는-경우" class="headerlink" title="Override 하지 않는 경우"></a>Override 하지 않는 경우</h6><ol>
<li>각각의 객체가 고유할 때<br> 값<sub>value</sub> 대신 활성 개체<sub>active entity</sub>를 나타내는 <em>Thread</em> 같은 클래스.</li>
<li>논리적 동일성<sub>logical equality</sub> 검사 방법이 상관 없을 때<br> <em>Random</em> 클래스를 설계할 때 값 비교를 사용안할 것 같아서 구현하지 않는 것처럼 필요 없을 경우</li>
<li>상위 클래스에서 정의한 equals가 하위 클래스에서 사용 가능할 때</li>
<li><p>클래스가 private, package-private로 선언되었고, equals를 호출할 일이 없을 때</p>
<blockquote>
<p>필자는 이런 상황에서는 반드시 equals를 재정의해야 한다고 본다. 실수로 equals를 호출할 수도 있기 때문.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); <span class="comment">// 호출되면 안 되는 메서드를 호출했다는 뜻</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="override-하는-경우"><a href="#Override-하는-경우" class="headerlink" title="Override 하는 경우"></a>Override 하는 경우</h6><ol>
<li><em>논리적 동일성<sub>logical equality</sub></em>의 개념을 지원하는 클래스일 때</li>
<li>상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때</li>
</ol>
<h6 id="override-할-필요가-없는-경우"><a href="#Override-할-필요가-없는-경우" class="headerlink" title="Override 할 필요가 없는 경우"></a>Override 할 필요가 없는 경우</h6><ol>
<li>개체 통제(<a href="#item1">규칙 1</a>) 기능으로 하나의 객체만 존재하는 클래스(e.g. 싱글톤, enum(<a href="#item30">규칙 30</a>))</li>
</ol>
<h4 id="override-규약-주의"><a href="#Override-규약-주의" class="headerlink" title="Override 규약, 주의"></a>Override 규약, 주의</h4><h6 id="equals-메서드를-정의할-때-준수해야-하는-일반-규약general-contract"><a href="#equals-메서드를-정의할-때-준수해야-하는-일반-규약general-contract" class="headerlink" title="equals 메서드를 정의할 때 준수해야 하는 일반 규약general contract"></a>equals 메서드를 정의할 때 준수해야 하는 일반 규약<sub>general contract</sub></h6><blockquote>
<p><em>Object</em> 클래스 명세(specification)[JavaSE6]</p>
</blockquote>
<p><em>동치 관계<sub>equivalence relation</sub></em> 구현, 다음과 같은 관계를 동치 관계라 한다.</p>
<ul>
<li><strong>반사성<sub>Reflexivity</sub></strong>: <code>x.equals(x)</code>는 <code>true</code></li>
<li><p><strong>대칭성<sub>Symmetry</sub></strong>: <code>x.equals(y)</code>가 <code>true</code>일 때, <code>y.equals(x)</code>도 <code>true</code></p>
<p>  <em>e.g. 대칭성 위반 코드</em></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomString</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String str;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> CustomString) &#123;</div><div class="line">      <span class="keyword">return</span> str.equalsIgnoreCase(((CustomString) o).getStr());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String) &#123; <span class="comment">// 대칭성 위반</span></div><div class="line">      <span class="keyword">return</span> str.equalsIgnoreCase((String) o);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CustomString cs = <span class="keyword">new</span> CustomString(<span class="string">"string"</span>);</div><div class="line">String s = <span class="string">"string"</span>;</div><div class="line"></div><div class="line">cs.equals(s); <span class="comment">// true</span></div><div class="line">s.equals(cs); <span class="comment">// false</span></div><div class="line"></div><div class="line">List&lt;CustomString&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">...</div><div class="line"><span class="comment">// JVM에 따라 결과가 달라진다.</span></div><div class="line">list.contains(s);</div></pre></td></tr></table></figure>
<blockquote>
<p>equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다.</p>
</blockquote>
</li>
<li><p><strong>추이성<sub>Transitivity</sub></strong>: <code>x.equals(y)</code>가 <code>true</code>이고, <code>y.equals(z)</code>가 <code>true</code>이면 <code>x.equals(z)</code>도 <code>true</code></p>
<p>  <em>e.g. 하위 클래스에서 새로운 값 컴포넌트<sub>value component</sub>를 추가하는 상황.</em></p>
<p>  <em>ColorPoint 클래스</em>(하위 클래스)의 <code>equals()</code>에서 새로운 값 color를 비교하는 로직을 추가할 경우, 대칭성에 위반</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@AllArgsConstructor</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Point)) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</div><div class="line">    Point p = (Point)obj;</div><div class="line">    <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(x, y);</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 대칭성 위반</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> ColorPoint)) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj) &amp;&amp; ((ColorPoint)obj).color == color;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Point p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">Point p2 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</div><div class="line">p1.equals(p2); <span class="comment">// true</span></div><div class="line">p2.equals(p1); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  그래서 Point 객체일 때 color 값을 비교안하도록 할 경우, 대칭성은 보존되지만 추이성 위반</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// 추이성 위반</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> obj.equals(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj) &amp;&amp; ((ColorPoint)obj).color == color;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Point p0 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</div><div class="line">Point p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">Point p2 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</div><div class="line"></div><div class="line">p0.equals(p1); <span class="comment">// true</span></div><div class="line">p1.equals(p2); <span class="comment">// true</span></div><div class="line">p0.equals(p2); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<blockquote>
<p>사실 이것은 객체 지향 언어에서 동치 관계<sub>equivalence relation</sub>를 구현할 때 발생하는 본질적 문제다. 객체 지향적 추상화<sub>object-oriented abstraction</sub>의 혜택을 누리지 않을 거라면 모를까, <strong>객체 생성 가능 클래스를 계승하여 새로운 값 컴포넌트를 추가하면서 equals 규약을 어기지 않을 방법은 없다.</strong></p>
</blockquote>
<p>  TO-DO: 리스코프 대체 원칙 위반(p52)</p>
<p>  ∴ Composition 으로 구현(<a href="#item16">규칙 16</a>).</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Point point;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(color == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    point = <span class="keyword">new</span> Point(x, y);</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> point; &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    ColorPoint cp = (ColorPoint) obj;</div><div class="line">    <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Point p0 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED).asPoint();</div><div class="line">Point p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">Point p2 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE).asPoint();</div><div class="line"></div><div class="line">p0.equals(p1); <span class="comment">// true</span></div><div class="line">p1.equals(p0); <span class="comment">// true</span></div><div class="line"></div><div class="line">p0.equals(p1); <span class="comment">// true</span></div><div class="line">p1.equals(p2); <span class="comment">// true</span></div><div class="line">p0.equals(p2); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>  cf. lombok</p>
<ul>
<li><code>@Value</code> 적용한 클래스는 <code>final class</code>가 되므로 상속 불가.</li>
<li><p>롬북 활용할 경우</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@EqualsAndHashCode</span></div><div class="line"><span class="meta">@AllArgsConstructor</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@EqualsAndHashCode</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(x, y);</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Point p0 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</div><div class="line">Point p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">Point p2 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</div><div class="line"></div><div class="line">p0.equals(p1); <span class="comment">// false</span></div><div class="line">p1.equals(p0); <span class="comment">// false</span></div><div class="line"></div><div class="line">p0.equals(p1); <span class="comment">// false</span></div><div class="line">p1.equals(p2); <span class="comment">// false</span></div><div class="line">p0.equals(p2); <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>일관성<sub>Consistency</sub></strong>: 값의 변화가 없다면 <code>x.equals(y)</code>는 호출 횟수에 상관없이 항상 같아야 함</p>
<ul>
<li>클래스를 구현할 때는 Mutable or immutable 을 깊이 생각해본다(<a href="#item15">규칙 15</a>).</li>
<li>신뢰성이 보장되지 않는 자원<sub>unreliable resource</sub>들을 비교하는 equals를 구현하는 것은 삼가라. 그렇지 않으면 일관성 규약을 만족시키기가 너무 어려움.</li>
</ul>
</li>
<li><p><strong>Null에 대한 비 동치성<sub>Non-nullity</sub></strong>: <em>null</em>이 아닌 참조 x에 대해서 <code>x.equals(null)</code>은 항상 <code>false</code></p>
<p>  equals의 일반 규약에서는 예외가 발생하는 것을 허용하지 않는다(e.g. NPE). 그래서 상당수의 클래스는 equals() 안에서 null 조건을 명시적으로 검사하는데(e.g. <code>if (o == null) return false;</code>), 이런 검사는 불필요하다.</p>
<p>  왜냐하면, equals 메서드는 먼저 인자를 형변환<sub>cast</sub>하는데, <em>instanceof</em> 연산자는 첫 번째 피연산자가 null이면 무조건 false를 반환한다[<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.20.2" rel="external nofollow noopener noreferrer" target="_blank">JLS, 15.20.2</a>].</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object e)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> CustomType)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="equlas-메서드를-구현하기-위해-따라야-할-지침"><a href="#equlas-메서드를-구현하기-위해-따라야-할-지침" class="headerlink" title="equlas 메서드를 구현하기 위해 따라야 할 지침"></a>equlas 메서드를 구현하기 위해 따라야 할 지침</h6><ol>
<li>== 연산자를 사용하여 equals의 인자가 자기 자신인지 검사 -&gt; 단순히 성능 최적화<sub>performance optimization</sub></li>
<li>instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사</li>
<li>equals의 인자를 정확한 자료형으로 변환</li>
<li>각각의 필드가 일치하는지 검사</li>
<li>equals 메서드 구현을 끝냈다면, 대칭성·추이성·일관성의 세 속성이 만족하는지 검토 -&gt; unit test</li>
</ol>
<p>(+) 추가 주의 사항</p>
<ul>
<li>equals를 구현할 떄는 hashCode도 재정의하라</li>
<li>너무 머리 쓰지 마라</li>
<li>equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라</li>
</ul>
<hr>
<h2 id="규칙-9-equals-메서드를-재정의하는-클래스는-반드시-hashcode-메서드도-재정의-해야-한다"><a href="#규칙-9-equals-메서드를-재정의하는-클래스는-반드시-hashCode-메서드도-재정의-해야-한다" class="headerlink" title="규칙 9. equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야 한다"></a>규칙 9. equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야 한다</h2><blockquote>
<p>Object 일반 규약[JavaSE6]</p>
<ul>
<li>응용프로그램 실행 중에 같은 객체의 hashCode를 여러 번 호출하는 경우, equals가 사용하는 정보들이 변경되지 않았다면, 언제나 동일한 정수가 반환되어야 한다. 다만 프로그램이 종료되었다가 다시 실행되어도 같은 값이 나올 필요는 없다.</li>
<li>equals(Object) 메서드가 같다고 판정한 두 객체의 hashCode 값은 같아야 한다.</li>
<li>equals(Object) 메서드가 다르다고 판정한 두 객체의 hashCode 값은 꼭 다를 필요는 없다.그러나 서로 다른 hashCode 값이 나오면 hash table의 성능이 향상될 수 있다는 점은 이해하고 있어야 한다.</li>
</ul>
</blockquote>
<ul>
<li><strong>equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야 한다.</strong> override 하지 않으면 Object 일반 규약중 두번째, 같은 객체는 같은 해시 코드 값을 가져야 한다는 규약이 위반되는 것이다. 재정의하지 않으면 Hash 기반 컬렉션과 함께 사용하면 오동작한다(e.g. HashMap, HashSet, …)</li>
<li>좋은 해시 함수는 다른 객체에서 다른 해시 코드를 반환하는 경향이 있다. - 충돌<sub>Collision</sub> 회피<ul>
<li>이상적인 해시 함수 만드는 방법 책 참고 - p64</li>
<li><a href="https://projectlombok.org/features/EqualsAndHashCode.html" rel="external nofollow noopener noreferrer" target="_blank">lombok</a>의 <code>@EqualsAndHashCode</code> 참고(책의 방법과 비슷)</li>
</ul>
</li>
<li>해시 코드 계산 비용이 높은 변경 불가능 클래스를 만들 때는, 재계산하는 대신 캐시해 두어야 할 수도 있다. 또한 경우에 해시 키에 따라 lazy initialization도 가능하다.</li>
<li><strong>주의할 것은, 성능을 개선하려고 객체의 중요 부분을 해시 코드 계산 과정에서 생략하면 안된다.</strong></li>
</ul>
<h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><ul>
<li><a href="http://d2.naver.com/helloworld/831311" rel="external nofollow noopener noreferrer" target="_blank">Java HashMap은 어떻게 동작하는가?</a></li>
</ul>
<hr>
<h2 id="규칙-10-tostring은-항상-재정의하라"><a href="#규칙-10-toString은-항상-재정의하라" class="headerlink" title="규칙 10. toString은 항상 재정의하라"></a>규칙 10. toString은 항상 재정의하라</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 이것보단</div><div class="line">PhoneNumber@163b91</div><div class="line">// 이게 훨씬 낫다!</div><div class="line">(070) 867-5309</div></pre></td></tr></table></figure>
<blockquote>
<p>“모든 하위 클래스는 이 메서드를 재정의함이 바람직하다.” - toString 일반 규약</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Agency agency; <span class="comment">// 통신사</span></div><div class="line">  <span class="keyword">private</span> String number; <span class="comment">// 전화번호</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Agency <span class="title">getAgency</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> agency; &#125; ④</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 전화번호를 문자열로 변환해서 반환한다.</div><div class="line">   * "[SKT] 010-1234-1234" 형식으로 반환된다. ③</div><div class="line">   * ....</div><div class="line">   */</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ①</div><div class="line">    <span class="keyword">return</span> agency.getName() + <span class="string">" "</span> + number; ②</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>toString을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.</li>
<li>가능하다면 toString()는 객체 내의 중요 정보를 전부 담아 반환해야 한다.</li>
<li>toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에, 어떤 의도인지는 문서에 분명하게 남겨야 한다.</li>
<li>toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해서 가져올 수 있도록(programmatic access)하라.<br> toString에 포함되는 정보를 가져올 수 있는 accessor를 만들지 않으면, 클라이언트는 toString을 파싱하려 할 것이다.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/03/11/methods-common-to-all-objects-1/#규칙-8-equals를-재정의할-때는-일반-규약을-따르라&quot;&gt;규칙 8&lt;/a&gt; - equals를 재정의할 때는 일반 규약을 따르라&lt;br&gt;&lt;a href=&quot;../../../../2017/03/11/methods-common-to-all-objects-1/#규칙-9-equals-메서드를-재정의하는-클래스는-반드시-hashCode-메서드도-재정의-해야-한다&quot;&gt;규칙 9&lt;/a&gt; - equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야 한다&lt;br&gt;&lt;a href=&quot;../../../../2017/03/11/methods-common-to-all-objects-1/#규칙-10-toString은-항상-재정의하라&quot;&gt;규칙 10&lt;/a&gt; - toString은 항상 재정의하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 2장. 객체 생성과 삭제 - 3</title>
    <link href="https://wickso.me/2017/02/21/creating-and-destroying-objects-3/"/>
    <id>https://wickso.me/2017/02/21/creating-and-destroying-objects-3/</id>
    <published>2017-02-21T01:00:00.000Z</published>
    <updated>2017-05-21T11:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/02/21/creating-and-destroying-objects-3/#규칙-6-유효기간이-지난-객체-참조는-폐기하라">규칙 6</a> - 유효기간이 지난 객체 참조는 폐기하라<br><a href="../../../../2017/02/21/creating-and-destroying-objects-3/#규칙-7-종료자-사용을-피하라">규칙 7</a> - 종료자 사용을 피하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-6-유효기간이-지난-객체-참조는-폐기하라"><a href="#규칙-6-유효기간이-지난-객체-참조는-폐기하라" class="headerlink" title="규칙 6. 유효기간이 지난 객체 참조는 폐기하라"></a>규칙 6. 유효기간이 지난 객체 참조는 폐기하라</h2><p><em>e.g. 메모리 누수</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Object[] element = <span class="keyword">new</span> Object[<span class="number">16</span>];</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</div><div class="line">    ensureCapacity();</div><div class="line">    elements[size++] = e;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">    <span class="keyword">return</span> elements[--size];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elements.length == size) &#123;</div><div class="line">      elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>스택이 커졌다가 줄어들 때, 인덱스 값이 size보다 큰 곳에 있는 요소들(쓰레기 값)은 GC가 처리하지 못한다. 스택이 그런 객체에 대한 <em>만기 참조<sub>obsolete reference</sub></em>를 제거하지 않기 때문이다. 만기 참조란 다시 이용되지 않을 참조<sub>reference</sub>를 말한다.</p>
<p>자동적으로 쓰레기 객체를 수집하는 언어에서 발생하는 메모리 누수 문제(≒ 의도치 않은 객체 보유<sub>unintentional object retention</sub>)는 찾아내기 어렵다.</p>
<h4 id="해결방안"><a href="#해결방안" class="headerlink" title="해결방안"></a>해결방안</h4><p>만기 참조를 제거하는 가장 좋은 방법은, 해당 참조가 보관된 변수의 유효범위<sub>socpe</sub>를 최대한 좁게 만들어 벗어나게 두는 것이다(<a href="#item45">규칙 45</a>).</p>
<p>위 예제 Stack과 같이 자체적으로 메모리는 관리하는 경우에는, 쓸 일이 없는 객체 참조는 반드시 null로 바꿔준다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">  Object result = elements[--size];</div><div class="line">  elements[size] = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="흔히-메모리-누수가-발견되는-곳"><a href="#흔히-메모리-누수가-발견되는-곳" class="headerlink" title="흔히 메모리 누수가 발견되는 곳"></a>흔히 메모리 누수가 발견되는 곳</h4><ul>
<li>자체적으로 관리하는 메모리가 있는 클래스</li>
<li>캐시<sub>cache</sub>: 객체 참조를 캐시 안에 넣어 놓고 잊어버리는 일이 많기 때문. (수명이 키에 대한 외부 참조의 수명에 따라 결정되는 상황에는 <em>WeakHashMap</em> 활용)</li>
<li>리스너<sub>listener</sub>등의 역호출자<sub>callback</sub> - 콜백을 명시적으로 제거하지 않을 경우, 적절한 조치를 취하기 전까지 메모리는 점유된 상태. 해결방안으로 콜백에 대한 약한 참조<sub>weak reference</sub>만 저장하는 것(WeakHashMap)</li>
</ul>
<hr>
<h2 id="규칙-7-종료자-사용을-피하라"><a href="#규칙-7-종료자-사용을-피하라" class="headerlink" title="규칙 7. 종료자 사용을 피하라"></a>규칙 7. 종료자 사용을 피하라</h2><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize?"></a>finalize?</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Called by the garbage collector on an object when garbage collection</div><div class="line">   * determines that there are no more references to the object.</div><div class="line">   * ...</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>‼️ <strong>종료자<sub>finalizer</sub>는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.</strong> … 어쨌든 종료자 사용은 피하는 것이 원칙이다.</p>
</blockquote>
<ul>
<li>GC가 객체에 대한 참조가 더 이상 없다고 판단할 때 GC로부터 호출된다. 하지만, 즉시 실행되리라는 보장이 전혀 없다(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6" rel="external nofollow noopener noreferrer" target="_blank">JLS, 12.6</a>). <strong>따라서 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안 된다</strong>(e.g. finalize안에서 파일 닫기).</li>
<li>종료자의 실행시점은 GC 알고리즘에 좌우되는데, 이 알고리즘은 JVM 구현마다 크게 다르다.</li>
<li>종료자의 더딘 실행<sub>tardy finalization</sub>은 단순히 이론적인 문제가 아니다. 클래스에 종료자를 붙여 놓으면, 드문 일이지만 객체 메모리 반환이 지연될 수도 있다.</li>
<li>종료자가 실행되지 않은 객체가 남은 상태로 프로그램이 끝나는 일도 충분히 가능하다. 그러므로 <strong>지속성이 보장되어야 하는 중요 상태 정보<sub>critical persistent state</sub>는 종료자로 갱신하면 안 된다.</strong></li>
<li><code>System.gc()</code>나 <code>System.runFinalization()</code> 같은 메서드는 종료자 실행 가능성을 높여주긴 하지만 보장하지 않는다.</li>
<li><code>System.runFinalizersOnExit()</code>, <code>Runtime.runFinalizersOnExit()</code>는 종료자 실행을 보장하지만, 심각한 결함을 갖고 있어 이미 명세에서 deprecated 되었다.</li>
<li><strong>종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.</strong></li>
<li><strong>명시적인 종료 메서드<sub>termination method</sub>를 하나 정의</strong>하고, 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메서드를 호출하도록 하라. 명심할 것은, 종료 여부를 객체 안에 보관해야 한다(유효하지 않은 객체임을 표시하는 private 필드 선언).</li>
<li><strong>명시적 종료 메서드는 보통 try-finally 문과 함께 쓰인다. 객체 종료를 보장하기 위해서다.</strong> Java1.7부터는 try-with-resources문 제공하기 때문에 finally 블록은 사용하지 않아도 된다(<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" rel="external nofollow noopener noreferrer" target="_blank">try-with-resources</a>).</li>
</ul>
<h4 id="사용하기-적합한-곳"><a href="#사용하기-적합한-곳" class="headerlink" title="사용하기 적합한 곳"></a>사용하기 적합한 곳</h4><ul>
<li><p>명시적 종료 메서드 호출을 잊을 경우를 대비하는 안전망<sub>safety net</sub>으로서의 역할.</p>
<p>  <strong>종료자는 반환되지 않은 자원을 발견하게 될 경우 반드시 log를 남겨야 한다.</strong> 클라이언트 코드에 버그가 있는 것이므로, 고치도록 알려야 하기 때문이다. (추가 비용을 감당하면서 구현할 가치가 있는지 신중하게 생각한다)</p>
</li>
<li><p><em>네이티브 피어<sub>native peer: 일반 자바 객체가 네이티브 메서드를 통해 기능 수행을 위임하는 네이티브 객체</sub></em>와 연결된 객체를 다룰 때.</p>
<p>  네이티브 피어는 일반 객체가 아니므로, 객체가 소멸되더라도 GC는 모른다(GC가 알 수 없을 뿐더라 Java peer가 반환될 때 같이 반환할 수도 없다). 네이티브 피어가 중요한 자원을 점유하고 있지 않다고 가정한다면, 종료자는 그런 객체의 반환에 걸맞다. 즉시 종료되어야 하는 자원을 포함하는 경우에는, 명시적인 종료 메서드를 클래스에 추가해야 한다.</p>
</li>
</ul>
<h4 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h4><ul>
<li><p>finalizer chaining이 자동으로 이루어지지 않는다.</p>
<p>  종료자를 구현한 클래스를 상속받은 경우, 하위 클래스의 종료자는 상위클래스의 종료자를 명시적으로 호출해야 한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ...</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 반드시 호출시키기 위해 try-finally 사용</span></div><div class="line">    <span class="keyword">super</span>.finalize();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>더 나은 방법 - 종료 보호자 패턴</strong></p>
<p>  종료되어야 하는 객체의 클래스마다 안에 종료자를 정의하는 대신 익명 클래스를 활용하는 방법. 이 익명 클래스로 만든 객체를 <em>종료 보호자<sub>finalizer guardian</sub></em>라고 한다. Foo 객체의 참조가 사라지는 순간 종료 보호자도 실행 가능한 상태가 된다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 종료 보호자 숙어(Finalizer Fuardian idiom)</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="comment">// 이 객체는 바깥 객체(Foo)를 종료시키는 역할만 한다</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object finalizerFuardian = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finaliza</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">      <span class="comment">// 바깥 Foo 객체를 종료시킴</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/02/21/creating-and-destroying-objects-3/#규칙-6-유효기간이-지난-객체-참조는-폐기하라&quot;&gt;규칙 6&lt;/a&gt; - 유효기간이 지난 객체 참조는 폐기하라&lt;br&gt;&lt;a href=&quot;../../../../2017/02/21/creating-and-destroying-objects-3/#규칙-7-종료자-사용을-피하라&quot;&gt;규칙 7&lt;/a&gt; - 종료자 사용을 피하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 2장. 객체 생성과 삭제 - 2</title>
    <link href="https://wickso.me/2017/02/12/creating-and-destroying-objects-2/"/>
    <id>https://wickso.me/2017/02/12/creating-and-destroying-objects-2/</id>
    <published>2017-02-12T01:00:00.000Z</published>
    <updated>2017-05-21T11:41:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-3-private-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계하라">규칙 3</a> - private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라<br><a href="../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-4-객체-생성을-막을-때는-private-생성자를-사용하라">규칙 4</a> - 객체 생성을 막을 때는 private 생성자를 사용하라<br><a href="../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-5-불필요한-객체는-만들지-말라">규칙 5</a> - 불필요한 객체는 만들지 말라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-3-private-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계하라"><a href="#규칙-3-private-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계하라" class="headerlink" title="규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라"></a>규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라</h2><blockquote>
<p><a href="dp-singleton">싱글턴</a>은 객체를 하나만 만들 수 있는 클래스다.</p>
</blockquote>
<h4 id="singleton-구현-방법"><a href="#singleton-구현-방법" class="headerlink" title="singleton 구현 방법"></a>singleton 구현 방법</h4><h6 id="public-static-final-상수before-jdk-15"><a href="#public-static-final-상수-before-JDK-1-5" class="headerlink" title="public static final 상수(before JDK 1.5)"></a><em>public static final</em> 상수(before JDK 1.5)</h6><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>문제점</strong></p>
<ul>
<li>리플렉션으로 private 생성자 호출 가능</li>
<li>생성자에서 에러날 경우 예외처리 불가능 -&gt; static 초기화 블럭으로 해결 가능</li>
</ul>
<h6 id="static-factory-메서드before-jdk-15"><a href="#static-factory-메서드-before-JDK-1-5" class="headerlink" title="static factory 메서드(before JDK 1.5)"></a><em>static factory</em> 메서드(before JDK 1.5)</h6><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> INSTANCE;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>문제점</strong></p>
<ul>
<li>리플렉션으로 private 생성자 호출 가능</li>
<li><p>위 두 방법에서 <a href="#serializable">직렬화</a>가능 클래스로 만드려면 클래스 선언에 <code>implements Serializable</code>을 추가하는 것으로는 부족하다.</p>
<ul>
<li>클래스 선언에 <code>implements Serializable</code> 추가</li>
<li>모든 객체 필드에 <code>transient</code> 선언</li>
<li><p><a href="#item77"><code>readResolve()</code> 추가</a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 동일한 객체가 반환되도록 하는 동시에,</span></div><div class="line">  <span class="comment">// 가짜 객체는 gc가 처리하도록 만든다.</span></div><div class="line">  <span class="keyword">return</span> INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>thread safe하려면 synchronized 적용</p>
  <figure class="highlight"><table><tr><td class="code"><pre><div class="line">  public static synchronized Single getInstance() &#123; ... &#125;</div><div class="line">  ```  </div><div class="line"></div><div class="line">###### Initialization on demand holder idiom</div><div class="line"></div><div class="line">- jvm 의 class loader의 매커니즘과 class의 load 시점을 이용하여 내부 class를 생성시킴으로 thread 간의 동기화 문제를 해결</div><div class="line">- lazy initialization</div><div class="line"></div><div class="line">```java</div><div class="line">public class Singleton &#123;</div><div class="line">  private Singleton() &#123; &#125;</div><div class="line"></div><div class="line">  private static class SingletonHolder &#123;</div><div class="line">          public static final Singleton INSTANCE = new Singleton();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static Singleton getInstance() &#123;</div><div class="line">          return SingletonHolder.INSTANCE;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="enum을-이용하는-방법after-jdk-15"><a href="#enum을-이용하는-방법-after-JDK-1-5" class="headerlink" title="enum을 이용하는 방법(after JDK 1.5)"></a><em>enum</em>을 이용하는 방법(after JDK 1.5)</h6><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Single &#123;</div><div class="line">  INSTANCE;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>직렬화 자동으로 처리된다.</li>
<li>리플렉션 공격에도 안전하다.</li>
<li>Enum 생성은 Thread-safe하지만, 내부 메서드들은 Thread-safe를 보장하지 않는다.</li>
</ul>
<p><em>why?</em></p>
<ul>
<li>선언된 상수 이외의 다른 객체는 존재할 수 없다는 확실한 보장이 생긴다(JVM이 해주는 보장).</li>
<li><code>enum</code> 타입은 <code>Comparable</code> 인터페이스, <code>Serializable</code> 인터페이스가 구현되어 있다.</li>
</ul>
<h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><h6 id="link"><a href="#Link" class="headerlink" title="Link"></a>Link</h6><ul>
<li>java singleton pattern (싱글톤 패턴) - <a href="https://blog.seotory.com/post/2016/03/java-singleton-pattern" rel="external nofollow noopener noreferrer" target="_blank">https://blog.seotory.com/post/2016/03/java-singleton-pattern</a></li>
<li>게으른 홀더를 통한 싱글턴의 동시성 문제 해결 (Initialization on demand holder idiom) - <a href="http://changsuk.me/?p=1433" rel="external nofollow noopener noreferrer" target="_blank">http://changsuk.me/?p=1433</a></li>
<li>Thread-safe Enum Singleton - <a href="http://stackoverflow.com/questions/28369025/thread-safe-enum-singleton" rel="external nofollow noopener noreferrer" target="_blank">http://stackoverflow.com/questions/28369025/thread-safe-enum-singleton</a></li>
</ul>
<h6 id="serializable"><a href="#serializable" class="headerlink" title="serializable"></a>serializable</h6><blockquote>
<p>객체의 내용을 파일에 저장하거나 네트워크로 전송하기 위해서 스트림으로 만드는 작업(바이트 단위로 변환)</p>
</blockquote>
<ul>
<li><code>Serializable</code> 인터페이스 구현</li>
<li>모든 필드 또한 <code>Serializable</code> 인터페이스 구현</li>
<li>제외하고자하는 필드는 <code>transient</code></li>
</ul>
<p><em>example</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">    SerializerTest test = <span class="keyword">new</span> SerializerTest();</div><div class="line">    test.serialization();</div><div class="line">    test.deserialization();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializerTest</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String filePath = <span class="string">"/Users/yeongjun/Desktop/test.ser"</span>;</div><div class="line">  <span class="keyword">private</span> User user;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialization</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    user = <span class="keyword">new</span> User(<span class="string">"yj"</span>, <span class="number">26</span>, <span class="string">"pwd"</span>);</div><div class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(filePath);</div><div class="line">    ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(f); <span class="comment">// 직렬화 클래스</span></div><div class="line">    o.writeObject(user); <span class="comment">// 파라미터로 넘긴 객체를 스트림으로 만들어서 출력하는 메서드</span></div><div class="line">    o.close();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deserialization</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">    FileInputStream f = <span class="keyword">new</span> FileInputStream(filePath);</div><div class="line">    ObjectInputStream o = <span class="keyword">new</span> ObjectInputStream(f); <span class="comment">// 역직렬화 클래스</span></div><div class="line">    user = (User)o.readObject(); <span class="comment">// 입력된 스트림으로부터 객체를 만들어서 반환하는 메서드</span></div><div class="line">    o.close();</div><div class="line">    System.out.println(user.toString());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>; <span class="comment">// 이건 왜?</span></div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> String password;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age, String password)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.password = password;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"User&#123;name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">", password='"</span> + password + <span class="string">"\'&#125;"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="규칙-4-객체-생성을-막을-때는-private-생성자를-사용하라"><a href="#규칙-4-객체-생성을-막을-때는-private-생성자를-사용하라" class="headerlink" title="규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라"></a>규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라</h2><ul>
<li>생성자를 생략하면 컴파일러는 자동으로 인자없는 <code>public</code> 생성자를 만든다. 그러므로, 객체 생성을 막기 위해서 <code>private</code> 생성자를 추가한다.</li>
<li><code>AssertionError()</code>를 통해 혹시나 클래스내에서 생성자를 사용할 경우를 방지한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123;		</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>cf.</strong> <em>Code with <a href="https://projectlombok.org/features/experimental/UtilityClass.html" rel="external nofollow noopener noreferrer" target="_blank">Lombok</a></em></p>
<ul>
<li>필드, 메서드를 static으로 변환</li>
<li>private 생성자 추가</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@UtilityClass</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION  = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> VERSION;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="규칙-5-불필요한-객체는-만들지-말라"><a href="#규칙-5-불필요한-객체는-만들지-말라" class="headerlink" title="규칙 5. 불필요한 객체는 만들지 말라"></a>규칙 5. 불필요한 객체는 만들지 말라</h2><ul>
<li>변경 불가능(immutable) 객체는 언제나 재용사할수 있다.(<a href="#item15">규칙 15</a>)</li>
<li><p><em>Bad Practice</em> 코드는 실행될 때마다 <code>String</code> 객체를 만드는 쓸데없는 짓을 한다. loop 도는 만큰 <code>String</code> 객체를 생성한다. <em>Good Practices</em>는 실행할 때마다 객체를 생성하지 않고, 동일한 <code>String</code> 객체를 사용한다. 같은 가상머신에서 실행되는 모든 코드가 해당 객체를 사용한다(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5" rel="external nofollow noopener noreferrer" target="_blank">JLS, 3.10.5</a>).</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</div><div class="line">  <span class="comment">// Bad Practice</span></div><div class="line">  System.out.println(<span class="keyword">new</span> String(<span class="string">"test"</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Good Practice</span></div><div class="line">  System.out.println(<span class="string">"test"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Static Factory Method(<a href="#item1">규칙 1</a>)를 이용하면 불필요한 객체 생성을 피할 수 있다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Boolean.valueOf(String)</div></pre></td></tr></table></figure>
</li>
<li><p>변경 가능한 객체이지만 변경할 일이 없다면 재사용한다.</p>
<p>  <em>AS-IS</em></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date birthDate;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBabyBoomer</span><span class="params">()</span> </span>&#123;</div><div class="line">    Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">"GMT"</span>));</div><div class="line">    gmtCal.set(<span class="number">1946</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    Date boomStart = gmtCal.getTime();</div><div class="line">    gmtCal.set(<span class="number">1965</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    Date boomEnd = gmtCal.getTime();</div><div class="line">    <span class="keyword">return</span> birthDate.compareTo(boomStart) &gt;= <span class="number">0</span> &amp;&amp; birthDate.compareTo(boomEnd) &lt; <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <em>TO-BE</em></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date birthDate;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Date BOOM_START;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Date BOOM_END;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">"GMT"</span>));</div><div class="line">    gmtCal.set(<span class="number">1946</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    BOOM_START = gmtCal.getTime();</div><div class="line">    gmtCal.set(<span class="number">1965</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    BOOM_END = gmtCal.getTime();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBabyBoomer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> birthDate.compareTo(BOOM_START) &gt;= <span class="number">0</span> &amp;&amp; birthDate.compareTo(BOOM_END) &lt; <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  static initialzer을 하지않고 <a href="#item71">lazy initialization</a> 기법을 사용할 수도 있다. 하지만, 추천하지 않는다. 구현이 복잡해질 뿐더러 <em>TO-BE</em>로 개선한 것 이상으로 성능을 높이기 어렵기 때문이다(<a href="#item55">규칙 55</a>).</p>
</li>
<li><p>어댑터 TO-DO</p>
</li>
<li><p>JDK 1.5 이후, 쓸데없는 객체 생성하는 방법 추가 - autoboxing</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Long sum = <span class="number">0L</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class="line">    sum += i;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <code>sum</code>이 <code>long</code>이 아닌 <code>Long</code>으로 선언되어 있기 때문에 더해질때마다 객체가 생성된다(2^31개 생성). 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않도록 유의하라.</p>
</li>
<li><p>직접 관리하는 객체 풀을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다.</p>
<p>  독자적으로 관리되는 객체풀을 만들면,</p>
<ul>
<li>코드의 복잡성</li>
<li>메모리 요구량 증가</li>
<li>성능 떨어짐: 사용해야할 상황 - <strong>데이터베이스</strong></li>
<li>접속 비용이 큼</li>
<li>라이선스 정책에 따라 연결 수가 제한될 수 있음</li>
</ul>
</li>
<li><p>규칙 39는 방어적 복사<sub>defensive copy</sub>에 관한 것.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 방어적 복사 방법</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</div><div class="line">    <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>규칙 5: “재사용이 가능하다면 새로운 객체는 만들지 말라”</li>
<li><a href="#item39">규칙 39</a>: “새로운 객체를 만들어야 한다면 기존 객체는 재사용하지 말라”<br> 방어적 복사가 요구되는 상황에서 객체를 재사용하는 것은 (쓸데없이 같은 객체를 만드는) 비용보다 훨씬 높다는 것에 유의하자. 필요할 때 방어적 복사본을 만들지 못하면 버그나 보안 결함으로 이어진다. 쓸데 없는 객체들은 고작 코드 스타일과 성능에나 영향을 줄 뿐이다.</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-3-private-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계하라&quot;&gt;규칙 3&lt;/a&gt; - private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라&lt;br&gt;&lt;a href=&quot;../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-4-객체-생성을-막을-때는-private-생성자를-사용하라&quot;&gt;규칙 4&lt;/a&gt; - 객체 생성을 막을 때는 private 생성자를 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/02/12/creating-and-destroying-objects-2/#규칙-5-불필요한-객체는-만들지-말라&quot;&gt;규칙 5&lt;/a&gt; - 불필요한 객체는 만들지 말라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>Factory Method Pattern</title>
    <link href="https://wickso.me/2017/02/10/factory-method-pattern/"/>
    <id>https://wickso.me/2017/02/10/factory-method-pattern/</id>
    <published>2017-02-10T01:00:00.000Z</published>
    <updated>2017-05-21T11:45:45.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="의도"><a href="#의도" class="headerlink" title="의도"></a>의도</h2><p>객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.</p>
<blockquote><p>Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다.</p>
<footer><strong>위키백과</strong><cite><a href="https://ko.wikipedia.org/wiki/%ED%8C%A9%ED%86%A0%EB%A6%AC_%EB%A9%94%EC%84%9C%EB%93%9C_%ED%8C%A8%ED%84%B4" rel="external nofollow noopener noreferrer" target="_blank">팩토리 메서드 패턴</a></cite></footer></blockquote>
<h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p><img src="https://www.codeproject.com/KB/architecture/csdespat_1/dpcs_fm.gif" alt="Factory Method Pattern"></p>
<h2 id="활용성"><a href="#활용성" class="headerlink" title="활용성"></a>활용성</h2><ul>
<li>어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때</li>
<li>생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때</li>
<li>객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때</li>
</ul>
<a id="more"></a>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>예를 들어 다양한 종류의 문서를 표현하는 응용프로그램 프레임워크가 있다. 이를 위해서는 일단 두 개의 큰 추상화가 필요하다. 하나는 <em>Creator</em>(응용프로그램) 추상 클래스이고, 다른 하나는 <em>Product</em>(문서) 추상 클래스(혹은 인터페이스)이다.<br><em>Creator</em> 클래스는 문서의 인스턴스를 ++언제++ 만들지는 알지만, ++어떤 문서++를 만들어야 하는지는 알지 못한다. <em>Product</em> 클래스가 추상 클래스이기 때문에 인스턴스를 가질 수 없기 때문이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> createProduct(); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>; <span class="comment">// factory method</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>팩토리 메서드 패턴은 이런 문제에 대한 해법을 제시한다. <em>Document</em>의 서브클래스 중 어느 것을 생성해야 하는지에 대한 정보를 캡슐화하고, 그것을 프레임워크에서 떼어낸다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><em>TextProduct</em> 클래스와 PhotoProduct 클래스를 팩토리 메서드 패턴을 활용하여 생성한다면 아래와 같은 방법이 있다.</p>
<h4 id="방법-1-추상-클래스"><a href="#방법-1-추상-클래스" class="headerlink" title="방법 1) 추상 클래스"></a>방법 1) 추상 클래스</h4><p>사용자는 특정 응용프로그램에 종속적인 구현을 위해서 두 클래스의 서브 클래스를 정의할 수 있다. <em>Creator</em> 클래스는 <em>Product</em> 객체를 관리하는 책임을 맡고 있으며, 필요에 따라 문서를 생성할 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern example with abstract class</span></div><div class="line">Creator textCreator = <span class="keyword">new</span> TextCreator();</div><div class="line">Product p1 = textCreator.newProduct();</div><div class="line"></div><div class="line">Creator photoCreator = <span class="keyword">new</span> PhotoCreator();</div><div class="line">Product p2 = photoCreator.newProduct();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WordProduct();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PhotoProduct();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-2-팩토리-메서드-매개변수화-abstract-factory-pattern"><a href="#방법-2-팩토리-메서드-매개변수화-abstract-factory-pattern" class="headerlink" title="방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern"></a>방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern</h4><p>팩토리 메서드가 매개변수를 받아서 어떤 종류의 제품을 생성할지 만드는 방법도 있다. (추상 팩토리 패턴은 팩토리 메서드를 이용해서 구현할 때가 많다)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Factory pattern example using argument</span></div><div class="line">Product p1 = Creator1.create(ProductType.TEXT);</div><div class="line">Product p2 = Creator1.create(ProductType.PHOTO);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ProductType &#123;</div><div class="line">  TEXT, PHOTO</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Product <span class="title">create</span><span class="params">(ProductType type)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">      <span class="keyword">case</span> TEXT:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExcelProduct();</div><div class="line">      <span class="keyword">case</span> PHOTO:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImageProduct();</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-3-lazy-initialization-기법"><a href="#방법-3-Lazy-Initialization-기법" class="headerlink" title="방법 3) Lazy Initialization 기법"></a>방법 3) Lazy Initialization 기법</h4><p>인스턴스화하는 접근자 메서드를 통해서만 인스턴스에 접근하는 방법으로, 생성자에서 아무 의미 없는 값으로 인스턴스에 대한 매개변수를 초기화하고, 접근자 메서드가 인스턴스를 반환하도록 할 수 있다. 생성자가 초기화 시키는 것이 아니라 필요한 시점에서 초기화를 수행하기 때문에 이런 기법을 Lazy Initialization이라고 한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern with lazy initialization</span></div><div class="line">TextCreator textCreator = <span class="keyword">new</span> TextCreator();</div><div class="line">List collection = textCreator.newCollection();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> List <span class="title">createCollection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TextProduct&gt;();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> List&lt;Product&gt; collection = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> List <span class="title">newCollection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// lazy initialization</span></div><div class="line">    <span class="keyword">if</span> (collection == <span class="keyword">null</span>) &#123;</div><div class="line">      collection = createCollection();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> collection;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// factory method</span></div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> List <span class="title">createCollection</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-4-템플릿-활용"><a href="#방법-4-템플릿-활용" class="headerlink" title="방법 4) 템플릿 활용"></a>방법 4) 템플릿 활용</h4><p>팩토리 메서드를 사용하면 생길 수 있는 문제점 중 하나는 <em>Product</em> 클래스 하나를 추가하려 할 때마다 <em>Creator</em> 클래스를 서브클래싱해야 한다는 점이다(<a href="#방법-1-추상-클래스">방법 1</a>). 이로써 클래스 계통의 부피가 확장되는 문제가 생길 수 있다. 이런 문제를 해결할 수 있는 방법 중 하나는 <em>Creator</em> 클래스를 상속받는 제네릭 클래스를 정의하고 Product 클래스로 매개변수화되도록 만드는 것이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern example whti template</span></div><div class="line">StandardCreator&lt;WordProduct&gt; wordProductCreator = <span class="keyword">new</span> StandardCreator&lt;&gt;(WordProduct.class);</div><div class="line">Product p1 = wordProductCreator.newProduct();</div><div class="line"></div><div class="line">StandardCreator&lt;ImageProduct&gt; imageProductCreator = <span class="keyword">new</span> StandardCreator&lt;&gt;(ImageProduct.class);</div><div class="line">Product p2 = imageProductCreator.newProduct();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creator Template</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; product type</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardCreator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Product</span>&gt; <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Class&lt;T&gt; cls;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StandardCreator</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.cls = cls;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    T product = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      product = cls.newInstance();</div><div class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> product;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>[<a href="http://wiki.c2.com/?GangOfFour" rel="external nofollow noopener noreferrer" target="_blank">GOF</a>{kr}:156] - 팩토리 메서드</li><br>        <li>GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.</li><br>    </ul><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;의도&quot;&gt;&lt;a href=&quot;#의도&quot; class=&quot;headerlink&quot; title=&quot;의도&quot;&gt;&lt;/a&gt;의도&lt;/h2&gt;&lt;p&gt;객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;위키백과&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8C%A9%ED%86%A0%EB%A6%AC_%EB%A9%94%EC%84%9C%EB%93%9C_%ED%8C%A8%ED%84%B4&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;팩토리 메서드 패턴&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;구조&quot;&gt;&lt;a href=&quot;#구조&quot; class=&quot;headerlink&quot; title=&quot;구조&quot;&gt;&lt;/a&gt;구조&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www.codeproject.com/KB/architecture/csdespat_1/dpcs_fm.gif&quot; alt=&quot;Factory Method Pattern&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;활용성&quot;&gt;&lt;a href=&quot;#활용성&quot; class=&quot;headerlink&quot; title=&quot;활용성&quot;&gt;&lt;/a&gt;활용성&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때&lt;/li&gt;
&lt;li&gt;생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때&lt;/li&gt;
&lt;li&gt;객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="design pattern" scheme="https://wickso.me/tags/design-pattern/"/>
    
      <category term="creational pattern" scheme="https://wickso.me/tags/creational-pattern/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 2장. 객체 생성과 삭제 - 1</title>
    <link href="https://wickso.me/2017/02/10/creating-and-destroying-objects-1/"/>
    <id>https://wickso.me/2017/02/10/creating-and-destroying-objects-1/</id>
    <published>2017-02-10T01:00:00.000Z</published>
    <updated>2017-05-21T11:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/02/10/creating-and-destroying-objects-1/#규칙-1-생성자-대신-static-factory-method-사용을-고려하자">규칙 1</a> - 생성자 대신 static factory method 사용을 고려하자<br><a href="../../../../2017/02/10/creating-and-destroying-objects-1/#규칙-2-생성자의-매개변수가-많을-때는-빌더-builder-를-고려하자">규칙 2</a> - 생성자의 매개변수가 많을 때는 빌더(builder)를 고려하자</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-1-생성자-대신-static-factory-method-사용을-고려하자"><a href="#규칙-1-생성자-대신-static-factory-method-사용을-고려하자" class="headerlink" title="규칙 1. 생성자 대신 static factory method 사용을 고려하자"></a>규칙 1. 생성자 대신 static factory method 사용을 고려하자</h2><blockquote>
<p>클래스를 통해 객체를 만드는 방법</p>
<ul>
<li>Constructor</li>
<li>Static factory method<br>  (Design Patterns에 나오는 [팩토리 메서드 패턴][dp-factory-method]과 다르다.)</li>
</ul>
</blockquote>
<p><em>Static factory method 예제 코드</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> value;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</div><div class="line">    FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</div><div class="line">    <span class="comment">// Q. static 초기화 블록 vs 선언과 동시에 생성</span></div><div class="line">    <span class="comment">// A. 초기화 블록은 클래스 초기화 될 떄 수행하고, 동시 생성은 언제?</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Boolean</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123; <span class="keyword">this</span>.value = b; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Boolean</span><span class="params">(String str)</span> </span>&#123; <span class="keyword">this</span>.value = <span class="string">"true"</span>.equalsIgnoreCase(str); &#125;</div><div class="line">  	<span class="comment">// Q. str.equalsIgnoreCase("true") 를 안쓰는 이유</span></div><div class="line">  <span class="comment">// A. str이 null이면 NullPointException 발생</span></div><div class="line"></div><div class="line">  <span class="comment">// Static factory method</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span> b = (<span class="keyword">boolean</span>)Boolean.TRUE; <span class="comment">// unboxing</span></div><div class="line">Boolean b = (Boolean)<span class="keyword">true</span>; <span class="comment">// boxing</span></div><div class="line">Boolean b = <span class="keyword">true</span>; <span class="comment">// auto boxing</span></div><div class="line">Boolean b = Boolean.valueOf(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<p>public으로 선언된 생성자 대신 Static factory method를 제공하는 방법의 장단점은 아래와 같다.</p>
<h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><p><em>java.utils.Collections</em> 클래스에는 Static factory method의 장점이 대부분 적용되어 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123; <span class="comment">// 3-3</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Collections</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 2-2(Non-instantiable class)</span></div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map EMPTY_MAP = <span class="keyword">new</span> EmptyMap&lt;&gt;(); <span class="comment">// 2-1, 2-2(Singleton)</span></div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">emptyMap</span><span class="params">()</span> </span>&#123; <span class="comment">// 1, 3-2, 4</span></div><div class="line">    <span class="keyword">return</span> (Map&lt;K,V&gt;) EMPTY_MAP;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; // 3-1</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Serializable</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;<span class="comment">/* ... */</span>&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 3-3</span></div></pre></td></tr></table></figure>
<ol>
<li>이해하기 쉬운 이름의 메서드를 생성자로 사용할 수 있다(가독성).<br> 클래스의 인스턴스를 생성하는데 있어서 매개변수의 타입과 갯수로 구별하는 것보단 잘 지은 이름이 더 파악하기 쉽다.</li>
<li><p>호출할 때마다 인스턴스화하지 않아도 된다.</p>
<ol>
<li>만든 객체를 캐시<sub>cache</sub> 해놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수 있다.<br> <code>Boolean.value(boolean)</code>는 이 기법을 활용한 좋은 사례로 [Flyweight 패턴][dp-flyweight]과 유사하다. 동일한 객체가 요청되는 일이 잦고, 특히 객체를 만드는 비용이 클 때 적용하면 성능을 크게 개선할 수 있다.</li>
<li><p>같은 객체를 반복해서 반환할 수 있다.</p>
<blockquote>
<p>어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. 그런 기능을 갖춘 클래스를 <em>개체 통제 클래스<sub>instance-controlled class</sub></em>라고 부른다.</p>
</blockquote>
<p> 개체 통제 클래스를 작성하는 이유는 아래와 같다.</p>
<ul>
<li><a href="#item3">Singleton pattern</a> 적용</li>
<li><p><a href="#item4">Non-instantiable class</a> 생성 가능(e.g. Utility class)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="#item15">불변 클래스</a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Complex</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> re;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> im;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Complex</span><span class="params">(<span class="keyword">double</span> re, <span class="keyword">double</span> im)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.re = re;</div><div class="line">        <span class="keyword">this</span>.im = im;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Complex <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> re, <span class="keyword">double</span> im)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(re, im);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="#item30">enum</a>이 이 기법을 사용</li>
<li><code>equals()</code> 대신 <code>==</code> 연산자 사용 가능</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>자신의 인스턴스만 반환하는 생성자와는 달리, 서브타입 객체도 반환 가능하다.</p>
<blockquote>
<ol>
<li>“public으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다. 그러면 구현 세부사항을 감출 수 있으므로 아주 간결한 API가 가능하다.”</li>
<li>“이 기법은 인터페이스 기반 프레임워크(interface-based framework) 구현에 적합한데, 이 프레임워크에서 인터페이스는 정적 팩터리 메서드의 반환값 자료형으로 이용된다.”</li>
<li>“관습상 반환값 자료형이 Type이라는 이름의 인터페이스인 정적 팩터리 맥서드를 Types라는 이름의 객체 생성 불가능 클래스안에 둔다.”</li>
</ol>
</blockquote>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruits</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Fruits</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getBanana</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Banana(); &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getApple</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Apple(); &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"apple"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"banana"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  Fruit apple = Fruits.getApple();</div><div class="line">  apple.getName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>제네릭 클래스의 인스턴스를 생성하는 코드를 간결하게 해준다.</p>
<p> static 팩토리 메서드를 사용하면 컴파일러가 타입 추론(type inference)으로 해결할 수 있다.</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// before</span></div><div class="line">Map&lt;String, List&lt;String&gt;&gt; m = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">// after: 1.6 버전</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">HashMap&lt;K, V&gt; <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K, V&gt;();</div><div class="line">&#125;</div><div class="line">Map&lt;String, List&lt;String&gt;&gt; m = HahsMap.newInstance();</div><div class="line"></div><div class="line"><span class="comment">// after: 1.7</span></div><div class="line"><span class="comment">// &lt;&gt;(다이아몬드) 연산자 추가</span></div><div class="line">Map&lt;String, List&lt;String&gt;&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><ol>
<li><p>Static factory method만 있는 클래스는 public이나 protected로 선언된 클래스가 없으므로 하위 클래스를 만들 수 없다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</div><div class="line">  Collections() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// inheritance</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCollections</span> <span class="keyword">extends</span> <span class="title">Collections</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomCollections</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(); <span class="comment">// 불가능</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>그러므로, <a href="#item16">Composition</a>을 사용한다.</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// composition</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCollections</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Collections collections;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>상속을 사용하는 경우: <code>is-a</code> 관계</li>
<li>컴포지션을 사용하는 경우: <code>has-a</code> 관계</li>
</ul>
</li>
<li><p>다른 Static factory method와 쉽게 구별할 수 없다.</p>
<p> API 문서에 메서드와 생성자가 분리되어 있지만, static 팩토리 메서드는 다른 메서드와 섞여 잘 구분되지 않는다. 그래서 컨벤션을 정하여 보다 구별하기 쉽게 한다.</p>
<ul>
<li><code>valueOf</code>: 자신의 매개변수와 같은 값을 갖는 인스턴스를 반환</li>
<li><code>of</code>: <code>valueOf</code> 줄인 형태, <a href="#item32"><em>EnumSet</em></a>에서 사용</li>
<li><code>getInstance</code>: 매개변수에 맞는 인스턴스 반환, 싱글톤인 경우 하나의 인스턴스 반환</li>
<li><code>newInstance</code>: 새로운 인스턴스 반환</li>
<li><code>get</code><em>Type</em>: <code>getInstance</code>와 유사하나 팩토리 메서드가 다른 클래스에 있을 때 사용. 여기서 <em>Type</em>은 팩토리 메서드에서 반환되는 객체의 타입을 나타낸다.</li>
<li><code>new</code><em>Type</em>: <code>get</code><em>Type</em>와 같음(?)</li>
</ul>
</li>
</ol>
<hr>
<h2 id="규칙-2-생성자의-매개변수가-많을-때는-빌더builder를-고려하자"><a href="#규칙-2-생성자의-매개변수가-많을-때는-빌더-builder-를-고려하자" class="headerlink" title="규칙 2. 생성자의 매개변수가 많을 때는 빌더(builder)를 고려하자"></a>규칙 2. 생성자의 매개변수가 많을 때는 빌더(builder)를 고려하자</h2><p>선택적 인자가 많을 때 객체를 생성하는 방법 세 가지.</p>
<h4 id="방법-1-점층적-생성자-패턴telescoping-constructor-pattern"><a href="#방법-1-점층적-생성자-패턴-telescoping-constructor-pattern" class="headerlink" title="방법 1) 점층적 생성자 패턴(telescoping constructor pattern)"></a>방법 1) 점층적 생성자 패턴(telescoping constructor pattern)</h4><blockquote>
<p><em>Bad Practice 👎</em></p>
</blockquote>
<ul>
<li>이 방법은 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 받는 생성자를 추가하는 것이다.</li>
<li>객체를 생성할 때는 설정하려는 인자 갯수에 맞는 생성자를 골라 호출한다.</li>
</ul>
<p><strong>문제점</strong></p>
<ul>
<li>설정할 필요가 없는 필드에도 인자를 전달해야 해야 한다.</li>
<li>인자 수가 늘어날수록 가독성이 떨어진다.</li>
</ul>
<p><em>Code</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">// 필수</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age; <span class="comment">// 필수</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mail;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String city;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String state;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(name, age, <span class="string">""</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String mail)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(name, age, mail, <span class="string">""</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String mail, String city)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(name, age, mail, city, <span class="string">""</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String mail, String city, String state)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.mail = mail;</div><div class="line">    <span class="keyword">this</span>.city = city;</div><div class="line">    <span class="keyword">this</span>.state = state;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Usage</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Person me = <span class="keyword">new</span> Person(<span class="string">"yeongjun.kim"</span>, <span class="string">"27"</span>);</div><div class="line">Person me = <span class="keyword">new</span> Person(<span class="string">"yeongjun.kim"</span>, <span class="string">"27"</span>, <span class="string">"opid911@gmail.com"</span>);</div></pre></td></tr></table></figure>
<h4 id="방법-2-javabeans-패턴"><a href="#방법-2-JavaBeans-패턴" class="headerlink" title="방법 2) JavaBeans 패턴"></a>방법 2) JavaBeans 패턴</h4><blockquote>
<p><em>Bad Practice 👎</em></p>
</blockquote>
<ul>
<li>인자 없는 생성자를 호출하여 객체를 만들고, setter로 값 설정하는 방법.</li>
<li>객체 생성도 쉽고, 가독성도 좋다.</li>
</ul>
<p><strong>문제점</strong></p>
<ul>
<li>1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성이 일시작으로 깨질 수 있다.</li>
<li>변경 불가능 클래스를 만들 수 없다. 해결하기 위해서 추가 구현할 코드가 많아진다.</li>
</ul>
<p><em>Code</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Setter</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">  <span class="keyword">private</span> String mail;</div><div class="line">  <span class="keyword">private</span> String city;</div><div class="line">  <span class="keyword">private</span> String state;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Usage</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Person me = <span class="keyword">new</span> Person();</div><div class="line">me.setName(<span class="string">"yeongjun.kim"</span>);</div><div class="line">me.setAge(<span class="number">27</span>);</div></pre></td></tr></table></figure>
<h4 id="방법-3-builder-패턴︎dp-builder"><a href="#방법-3-Builder-패턴-↩︎-dp-builder" class="headerlink" title="방법 3) Builder 패턴[↩︎][dp-builder]"></a>방법 3) Builder 패턴[↩︎][dp-builder]</h4><blockquote>
<p><strong><em>Good Practice 👍</em></strong></p>
</blockquote>
<ul>
<li><p>필수 인자들을 생성자(또는 정적 팩터리 메서드)에 전달하여 빌더 객체를 만들고, 선택적 인자들을 추가한 뒤, 마지막에 <code>build()</code>를 호출하여 Immutable 객체를 만드는 방법.</p>
<p>  <em>Code</em></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mail;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String city;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String state;</div><div class="line"></div><div class="line">  <span class="comment">// 빌더 객체</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="comment">// 필수 인자</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String age;</div><div class="line">    <span class="comment">// 선택적 인자 - 기본값으로 초기화</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mail = <span class="string">""</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String city = <span class="string">""</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String state = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String of, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">mail</span><span class="params">(String mail)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.mail = mail;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">city</span><span class="params">(String city)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.city = city;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">state</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.state = state;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.mail = mail;</div><div class="line">    <span class="keyword">this</span>.city = city;</div><div class="line">    <span class="keyword">this</span>.state = state;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <em>Usage</em></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Person me = Person.Builder(<span class="string">"yeongjun.kim"</span>, <span class="number">27</span>)</div><div class="line">  .mail(<span class="string">"opid911@gmail.com"</span>)</div><div class="line">  .build();</div></pre></td></tr></table></figure>
</li>
<li><p>빌더 클래스(<em>Builder</em>)는 빌더가 만드는 객체 클래스(<em>Person</em>)의 정적 맴버 클래스로 정의한다(<a href="#item22">규칙 22</a>).</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>불변식을 적용할 수 있으며, build()에서 불변식이 위반되었는지 검사할 수 있다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      Person result = <span class="keyword">new</span> Person(<span class="keyword">this</span>);</div><div class="line">      <span class="keyword">if</span>(<span class="comment">/* result의 값 검사 */</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="comment">/* 위반 원인 */</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>빌더 객체에서 실제 객체로 인자가 복사된 다음에 불변식들을 검사할 수 있다는 것, 그리고 그 불변식을 빌더 객체의 필드가 아니라 실제 객체의 필드를 두고 검사할 수 있다는 것은 중요하다(<a href="#item39">규칙 39</a>).</li>
<li>불변식을 위반한 경우, <em>build()</em>는 <em>IllegalStateException</em>을 던져야 한다(<a href="#item60">규칙 60</a>).</li>
<li><p>예외 객체를 살펴보면 어떤 불변식을 위반했는지 알아낼 수도 있어야 한다(<a href="#item63">규칙 63</a>).</p>
<p><em>cf. 불변식을 강제하는 방법</em></p>
</li>
<li><p>불변식이 적용될 값 전부를 인자로 받는 setter를 정의하는 방법.</p>
</li>
<li>setter는 불변식이 만족하지 않으면 <em>IllegalArgumentException</em>을 던짐.</li>
<li><p>build()가 호출되기 전에 불변식을 깨뜨리는 인자가 전달되었다는 것을 신속하게 알 수 있는 장점.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setNameAndAge</span><span class="params">(String name, <span class="keyword">int</span> ate)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>(name == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>메서드마다 하나씩, 필요한 만큼 varargs 인자를 받을 수 있다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">names</span><span class="params">(String... names)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.names = names;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">foramily</span><span class="params">(String... names)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.farther = names[<span class="number">0</span>];</div><div class="line">      <span class="keyword">this</span>.marther = names[<span class="number">1</span>];</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>유연하다. (e.g. 객체가 만들어질 때마다 자동적으로 증가하는 일련번호 같은 것을 채울 수 있다)</p>
</li>
<li><p>인자가 설정된 빌더는 훌륭한 [Abstract Factory][dp-abstract-factory]다. JDK1.5 이상을 사용하는 경우, 제네릭 자료형 하나면 어떤 자료형의 객체를 만드는 빌더냐의 관계 없이 모든 빌더에 적용할 수 있다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">build</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">implements</span> <span class="title">Builder</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>e.g.</strong> <em>Code at package <code>java.util.stream</code></em></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stream.builder().add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>).build();</div></pre></td></tr></table></figure>
</li>
<li><p>빌더 객체를 인자로 받는 메서드는 보통 <em>한정적 와일드카드 자료형<sub>bounded wildcard type</sub></em>을 통해 인자의 자료형을 제한한다(<a href="#items28">규칙 28</a>).</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">Tree <span class="title">buildTree</span><span class="params">(Builder&lt;? extends Node&gt; nodeBuilder)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>자바가 제공하는 추상적 팩토리로는 Class 객체가 있으며, 이 객체의 <em>newInstance()</em> 가 build 메서드 구실을 한다.</p>
<p>  <strong>하지만,</strong> newInstance()는 항상 무인자 생성자를 호출하려 하는데, 문제는 그런 생성자가 없을 수도 있다는 것. TO-DO</p>
</li>
</ul>
<p><strong>문제점</strong></p>
<ul>
<li>빌더 객체를 만드는 오버헤드가 문제가 될 수 있다(성능이 중요한 상황). 그러니 인자 갯수가 통제할 수 없을 정도로 많아지만 빌더 패턴을 적용하자.</li>
</ul>
<h4 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h4><p>빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특시 대부분의 인자가 선택적 인자인 상황에 유용하다.</p>
<p><strong>cf.</strong> <em>Code with <a href="https://projectlombok.org/features/Builder.html" rel="external nofollow noopener noreferrer" target="_blank">Lombok</a></em> - 정적 팩터리 메서드로 구현</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Value</span> <span class="comment">// immutable(private, final 적용)</span></div><div class="line"><span class="meta">@Builder</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  String name;</div><div class="line">  <span class="keyword">int</span> age;</div><div class="line">  String mail;</div><div class="line">  String city;</div><div class="line">  String state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/02/10/creating-and-destroying-objects-1/#규칙-1-생성자-대신-static-factory-method-사용을-고려하자&quot;&gt;규칙 1&lt;/a&gt; - 생성자 대신 static factory method 사용을 고려하자&lt;br&gt;&lt;a href=&quot;../../../../2017/02/10/creating-and-destroying-objects-1/#규칙-2-생성자의-매개변수가-많을-때는-빌더-builder-를-고려하자&quot;&gt;규칙 2&lt;/a&gt; - 생성자의 매개변수가 많을 때는 빌더(builder)를 고려하자&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>Java Generic</title>
    <link href="https://wickso.me/2016/04/12/generic/"/>
    <id>https://wickso.me/2016/04/12/generic/</id>
    <published>2016-04-12T07:40:01.000Z</published>
    <updated>2017-05-03T07:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="제네릭-프로그래밍"><a href="#제네릭-프로그래밍" class="headerlink" title="제네릭 프로그래밍"></a>제네릭 프로그래밍</h2><hr>
<h2 id="generic-class-method"><a href="#generic-class-method" class="headerlink" title="generic class, method"></a>generic class, method</h2><pre><code>// class
public class Entry&lt;K, V&gt; {
    private K key;
    private V value;
    ...
}

Entry&lt;String, Integer&gt; entry = new Entry&lt;&gt;(...);

// method
public class Arrays {
    public &lt;T&gt; void swap(T[] array, int i, int j) {
        T tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
</code></pre><p>–</p>
<h3 id="generic-method"><a href="#generic-method" class="headerlink" title="generic method"></a>generic method</h3><pre><code>public static &lt;T&gt; void swap(T[] array, int i, int j)
</code></pre><ul>
<li>타입 파라미터를 제어자와 반환타입 사이에 둔다</li>
<li><p>호출할 때는 명시하지 않아도 가능</p>
<ul>
<li><p>컴파일러가 타입파라미터 추론</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Arrays.&lt;String&gt;swap(friends, 0, 1);</div></pre></td></tr></table></figure>
</li>
<li><p>원한다면 명시적으로 가능</p>
</li>
<li>문제 발생시 더 자세한 오류 메시지</li>
</ul>
</li>
</ul>
<p>–</p>
<h3 id="e-t"><a href="#E-T" class="headerlink" title="E? T? ??"></a>E? T? <code>?</code>?</h3><ul>
<li>E : Element</li>
<li>T : Type</li>
<li>V : Value</li>
<li>K : Key</li>
<li>? : 와일드 카드</li>
<li>…</li>
</ul>
<p>–</p>
<h3 id="기본-타입은-불가능"><a href="#기본-타입은-불가능" class="headerlink" title="기본 타입은 불가능"></a>기본 타입은 불가능</h3><pre><code>Entry&lt;String, int&gt; // 불가능
</code></pre><hr>
<h2 id="타입-경계"><a href="#타입-경계" class="headerlink" title="타입 경계"></a>타입 경계</h2><p>제네릭 클래스/메서드가 받는 타입 파라미터의 타입을 제한할 때</p>
<pre><code>public status &lt;T extends AutoCloseable&gt; void closeAll(ArrayList&lt;T&gt; elems) {
    for (T elem : elems) {
        elem.close();
    }
}
</code></pre><ul>
<li>다중 경계 지정</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">T extends Runable &amp; AutoCloseable</div></pre></td></tr></table></figure>
<p>–</p>
<h3 id="ltt-extends-autocloseablegt"><a href="#lt-T-extends-AutoCloseable-gt" class="headerlink" title="&lt;T extends AutoCloseable&gt;"></a>&lt;T extends AutoCloseable&gt;</h3><ul>
<li>요소타입이 AutoCloseable의 서브타입임을 보장한다.</li>
<li>extends == 서브타입, 상속 X<ul>
<li>기존에 사용하던 extends 키워드를 사용함</li>
</ul>
</li>
</ul>
<hr>
<h2 id="타입-가변성과-와일드카드"><a href="#타입-가변성과-와일드카드" class="headerlink" title="타입 가변성과 와일드카드"></a>타입 가변성과 와일드카드</h2><ul>
<li><p>Employee의 서브클래스 객체로 구성된 배열을 사용하고자 할 때,</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void process(Employee[] staff) &#123;...&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>이때, Manager[]이 Employee[]의 서브타입이라면 process()에 전달할 수 있다.</p>
<ul>
<li>이러한 동작을 공변성(covariance)라고 한다.</li>
<li>즉, 배열은 요소 타입과 같은 방식으로 변한다.</li>
</ul>
</li>
<li>자바에서는 와일드카드로 메서드의 파라미터와 반환 타입이 변하는 방식을 지정.<ul>
<li>이 메커니즘을 use-site variance(사용처 공변성)이라고 한다.</li>
</ul>
</li>
</ul>
<p>–</p>
<h3 id="covariance"><a href="#covariance" class="headerlink" title="covariance"></a>covariance</h3><pre><code>Manager[] bosses1 = new Manager[10];
Employee[] empls1 = bosses1; // 공변성
empls1[0] = new Manager(); // p.169
// 런타임에서 ArrayStoreException을 던질 때 잡을 수 파악
</code></pre><ul>
<li>자바의 모든 제네릭 타입은 불변(invariant)</li>
</ul>
<p>–</p>
<h3 id="but"><a href="#But" class="headerlink" title="But!"></a>But!</h3><pre><code>ArrayList&lt;Manager&gt; bosses2 = new ArrayList&lt;&gt;();
ArrayList&lt;Employee&gt; empls2 = bosses2; // error
</code></pre><ul>
<li>자바의 모든 제네릭 타입은 불변(invariant)</li>
<li>ArrayList<manager>은 ArrayList<employee>의 서브타입이 아니다.</employee></manager></li>
</ul>
<p>–</p>
<h3 id="서브타입-와일드카드"><a href="#서브타입-와일드카드" class="headerlink" title="서브타입 와일드카드"></a>서브타입 와일드카드</h3><ul>
<li><p>&lt;? extends Employee&gt;</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public statis void pringNames(ArrayList&lt;? extends Employee&gt; staff) &#123;</div><div class="line">  for(Employee e : staff) &#123;</div><div class="line">    System.out.println(e.getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>?는 Employee의 서브타입</p>
</li>
</ul>
<p>–</p>
<h4 id="but"><a href="#But-1" class="headerlink" title="But!!"></a>But!!</h4><pre><code>Employee e = staff.get(0); // 가능
staff.add(new Manager(&quot;yj&quot;)); // 불가능, 컴파일 에러
</code></pre><ul>
<li>?는 어떤 서브클래스든 가르킬 수 있으므로 컴파일 오류</li>
<li><p>즉, ? extends Employee는</p>
<ul>
<li>Employee로 변환할 수 있지만</li>
<li><p>어떤 것도 절대 ? extends Employee로 변환할 수 없다.</p>
<p><img src="doc/images/java-generic-01.png"></p>
</li>
</ul>
</li>
<li><p>ArrayList&lt;? extends Employee&gt;에서 읽을 수는 있지만 쓸 수는 없다.</p>
</li>
</ul>
<p>–</p>
<h3 id="슈퍼타입-와일드카드"><a href="#슈퍼타입-와일드카드" class="headerlink" title="슈퍼타입 와일드카드"></a>슈퍼타입 와일드카드</h3><ul>
<li><p>? super Employee</p>
<ul>
<li><p>함수형 객체의 파라미터로 유용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface Pridicate&lt;T&gt; &#123;</div><div class="line">  boolean test(T arg);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>p.247 다시 볼것</p>
</li>
<li><a href="http://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java" rel="external nofollow noopener noreferrer" target="_blank">super vs extends</a></li>
</ul>
</li>
</ul>
<p>–</p>
<h3 id="슈퍼타입-와일드카드-2"><a href="#슈퍼타입-와일드카드-2" class="headerlink" title="슈퍼타입 와일드카드 2"></a>슈퍼타입 와일드카드 2</h3><p>PECS(Producer Extends Consumer Super)<br>와일드카드와 관련해 PECS라는 약칭을 사용하기도 한다. 생산자에는 extends, 소비자에는 super를 사용한다는 의미이다.</p>
<pre><code>public void pushAll(Iterable&lt;? extends E&gt; src) {
    for (E e : src) {
        push(e);
    }
}

public void popAll(Collection&lt;? super E&gt; dst) {
    while(!isEmpty()) {
        dst.add(pop());
    }
}
</code></pre><p>예를 들어, Stack의 경우에 pushAll()의 src는 Stack에서 사용될 E 인스턴스를 생산하므로 extends, popAll()의 dst는 Stack으로부터 E 인스턴스를 소비하므로 super가 적합하다. <small>(이펙티브자바 항목 28)</small></p>
<p>–</p>
<h3 id="타입-변수와-함께-사용하는-와일드카드"><a href="#타입-변수와-함께-사용하는-와일드카드" class="headerlink" title="타입 변수와 함께 사용하는 와일드카드"></a>타입 변수와 함께 사용하는 와일드카드</h3><ul>
<li>p.249 공부할 곳</li>
</ul>
<p>–</p>
<h3 id="경계-없는-와일드카드"><a href="#경계-없는-와일드카드" class="headerlink" title="경계 없는 와일드카드"></a>경계 없는 와일드카드</h3><pre><code>public static boolean hasNulls(ArrayList&lt;?&gt; elems) {
    for(Object e : elems) {
        if (e == null) return true;
    }
    return false;
}
</code></pre><ul>
<li>파라미터(ArrayList)의 타입 파라미터(?)가 중요하지 않을 때 제네릭 메서드보다 ArrayList&lt;?&gt;를 사용하는 것이 타당</li>
</ul>
<p>–</p>
<h3 id="와일드카드-캡처"><a href="#와일드카드-캡처" class="headerlink" title="와일드카드 캡처"></a>와일드카드 캡처</h3><pre><code>public static void swap(ArrayList&lt;?&gt; elems, int i, int j) {
    ? temp = elems.get(i);
    elems.set(i, elems.get(j));
    elems.set(j, temp);
}
</code></pre><ul>
<li>?을 타입으로 사용할 수 없다.</li>
</ul>
<p>–</p>
<h4 id="정상적인-코드"><a href="#정상적인-코드" class="headerlink" title="정상적인 코드"></a>정상적인 코드</h4><pre><code>public static void swap(ArrayList&lt;?&gt; elems, int i, int j) {
    swapHelper(elems, i, j);
}

private static &lt;T&gt; void swapHelper(ArrayList&lt;T&gt; elems, int i, int j) {
    T temp = elems.get(i);
    elems.set(i, elems.get(j));
    elems.set(j, temp);
}
</code></pre><p>–</p>
<h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><ul>
<li>와일드카드 캡처라는 규칙 덕분에 가능</li>
<li>컴파일러는 ?를 모르지만, ?는 어떤 타입을 나타내므로 제네릭 메서드를 호출해도 된다.</li>
<li>swapHelper 메서드의 타입파라미터 T는 와일드카드 타입을 <strong>캡처</strong>한다.</li>
<li>API 사용자가 T보다 ?를 이해하는것이 쉽다.</li>
</ul>
<hr>
<h2 id="자바-가상-머신에서의-제네릭"><a href="#자바-가상-머신에서의-제네릭" class="headerlink" title="자바 가상 머신에서의 제네릭"></a>자바 가상 머신에서의 제네릭</h2><ul>
<li>제네릭이 없던 시절에는 Object 타입으로 받았다.</li>
<li>이후 설계자들은 VM에서 타입을 지우는 구현 방식으로 기존 버전 클래스와 호환되게 했다.</li>
<li>그리고 점진적으로 제네릭으로 옮겨갔다.</li>
</ul>
<p>–</p>
<h3 id="1-타입소거"><a href="#1-타입소거" class="headerlink" title="1. 타입소거"></a>1. 타입소거</h3><p>제네릭을 정의하면 해당 타입은 raw 타입으로 컴파일된다.</p>
<pre><code>public class Entry {
    private Object key;
    private Object value;

    public Entry(Object key, Object value) {
        this.key = key;
        this.value = value;
    }
    ...
}
</code></pre><p>–</p>
<h4 id="경계가-있는-타입변수의-경우"><a href="#경계가-있는-타입변수의-경우" class="headerlink" title="경계가 있는 타입변수의 경우"></a>경계가 있는 타입변수의 경우</h4><p>첫 번째 경계로 교체된다.</p>
<pre><code>public class Entry&lt;K extends Comparable&lt;? super K&gt; &amp; Serializable,
                   V extends Serializable&gt;
</code></pre><p>다음과 같이 교체</p>
<pre><code>public class Entry{
    private Comparable key;
    private Serializable value;
    ...
</code></pre><p>–</p>
<h3 id="2-타입-변환-연산자-삽입"><a href="#2-타입-변환-연산자-삽입" class="headerlink" title="2. 타입 변환 연산자 삽입"></a>2. 타입 변환 연산자 삽입</h3><ul>
<li>Entry<string, integer="">의 객체로 생성할 경우 반드시 String, Integer가 전달되야 한다.<ul>
<li>그렇지 않으면 컴파일 X</li>
<li>즉, getKey()는 String을 반환한다는 것을 보장받는다.(컴파일이 안되므로)</li>
</ul>
</string,></li>
</ul>
<p>–</p>
<h3 id="21-타입-변환-연산자-삽입"><a href="#2-1-타입-변환-연산자-삽입" class="headerlink" title="2.1 타입 변환 연산자 삽입"></a>2.1 타입 변환 연산자 삽입</h3><ul>
<li><p>타입 연산자(T), 제네릭, raw(Object)를 사용하여 컴파일된 경우(비검사 경고옵션으로)</p>
<ul>
<li>다른 값이 들어갈 수 있다.</li>
<li><p>따라서 실행 시간에 안전성 검사를 해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Entry&lt;String, Integer&gt; entry = ...</div><div class="line">String key = entry.getKey();</div></pre></td></tr></table></figure>
</li>
<li><p>타입이 소거된 getKey()는 Object를 반환하므로 컴파일러는 다음과 같은 코드를 만들어낸다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String key = (String) entry.getKey();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>–</p>
<h3 id="3-bridge-method"><a href="#3-bridge-method" class="headerlink" title="3. bridge method"></a>3. bridge method</h3><ul>
<li>메서드 파라미터와 반환 타입을 소거할 때 때때로 컴파일러가 브릿지 메서드를 만들어내야 한다.</li>
<li>컴파일러가 raw로 만들었기 때문에 bridge method 생성</li>
</ul>
<p>–</p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><pre><code>public class WordList extends ArrayList&lt;String&gt; {
    public void add(String e) {
        return isBadWord(e) ? false : super.add(e);
    }
    ...
}
...
WordList words = ...
ArrayList&lt;String&gt; strs = words;
strs.add(&quot;JAVA&quot;);
</code></pre><ul>
<li>strs.add()에서 타입소거된 ArrayList의 add(Object)를 호출한다.</li>
<li>WordList 객체의 add를 호춣하면 동적 메서드 조회가 일어나고, ArrayList가 아닌 WordList의 add가 호출될 것을 예상할 수 있다.</li>
</ul>
<p>–</p>
<h4 id="example"><a href="#example-1" class="headerlink" title="example"></a>example</h4><ul>
<li>컴파일러는 예상대로 동작하게 하려고 WordList 안에 bridge method를 만든다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class WordList extends ArrayList&lt;String&gt; &#123;</div><div class="line">  public void add(String e) &#123;</div><div class="line">    return isBasWord(e) ? false : super.add(e);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // bridge method</div><div class="line">  public void add(Object e) &#123;</div><div class="line">    add((String) e);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>add(Object)가 호출되고 WordList의 add(String)가 호출된다.</li>
</ul>
<p>–</p>
<h4 id="bridge-method"><a href="#bridge-method" class="headerlink" title="bridge method"></a>bridge method</h4><ul>
<li>컴파일러는 동적 메서드 조회가 일어나게 하려고 브릿지 메서드를 만들어낸다.</li>
<li>자바에서는 이러한 메서드 쌍을 구현할 수 없다.(?)<ul>
<li>파라미터 타입이 다르면 오버로딩으로 가능한데 why?</li>
<li>String get(int), Object get(int)의 형태로도 bridge method 생성!</li>
</ul>
</li>
<li>가상 머신에서는 메서드를 이름, 파라미터 타입, 반환 타입으로 명시하므로 컴파일러가 이 메서드 쌍을 만들어낼 수 있다.</li>
</ul>
<p>–</p>
<h4 id="note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><ul>
<li>제네릭 외에 공변 반환 타입(covariant return type)을 구현하는데도 이용</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Employee implements Cloneable &#123;</div><div class="line">  public Employee clone() throws CloneNotSupportedException &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Employee clone()</div><div class="line">Object clone() // bridge method</div></pre></td></tr></table></figure>
<hr>
<h2 id="제네릭의-제약"><a href="#제네릭의-제약" class="headerlink" title="제네릭의 제약"></a>제네릭의 제약</h2><ul>
<li>기본 타입 인자가 없다</li>
<li>실행 시간에는 모든 타입이 raw 형태다</li>
<li>타입 변수의 인스턴스를 만들 수 없다</li>
<li>파라미터화된 타입의 배열을 생성할 수 없다</li>
<li>정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다</li>
<li>메서드가 소거 후 충동하지 않을 수도 있다</li>
<li>예외와 제네릭</li>
</ul>
<h3 id="실행-시간에는-모든-타입이-raw-형태다"><a href="#실행-시간에는-모든-타입이-raw-형태다" class="headerlink" title="실행 시간에는 모든 타입이 raw 형태다"></a>실행 시간에는 모든 타입이 raw 형태다</h3><p>VM에는 오직 raw type만 있다. 그래서 실행시간에 ArrayList가 String 객체를 담고 있는지 알아낼 수 없다.</p>
<p><img src="doc/images/java-generic-02.png"></p>
<p>이와 같은 조건은 절대로 검사할 수 없으므로 compile-time error를 일으킨다</p>
<p>–</p>
<h3 id="실행-시간에는-모든-타입이-raw-형태다"><a href="#실행-시간에는-모든-타입이-raw-형태다-1" class="headerlink" title="실행 시간에는 모든 타입이 raw 형태다"></a>실행 시간에는 모든 타입이 raw 형태다</h3><p>아래 코드는 비효율적이지만 합법적인 방법이다. obj가 ArrayList인지만 검사한다.</p>
<pre><code>Object obj = ...;
ArrayList&lt;String&gt; list = (ArrayList&lt;String&gt;) obj;
</code></pre><p>경고창을 사라지게 하려면 변수앞에 어노테이션을 붙여야 한다.</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;) ArrayList&lt;String&gt; list = (ArrayList&lt;String&gt;) obj;
</code></pre><p>–</p>
<h3 id="but"><a href="#but" class="headerlink" title="but!"></a>but!</h3><p><strong>caution</strong></p>
<p>@SuppressWarnings 어노테이션을 잘못 사용하면 heap pollution으로 이어질 수 있다. heap pollution이란 객체가 특정 제네릭 타입 인스턴스에 속해야 하지만 실제로는 다른 인스턴스에 속하는 현상을 말한다. ArrayList<string>에 ArrayList<integer>을 할당할 수 있지만, 부적합한 타입 요소를 추출하면 당연히 ClassCastException이 일어난다.</integer></string></p>
<p><img src="doc/images/java-generic-03.png"></p>
<p>–</p>
<h3 id="but"><a href="#but-1" class="headerlink" title="but!"></a>but!</h3><p><strong>tip</strong></p>
<p>힙 펄루션의 문제점은 보고된 실행 시간 오류가 문제의 원인(부적합한 요소의 삽입)과 상당히 다르다는 점이다(문제의 원인은 인스턴스에 다른 값을 넣은 것인데 ClassCate가 발생하는 점). 이런 문제를 디버그하려면 checked view를 사용해야 한다.</p>
<pre><code>List&lt;String&gt; strings =
    Collections.checkedList(new ArrayList&lt;&gt;, String.class);
</code></pre><p>이 검사 뷰는 해당 리스트에 삽입하는 동작을 모두 검사해서 부적합한 타입 객체를 추가하는 순간 예외를 던진다.</p>
<p>–</p>
<h3 id="실행-시간에는-모든-타입이-raw-형태다"><a href="#실행-시간에는-모든-타입이-raw-형태다-2" class="headerlink" title="실행 시간에는 모든 타입이 raw 형태다"></a>실행 시간에는 모든 타입이 raw 형태다</h3><p>getClass 메서드는 항상 raw 타입을 반환한다.</p>
<pre><code>ArrayList&lt;String&gt; list = ...;
list.getClass(); // ArrayList.class
ArrayList&lt;String&gt;/classl // 없는 클래스이므로 문법오류 발생
</code></pre><p>–</p>
<h3 id="타입-변수의-인스턴스를-만들-수-없다"><a href="#타입-변수의-인스턴스를-만들-수-없다" class="headerlink" title="타입 변수의 인스턴스를 만들 수 없다."></a>타입 변수의 인스턴스를 만들 수 없다.</h3><p>해결하려면 호출하는 쪽에서 배열 생성자를 메서드 참조로 제공하게 해야 한다.</p>
<pre><code>// obj가 n개 들어간 배열을 만든다고 가정할때
String[] arr = Arrays.repeat(10, &quot;hi&quot;, String[]::new);
public static &lt;T&gt; T[] repeat(int i, T obj, IntFunction&lt;T[]&gt; constr) {
    T[] result = constr.apply(n);
    for (int i=0; i &lt; n; i++) result[i] = obj;
    return result;
}

String[] arr = Arrays.repeat(10, &quot;hi&quot;, String.class); // 리플렉션
public static &lt;T&gt; T[] repeat(int n, T obj, Class&lt;T&gt; cl) {
    @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) java.lang.reflect.Array.newInstance(cl, n);
    for (int i=0; i &lt; n; i++) result[i] = obj;
    return result;
}
</code></pre><p>–</p>
<h3 id="타입-변수의-인스턴스를-만들-수-없다"><a href="#타입-변수의-인스턴스를-만들-수-없다-1" class="headerlink" title="타입 변수의 인스턴스를 만들 수 없다."></a>타입 변수의 인스턴스를 만들 수 없다.</h3><p>또 다른 방법으로 호출하는 쪽에서 배열을 할당하게 하는 방법</p>
<pre><code>String[] arr = Arrays.repeat(10, &quot;hi&quot;, new String[5]);
public static &lt;T&gt; T[] repeat(int i, T obj, T[] array) {
    T[] result;
    if(array.length &gt;= n) {
        result = array;
    } else {
        @SuppressWarnings(&quot;unchecked&quot;) T[] newArray = (T[]) java.lang.reflect.Array.newInstance(
                array.getClass().getComponenetType(), n);
        result = newArray;
    }
    for (int i=0; i &lt; n; i++) result[i] = obj;
    return result;
}
</code></pre><p>–</p>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><p>타입 변수를 이용하여 ArrayList는 생성가능하니, 마땅히 배열을 사용해야하는 이유가 없다면 ArrayList방법을 권장한다.</p>
<pre><code>public static &lt;T&gt; ArrayList&lt;T&gt; repeat(int n, T obj) {
    ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;();
    for(int i = 0; i &lt; n; i++) result.add(obj);
    return result;
}
</code></pre><p>–</p>
<h3 id="파라미터화된-타입의-배열을-생성할-수-없다"><a href="#파라미터화된-타입의-배열을-생성할-수-없다" class="headerlink" title="파라미터화된 타입의 배열을 생성할 수 없다."></a>파라미터화된 타입의 배열을 생성할 수 없다.</h3><pre><code>// 오류 - 제네릭 컴포넌트 타입으로 구성된 배열은 생성할 수 없다.
Entry&lt;String, Integer&gt;[] entries = new Entry&lt;String, Integer&gt;[100];
// 해결방안
@SuppressWarnings(&quot;unchecked&quot;) Entry&lt;String, Integer&gt;[] entries
    = (Entry&lt;String, Integer&gt;[]) new Entry&lt;?, ?&gt;[100];

// 더 나은 방안 - ArrayList 사용
ArrayList&lt;Entry&lt;String, Integer&gt;&gt; entries = new ArrayList&lt;&gt;(100);
</code></pre><p>–</p>
<h3 id="파라미터화된-타입의-배열을-생성할-수-없다"><a href="#파라미터화된-타입의-배열을-생성할-수-없다-1" class="headerlink" title="파라미터화된 타입의 배열을 생성할 수 없다."></a>파라미터화된 타입의 배열을 생성할 수 없다.</h3><pre><code>public static &lt;T&gt; ArrayList&lt;T&gt; asList(T... elements) {
    ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;();
    for(T e : elements) {
        result.add(e);
    }
    return result;
}
...
Entry&lt;String, Integer&gt; e1 = ...;
Entry&lt;String, Integer&gt; e2 = ...;
ArrayList&lt;Entry&lt;String, Integer&gt;&gt; entries = Lists.asList(e1, e2); // 컴파일러가 경고, 오류X

@SafeVarargs public static &lt;T&gt; ArrayList&lt;T&gt; asList(T... elements) {
    ...
</code></pre><p>–</p>
<h3 id="정적-컨텍스트에서는-클래스-타입-변수가-유효하지-않다"><a href="#정적-컨텍스트에서는-클래스-타입-변수가-유효하지-않다" class="headerlink" title="정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다."></a>정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다.</h3><pre><code>public class Entry&lt;K, V&gt; {
    private static V defaultValue; // 오류
    public static void setDefault(V value) { ... } // 오류
    ...
}

타입 소거는 소거된 Entry 클래스에 이런 종류의 변수나 메서드가 K와 V별로 있는 것이 아니라 오직 한 개만 있다는 것을 알 수 있다.
== 타입 소거가 되면 Entry 클래스에는 Object로 모두 바뀌어서 구분할 수 없이 Object 한 개만 있다는 것이다?
</code></pre><p>–</p>
<h3 id="메서드가-소거-후-충돌하지-않을-수도-있다"><a href="#메서드가-소거-후-충돌하지-않을-수도-있다" class="headerlink" title="메서드가 소거 후 충돌하지 않을 수도 있다."></a>메서드가 소거 후 충돌하지 않을 수도 있다.</h3><p>타입 소거 후 충돌을 일으킬 수 있는 메서드는 선언하지 않아야 한다. 다음 코드는 타입 소거후 Object의 equals과 충돌한다.</p>
<pre><code>public interface Ordered&lt;T&gt; extends Comparable&lt;T&gt; {
    public default boolean equals(T value) {
        return compareTo(value) == 0;
    }
    ...
}
</code></pre><p>–</p>
<h3 id="메서드가-소거-후-충돌하지-않을-수도-있다-2"><a href="#메서드가-소거-후-충돌하지-않을-수도-있다-2" class="headerlink" title="메서드가 소거 후 충돌하지 않을 수도 있다. 2"></a>메서드가 소거 후 충돌하지 않을 수도 있다. 2</h3><p>충돌의 원인이 미묘할 때</p>
<pre><code>public class Employee implements Comparable&lt;Employee&gt; {
    ...
    public int compareTo(Employee other) {
        return name.compareTo(other.name);
    }
}
public class Manager extends Employee implements Comparable&lt;Manager&gt; {
    // 오류 - 두 Comparable 인스턴스를 슈퍼타입으로 둘 수 없다.
    ...
    public int compareTo(Manager other) {
        return Double.compare(salary, other.salary);
    }
}
</code></pre><p>여기서는 소거가 일어나지 않는다. 두 compareTo의 브릿지 메서드가 충돌한다.<br>// ?. 제목이랑 내용이랑 무슨 말인지..?</p>
<p>–</p>
<h3 id="예외와-제네릭"><a href="#예외와-제네릭" class="headerlink" title="예외와 제네릭"></a>예외와 제네릭</h3><p>제네릭 클래스의 객체는 예외로 던지거나 잡아낼 수 없다. Throwable의 제네릭 서브클래스조차 만들 수 없다.</p>
<pre><code>public class Problem&lt;T&gt; extends Exception {
    // 제네릭 틀래스는 Throwable의 서브타입이 될 수 없다.
}
</code></pre><p>catch 절에서도 타입 변수를 사용할 수 없다.</p>
<pre><code>...
try {
    r.run();
} catch(T ex) {
    Logger.get....
}
</code></pre><p>–</p>
<h3 id="but"><a href="#but-2" class="headerlink" title="but"></a>but</h3><p>throws 선언에는 타입 변수를 사용할 수 있다.</p>
<pre><code>public static &lt;V, T extends Throwable&gt; V doWork(Callable&lt;V&gt; c, T ex) throws T {
    try {
        return c.call();
    } catch (Throwable realEx) {
        ex.initCause(realEx);
        throw ex;
    }
}
</code></pre><hr>
<h2 id="리플렉션과-제네릭"><a href="#리플렉션과-제네릭" class="headerlink" title="리플렉션과 제네릭"></a>리플렉션과 제네릭</h2><p>–</p>
<h3 id="class-클래스"><a href="#Class-클래스" class="headerlink" title="Class 클래스"></a>Class<t> 클래스</t></h3><p><strong>Class 클래스는 Class 객체가 기술하는 클래스를 타입 파라미터로 받는다.</strong></p>
<p>String.class 는 타입이 Class<string>이다. 그러므로, Class<string>의 newInstance 메서드는 String을 반환한다.<br>이 정보 덕분에 타입 변환 연산자를 사용하지 않아도된다.</string></string></p>
<p>–</p>
<h3 id="가상-머신에서-제네릭-타입-정보"><a href="#가상-머신에서-제네릭-타입-정보" class="headerlink" title="가상 머신에서 제네릭 타입 정보"></a>가상 머신에서 제네릭 타입 정보</h3><p><strong>제네릭 클래스와 제네릭 메서드의 선언부가 지워지지 않으므로 리플렉션으로 접근할 수 있다.</strong></p>
<p>–</p>
<h3 id="가상-머신에서-제네릭-타입-정보-2"><a href="#가상-머신에서-제네릭-타입-정보-2" class="headerlink" title="가상 머신에서 제네릭 타입 정보 2"></a>가상 머신에서 제네릭 타입 정보 2</h3><p>java.lang.reflect 패키지의 Type 인터페이스는 제네릭 타입 선언을 나타낸다. Type 인터페이스의 서브타입은 다음과 같다.</p>
<ol>
<li>구체적인 타입을 기술하는 Class 클래스</li>
<li>(T extends Comparable&lt;? super T&gt; 같은) 타입 변수를 나타내는 TypeVariable 인터페이스</li>
<li>(? super T 같은) 와일드카드를 나타내는 WildcardType 인터페이스</li>
<li>(Comparable&lt;? super T&gt; 같은) 제네릭 클래스나 인터페이스를 나타내는 ParameterizedType 인터페이스</li>
<li>(T[] 같은) 제네릭 배열을 나타내는 GenericArrayType 인터페이스</li>
</ol>
<p>–</p>
<h3 id="가상-머신에서-제네릭-타입-정보-3"><a href="#가상-머신에서-제네릭-타입-정보-3" class="headerlink" title="가상 머신에서 제네릭 타입 정보 3"></a>가상 머신에서 제네릭 타입 정보 3</h3><p>Class, Method, Constructor 객체가 제네릭 선언에서 나온 것인지 알아내려면 getTypeParameters 메서드를 호출한다. 반환값으로 TypeVariable 인스턴스 배열을 얻으며 각 요소는 선언부에 있는 타입 변수를 나타낸다. 길이가 0이라면 제네릭 선언이 아니다.</p>
<pre><code>Method m = Collections.class.getMethod(&quot;sort&quot;, List.class);
TypeVariable&lt;Method&gt;[] vars = m.getTypeParameters();
String name = vars[0].getName();
System.out.println(name); // &quot;T&quot;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;제네릭-프로그래밍&quot;&gt;&lt;a href=&quot;#제네릭-프로그래밍&quot; c
    
    </summary>
    
      <category term="slide" scheme="https://wickso.me/categories/slide/"/>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring study 01</title>
    <link href="https://wickso.me/2016/04/07/spring-01/"/>
    <id>https://wickso.me/2016/04/07/spring-01/</id>
    <published>2016-04-06T17:32:16.000Z</published>
    <updated>2017-05-03T07:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center><br>    <h2 style="text-align: center;" id="spring-in-action">Spring in Action</h2><br>    <strong>chapter 1</strong><br><br>    스프링 속으로<br></center><br><br><br><div style="text-align: right;"><br>    <p><strong>@date</strong>    2016.04.07</p><br></div><br><br>—<br><br>## readme<br><br>Spring in Action 으로 공부하면서 어려웠던 부분, 기억해야 할 것같은 부분 위주로 정리한 ppt이다. 상단 제목의 번호는 필요할 때 책을 참고하고자 동일하게 적어두었다.<br><br>—<br><br>## 1.1 자바 개발 간소화<br><br>자바 복잡도 간소화를 지원하기 위한 주요 전략<br><br>1. POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive)인 개발<sup><em></em></sup><br>2. DI와 인터페이스 지향(interface orientation)을 통한 느슨한 결합도(loose coupling)<br>3. 애스펙트와 공통 규약을 통한 선언적(declarative) 프로그래밍<br>4. 애스팩트와 템플릿(template)을 통한 반복적인 코드 제거<br><br><small>비침투적 개발이란, 바탕이 되는 기술을 사용하는 클래스, 인터페이스, API 등을 코드에 직접 나타내지 않는 방법으로 복잡함을 분리할 수 있다.</small><br><br>–<br><br>## 1.1.2 종속객체 주입<br><br>- <strong>종속객체 주입(DI, Dependency Injection)</strong><br>- 객체는 종속객체를 생성하거나 얻지 않는다. 즉, 종속객체는 종속객체가 필요한 객체에 주입된다.<br><br>–<br><br>### 1.1.2-1<br><strong>생성자 주입(constructor injection)</strong><br><br>    public class BraveKnight implements Knight {<br>        private Quest quest;<br>        public BraveKnight(Quest quest) { // Quest 주입<br>            this.quest = quest;<br>        }<br>        public void embarkOnQuest() {<br>            quest.embark();<br>        }<br>    }<br><br>–<br><br>### 1.1.2-2<br>BraveNight 테스트<br><br>    public class BraveKnightTest {<br>        @Test<br>        public void knightShouldEmbarkOnQuest() {<br>            Quest mockQuest = mock(Quest.class); // 모의 Quest 생성<br>            BraveKnight knight = new BraveKnight(mockQuest); // 모의 Quest 주입<br>            knight.embarkOnQuest();<br>            verify(mockQuest, time(1)).embark();<br>        }<br>    }<br><br>강한 결합으로 생성자 안에서 quest를 생성할 때는 테스트가 불가능 했지만 DI를 이용하고 테스트가 가능하다. embarkOnQuest()를 호출한 후에 Mockito에게 Quest의 embark()가 정확히 한 번 호출됐는지 확인한다.<br><br>–<br><br>### 1.1.2-3<br><br>    public class SlayDragonQuest implements Quest {<br>        private PrintStream stream;<br>        public SlayDragonQuest(PrintStream stream) {<br>            this.stream = stream;<br>        }<br>        public void embark() {<br>            stream.println(“Embarking on quest to slay the dragon!”);<br>        }<br>    }<br><br>위와 같은 클래스가 있을 때, 어떻게 BraveKnight에게 SlayDragonQuest를 줄 수 있는가? 그리고 어떻게 SlayDragonQuest에게 PrintStrean을 줄 수 있는가?<br><br>–<br><br>### 1.1.2-4<br><strong>와이어링(wiring)</strong>: 애플리케이션 컴포넌트 간의 관계를 정의하는 것(xml or java를 이용한 방법)<br><br>xml<br><br>    &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>    <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd"><br>        <bean id="knight" class="com.test.knights.BraveKnight"><br>            <constructor-arg ref="quest"> <!-- 빈 주입 --><br>        </constructor-arg></bean><br><br>        <bean id="quest" class="com.test.knights.SlayDragonQuest"> <!-- SlayDragonQuest 생성 --><br>            <constructor-arg value="#{T(System).out}"><br>        </constructor-arg></bean><br>    </beans><br><br>–<br><br>### 1.1.2-5<br>java<br><br>    @Configuration<br>    public class KnightConfig {<br>        @Bean<br>        public Knight knight() {<br>            return new BraveKnight(quest());<br>        }<br><br>        @Bean<br>        public Quest quest() {<br>            return new SlayDragonQuest(System.out);<br>        }<br>    }<br><br>–<br><br>### 1.1.2-6<br><strong>실행해 보기</strong><br><br><strong>application context</strong>은 빈에 관한 정의들을 바탕으로 빈들을 엮어 준다. 스프링 애플리케이션 컨텍스트는 애플리케이션을 구성하는 객체의 생성과 와이어링을 전적으로 책임진다.<br><br>xml: ClassPathXmlApplicationContext()<br><br>java: AnnotationConfigApplicationContext()<br><br>    public static void main(String[] args) {<br>        ClassPathXmlApplicationContext context = // 스프링 컨텍스트 로드<br>            new ClassPathXmlApplicationContext(<br>                    “META-INF/spring/knights.xml”);<br>        Knight k = context.getBean(Knight.class); // 빈 얻기<br>        k.embarkOnQuest(); // 사용<br>        context.close();<br>    }<br><br>–<br><br>## 1.1.3 애스펙트 적용<br>AOP(Aspect-Oriented Programming)은 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용할 수 있는 컴포넌트에 담는다. 즉, 소프트웨어 내부의 관심사들을 서로 분리하는 기술이다. 예를 들어 로깅, 트랜잭션 관리, 보안 등의 시스템 서비스(이렇게 여러 컴포넌트에 관련되는 것을 <em>*횡단 관심사(cross-cutting concerns)</em>라고 한다. 이러한 관심사가 각각의 컴포넌트에 퍼지게 되면 다음과 같은 문제점이 있다.<br><br>1. 관심사를 구현하는 코드가 시스템 전반에 중복되어 걸쳐있어, 변경해야하는 경우 모두 변경해야 한다.<br>2. 컴포넌트의 코드가 본연의 기능과 관련 없응 코드로 지저분해진다.<br><br>–<br><br>### 1.1.3-1<br>AOP를 이용하면 응집도가 높고 본연의 관심사에 집중하는 컴포넌트를 만든다. 즉, 애스펙트는 확실히 POJO를 단순화한다.<br><center><br><img src="http://www.geekmantra.com/staticcontent/contentimages/Spring-Aspect-Oriented1.gif" alt="aspect-exam"><br></center>

<p>–</p>
<h3 id="113-2"><a href="#1-1-3-2" class="headerlink" title="1.1.3-2"></a>1.1.3-2</h3><p>ex) 기사가 원정전,후에 노래가 울려야 할 경우</p>
<pre><code>public class BraveKnight implements Knight {
    ...
    public void embarkOuest() {
        sing.beforeQuest(); // 기사가 이것까지 관리해야할까?
        quest.embark();
        sing.afterQuest();
    }
}
</code></pre><p>–</p>
<h3 id="113-3"><a href="#1-1-3-3" class="headerlink" title="1.1.3-3"></a>1.1.3-3</h3><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    ...&gt;
    &lt;bean id=&quot;sing&quot; class=&quot;com.test.Sing&quot;&gt;
        ...
    &lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;aop:aspect ref=&quot;sing&quot;&gt;
            &lt;aop:pointcut id=&quot;embark&quot;
                expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt; &lt;!-- 포인트커트 정의 --&gt;
            &lt;aop:before pointcut-ref=&quot;embark&quot;
                method=&quot;beforeQuest&quot;/&gt;
            &lt;aop:after pointcut-ref=&quot;embark&quot;
                method=&quot;afterQuest&quot;/&gt;
        &lt;/sop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/bean&gt;
</code></pre><hr>
<h2 id="12-빈은-담는-그릇-컨테이너"><a href="#1-2-빈은-담는-그릇-컨테이너" class="headerlink" title="1.2 빈은 담는 그릇, 컨테이너"></a>1.2 빈은 담는 그릇, 컨테이너</h2><p>스프링 기반 애플리케이션은 spring container 안에서 객체가 태어나고, 자라고, 소멸한다. 그래서 spring container는 객체를 생성하고, 엮어주고, 이들의 전체 생명주기를 관리한다.</p>
<p>–</p>
<h3 id="12-1"><a href="#1-2-1" class="headerlink" title="1.2-1"></a>1.2-1</h3><p>스프링에는 여러 컨테이너 구현체가 존재하며, 이들은 크게 두 가지로 분류된다.</p>
<ol>
<li>빈 팩토리(org.springframework.beans.factory.BeanFactory)<ul>
<li>인터페이스에 의해 정의</li>
<li>DI에 대한 기본적인 지원을 제공하는 가장 단순한 컨테이너</li>
</ul>
</li>
<li>애플리케이션 컨텍스트(org.springframework.context.ApplicationContext)<ul>
<li>인터페이스에 의해 정의</li>
<li>빈 팩토리를 확장해 애플리케이션 프레임워크 서비스를 제공하는 컨테이너</li>
</ul>
</li>
</ol>
<p>–</p>
<h3 id="121-애플리케이션-컨텍스트"><a href="#1-2-1-애플리케이션-컨텍스트" class="headerlink" title="1.2.1 애플리케이션 컨텍스트"></a>1.2.1 애플리케이션 컨텍스트</h3><p>애플리케이션의 설정을 제공하기 위한 중앙 인터페이스로, 실행중일땐 읽기만 가능하지만, 실행이 지원되면 리로드될 수 있다.</p>
<ul>
<li>AnnotationConfigApplicationContext<br>  <small>하나 이상의 자바 기반 설정 클래스에서 스코프 애플리케이션 컨텍스트를 로드</small></li>
<li>AnnotationConfigWebApplicationContext<br>  <small>하나 이상의 자바 기반 설정 클래스에서 스프링 웹 애플리케이션 컨텍스트를 로드</small></li>
<li>ClassPathXmlApplicationContext<br>  <small>클래스패스에 위치한 xml 파일에서 컨텍스트 정의 내용을 로드</small></li>
<li>FileSystemXmlApplicationContext<br>  <small>파일 경로로 지정된 xml 파일에서 컨텍스트 정의 내용 로드</small></li>
<li>XmlWebApplicationContext<br>  <small>웹 어플리케이션에 포함된 xml 파일에서 컨텍스트 정의 내용 로드</small></li>
</ul>
<p>–</p>
<h3 id="122-빈의-생명주기"><a href="#1-2-2-빈의-생명주기" class="headerlink" title="1.2.2 빈의 생명주기"></a>1.2.2 빈의 생명주기</h3><center><img src="https://premaseem.files.wordpress.com/2013/02/spring-bean-lifecycle.png" style="border:0px; width:60%; height:60%"></center>

<p>–</p>
<h3 id="122-1-life-cycle"><a href="#1-2-2-1-life-cycle" class="headerlink" title="1.2.2-1 life-cycle"></a>1.2.2-1 life-cycle</h3><ol>
<li>스프링이 빈 인스턴스화</li>
<li>스프링이 값과 빈의 레퍼런스를 빈의 프로퍼티에 주입</li>
<li>빈이 BeanNameAware를 구현하면 스프링이 빈의 ID를 setBEanName()에 넘김</li>
<li>빈이 BeanFactoryAware를 구현하면 setBEanFactory() 호출하여 빈팩토리 자체를 넘김</li>
<li>빈이 ApplicationContextAware를 구현하면 스프링이 setApplicationContext()를 호출하고 둘러싼 애플리케이션컨텍스트에 대한 참조를 넘김</li>
<li>빈이 BeanPostProcessor 인터페이스를 구현하면 스프링은 postProcessBeforeInitialzation()을 호출</li>
</ol>
<p>–</p>
<h3 id="122-2-life-cycle"><a href="#1-2-2-2-life-cycle" class="headerlink" title="1.2.2-2 life-cycle"></a>1.2.2-2 life-cycle</h3><ol start="7"><br><li>빈이 InitialzingBean 인터페이스를 구현하면 스프링은 afterPropertiesSet() 호출, 빈이 init-method와 함께 선언됐으면 지정한 초기화 메소드가 호출</li><br><li>빈이 BeanPostProcessor를 구현하면 스프링은 postProcessAfterInitialization() 호출</li><br><li>이 상태가 되면 빈은 애플리케이션에서 사용될 준비가 된 것이며, 애플리케이션 컨텍스트가 소멸될 때까지 애플리케이션 컨텍스트에 남아 있다.</li><br><li>빈이 DisposableBean 인터페이스를 구현하면 스프링은 destroy()를 호출한다. 마찬가지고 빈이 destroy-method와 함께 선언됬으면 지정 메소드가 호출</li><br></ol>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;center&gt;&lt;br&gt;    &lt;h2 style=&quot;text-align: ce
    
    </summary>
    
      <category term="slide" scheme="https://wickso.me/categories/slide/"/>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="spring" scheme="https://wickso.me/tags/spring/"/>
    
  </entry>
  
</feed>
