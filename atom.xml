<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wicksome Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wickso.me/"/>
  <updated>2017-05-02T13:11:13.000Z</updated>
  <id>https://wickso.me/</id>
  
  <author>
    <name>Yeongjun Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Template Method Pattern</title>
    <link href="https://wickso.me/2017/05/02/template-method-pattern/"/>
    <id>https://wickso.me/2017/05/02/template-method-pattern/</id>
    <published>2017-05-02T03:57:22.000Z</published>
    <updated>2017-05-02T13:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="의도"><a href="#의도" class="headerlink" title="의도"></a>의도</h2><p>연산<sub>operation</sub>에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다.</p>
<h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p><img src="http://www.cs.unc.edu/~stotts/GOF/hires/Pictures/tmethod.gif" alt="Template Method Pattern"></p>
<h2 id="활용성"><a href="#활용성" class="headerlink" title="활용성"></a>활용성</h2><ul>
<li>어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때</li>
<li>서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93]<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC '93), pages 66–73, Indianapolis, IN, February 1993.
">[1]</span></a></sup> “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다.</li>
<li>서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.</li>
</ul>
<a id="more"></a>
<h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><ul>
<li>템플릿 메서드는 코드 재사용을 위한 기본 기술이다(특히 클라스 라이브러리 구현 시 중요).</li>
<li>템플릿 메서드는 IoC(Inversion of Control, 제어 역전) 구조를 이끌어 낸다. 즉, 부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만 반대 방향의 호출은 안 된다.<blockquote><p>Don’t call us, we’ll call you.</p>
<footer><strong>할리우드 원칙(Hollywood principle)</strong></footer></blockquote></li>
<li>템플릿 메서드는 여러 종류의 연산 중 하나를 호출한다.<ul>
<li>구체 연산</li>
<li>AbstractClass 구체 연산</li>
<li>기본 연산</li>
<li>factory method</li>
<li>hook operation: 필요하다면 서브클래스에서 활장할 수 있는 기본 행동을 제공하는 연산. 기본적으로 아무 내용도 정의하지 않는다.</li>
</ul>
</li>
</ul>
<h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><ul>
<li><strong>접근제어자를 이용한다.</strong> - 템플릿 메서드에서 호출하는 기본 연산들을 protected로 구현한다. 이렇게 하면 이 연산들은 템플릿 메서드만 호출할 수 있게 된다. 템플릿 메서드는 재정의하면 안되므로 맴버 함수로 만든다(final로 정의하면 재정의 불가능).</li>
<li><strong>기본 연산의 수를 최소화한다.</strong> - 템플릿 메서드를 설계할 때 중요한 목표 중 하나는 서브클래스가 오버라이드해야 하는 연산의 수를 최소화하는 것이다. 재정의해야 하는 메서드가 많아질수록 사용자는 불편해진다.</li>
<li><strong>네이밍 규칙을 만든다.</strong> - 재정의 연산에 접두어를 추가하여 식별이 잘되도록 할 수 있다. 예를 들어, 매킨토시 응용프로그램의 MapAPP프레임워크[App89]<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994.
">[2]</span></a></sup>의 모든 템플릿 메서드는 <code>Do-</code>로 시작한다. <code>DoCreateDocument</code>, <code>DoRead</code></li>
</ul>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>문서 관리 응용프로그램이 새 문서를 만드는 경우로 예를 들어 보자. 모든 응용프로그램은 파일을 생성하기 전에 파일 존재 확인과 권한 확인을 하며, 특정 응용프로그램은 파일을 열기전에 로그를 출력해야 한다.</p>
<p>이런 경우에 <code>openNewDocument()</code> 템플릿 메서드를 사용할 수 있다. <code>Application.java</code>는 항상 확인해야할 연산(파일 존재 확인, 권한 확인)을 추상 메서드로 정의하고 템플릿 메서드에서 수행한다. Application에서 <code>beforeCreateDocument()</code>는 hook 연산으로 필요에따라 확장해서 사용 가능하다. 이렇게 함으로</p>
<p>추상 연산을 통해 알고리즘의 일부를 정의함으로써, 템플릿 메서드는 각 단계의 순서는 고정하되 각각의 서브클래스는 필요에 따라 이들 단계의 처리를 다양화시킬 수 있다.</p>
<p><em>Application.java(AbstractClass)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">newDcument</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> createDocument(); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Document <span class="title">createDocument</span><span class="params">()</span></span>; <span class="comment">// factory method</span></div><div class="line"></div><div class="line">  <span class="comment">// template method</span></div><div class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> Document <span class="title">openNewDocument</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!existDocument(fileName)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The file doesn't exist: "</span> + fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!canOpenDocument(fileName)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"can't open the document: "</span> + fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    beforeCreateDocument(); <span class="comment">// hook 연산</span></div><div class="line">    Document document = createDocument(); <span class="comment">// template method에서 factory method가 호출된다.</span></div><div class="line">    document.setFileName(fileName);</div><div class="line">    <span class="keyword">return</span> document;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String fileName)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">canOpenDocument</span><span class="params">(String fileName)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeCreateDocument</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// hook: 기본적으로 아무 내용도 정의하지 않는다.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>MyApplication.java(ConcreteClass)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PATH = <span class="string">"/local/path/base"</span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCreateDocument</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"create document"</span>); &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">createDocument</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> WordDocument(); &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> File(BASE_PATH + fileName)).exists();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>[<a href="http://wiki.c2.com/?GangOfFour" rel="external nofollow noopener noreferrer" target="_blank">GOF</a>{kr}:419] - 템플릿 메서드</li><br>        <li>GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.</li><br>    </ul><br></div>

<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC ‘93), pages 66–73, Indianapolis, IN, February 1993.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994.<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;의도&quot;&gt;&lt;a href=&quot;#의도&quot; class=&quot;headerlink&quot; title=&quot;의도&quot;&gt;&lt;/a&gt;의도&lt;/h2&gt;&lt;p&gt;연산&lt;sub&gt;operation&lt;/sub&gt;에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다.&lt;/p&gt;
&lt;h2 id=&quot;구조&quot;&gt;&lt;a href=&quot;#구조&quot; class=&quot;headerlink&quot; title=&quot;구조&quot;&gt;&lt;/a&gt;구조&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.cs.unc.edu/~stotts/GOF/hires/Pictures/tmethod.gif&quot; alt=&quot;Template Method Pattern&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;활용성&quot;&gt;&lt;a href=&quot;#활용성&quot; class=&quot;headerlink&quot; title=&quot;활용성&quot;&gt;&lt;/a&gt;활용성&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때&lt;/li&gt;
&lt;li&gt;서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93]&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-right hint--error hint--large&quot; aria-label=&quot;William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC &#39;93), pages 66–73, Indianapolis, IN, February 1993.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다.&lt;/li&gt;
&lt;li&gt;서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="design pattern" scheme="https://wickso.me/tags/design-pattern/"/>
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="befavioral pattern" scheme="https://wickso.me/tags/befavioral-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Factory Method Pattern</title>
    <link href="https://wickso.me/2017/04/26/factory-method-pattern/"/>
    <id>https://wickso.me/2017/04/26/factory-method-pattern/</id>
    <published>2017-04-26T04:32:16.000Z</published>
    <updated>2017-05-02T05:23:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="의도"><a href="#의도" class="headerlink" title="의도"></a>의도</h2><p>객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.</p>
<blockquote><p>Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다.</p>
<footer><strong>위키백과</strong><cite><a href="https://ko.wikipedia.org/wiki/%ED%8C%A9%ED%86%A0%EB%A6%AC_%EB%A9%94%EC%84%9C%EB%93%9C_%ED%8C%A8%ED%84%B4" rel="external nofollow noopener noreferrer" target="_blank">팩토리 메서드 패턴</a></cite></footer></blockquote>
<h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p><img src="https://www.codeproject.com/KB/architecture/csdespat_1/dpcs_fm.gif" alt="Factory Method Pattern"></p>
<h2 id="활용성"><a href="#활용성" class="headerlink" title="활용성"></a>활용성</h2><ul>
<li>어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때</li>
<li>생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때</li>
<li>객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때</li>
</ul>
<a id="more"></a>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>예를 들어 다양한 종류의 문서를 표현하는 응용프로그램 프레임워크가 있다. 이를 위해서는 일단 두 개의 큰 추상화가 필요하다. 하나는 <em>Creator</em>(응용프로그램) 추상 클래스이고, 다른 하나는 <em>Product</em>(문서) 추상 클래스(혹은 인터페이스)이다.<br><em>Creator</em> 클래스는 문서의 인스턴스를 ++언제++ 만들지는 알지만, ++어떤 문서++를 만들어야 하는지는 알지 못한다. <em>Product</em> 클래스가 추상 클래스이기 때문에 인스턴스를 가질 수 없기 때문이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> createProduct(); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>; <span class="comment">// factory method</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>팩토리 메서드 패턴은 이런 문제에 대한 해법을 제시한다. <em>Document</em>의 서브클래스 중 어느 것을 생성해야 하는지에 대한 정보를 캡슐화하고, 그것을 프레임워크에서 떼어낸다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><em>TextProduct</em> 클래스와 PhotoProduct 클래스를 팩토리 메서드 패턴을 활용하여 생성한다면 아래와 같은 방법이 있다.</p>
<h4 id="방법-1-추상-클래스"><a href="#방법-1-추상-클래스" class="headerlink" title="방법 1) 추상 클래스"></a>방법 1) 추상 클래스</h4><p>사용자는 특정 응용프로그램에 종속적인 구현을 위해서 두 클래스의 서브 클래스를 정의할 수 있다. <em>Creator</em> 클래스는 <em>Product</em> 객체를 관리하는 책임을 맡고 있으며, 필요에 따라 문서를 생성할 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern example with abstract class</span></div><div class="line">Creator textCreator = <span class="keyword">new</span> TextCreator();</div><div class="line">Product p1 = textCreator.newProduct();</div><div class="line"></div><div class="line">Creator photoCreator = <span class="keyword">new</span> PhotoCreator();</div><div class="line">Product p2 = photoCreator.newProduct();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WordProduct();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PhotoProduct();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-2-팩토리-메서드-매개변수화-abstract-factory-pattern"><a href="#방법-2-팩토리-메서드-매개변수화-abstract-factory-pattern" class="headerlink" title="방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern"></a>방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern</h4><p>팩토리 메서드가 매개변수를 받아서 어떤 종류의 제품을 생성할지 만드는 방법도 있다. (추상 팩토리 패턴은 팩토리 메서드를 이용해서 구현할 때가 많다)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Factory pattern example using argument</span></div><div class="line">Product p1 = Creator1.create(ProductType.TEXT);</div><div class="line">Product p2 = Creator1.create(ProductType.PHOTO);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ProductType &#123;</div><div class="line">  TEXT, PHOTO</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Product <span class="title">create</span><span class="params">(ProductType type)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">      <span class="keyword">case</span> TEXT:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExcelProduct();</div><div class="line">      <span class="keyword">case</span> PHOTO:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImageProduct();</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-3-lazy-initialization-기법"><a href="#방법-3-Lazy-Initialization-기법" class="headerlink" title="방법 3) Lazy Initialization 기법"></a>방법 3) Lazy Initialization 기법</h4><p>인스턴스화하는 접근자 메서드를 통해서만 인스턴스에 접근하는 방법으로, 생성자에서 아무 의미 없는 값으로 인스턴스에 대한 매개변수를 초기화하고, 접근자 메서드가 인스턴스를 반환하도록 할 수 있다. 생성자가 초기화 시키는 것이 아니라 필요한 시점에서 초기화를 수행하기 때문에 이런 기법을 Lazy Initialization이라고 한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern with lazy initialization</span></div><div class="line">TextCreator textCreator = <span class="keyword">new</span> TextCreator();</div><div class="line">List collection = textCreator.newCollection();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> List <span class="title">createCollection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TextProduct&gt;();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> List&lt;Product&gt; collection = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> List <span class="title">newCollection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// lazy initialization</span></div><div class="line">    <span class="keyword">if</span> (collection == <span class="keyword">null</span>) &#123;</div><div class="line">      collection = createCollection();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> collection;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// factory method</span></div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> List <span class="title">createCollection</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-4-템플릿-활용"><a href="#방법-4-템플릿-활용" class="headerlink" title="방법 4) 템플릿 활용"></a>방법 4) 템플릿 활용</h4><p>팩토리 메서드를 사용하면 생길 수 있는 문제점 중 하나는 <em>Product</em> 클래스 하나를 추가하려 할 때마다 <em>Creator</em> 클래스를 서브클래싱해야 한다는 점이다(<a href="#방법-1-추상-클래스">방법 1</a>). 이로써 클래스 계통의 부피가 확장되는 문제가 생길 수 있다. 이런 문제를 해결할 수 있는 방법 중 하나는 <em>Creator</em> 클래스를 상속받는 제네릭 클래스를 정의하고 Product 클래스로 매개변수화되도록 만드는 것이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern example whti template</span></div><div class="line">StandardCreator&lt;WordProduct&gt; wordProductCreator = <span class="keyword">new</span> StandardCreator&lt;&gt;(WordProduct.class);</div><div class="line">Product p1 = wordProductCreator.newProduct();</div><div class="line"></div><div class="line">StandardCreator&lt;ImageProduct&gt; imageProductCreator = <span class="keyword">new</span> StandardCreator&lt;&gt;(ImageProduct.class);</div><div class="line">Product p2 = imageProductCreator.newProduct();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creator Template</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; product type</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardCreator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Product</span>&gt; <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Class&lt;T&gt; cls;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StandardCreator</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.cls = cls;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    T product = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      product = cls.newInstance();</div><div class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> product;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>[<a href="http://wiki.c2.com/?GangOfFour" rel="external nofollow noopener noreferrer" target="_blank">GOF</a>{kr}:419] - 템플릿 메서드</li><br>        <li>GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.</li><br>    </ul><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;의도&quot;&gt;&lt;a href=&quot;#의도&quot; class=&quot;headerlink&quot; title=&quot;의도&quot;&gt;&lt;/a&gt;의도&lt;/h2&gt;&lt;p&gt;객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;위키백과&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8C%A9%ED%86%A0%EB%A6%AC_%EB%A9%94%EC%84%9C%EB%93%9C_%ED%8C%A8%ED%84%B4&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;팩토리 메서드 패턴&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;구조&quot;&gt;&lt;a href=&quot;#구조&quot; class=&quot;headerlink&quot; title=&quot;구조&quot;&gt;&lt;/a&gt;구조&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www.codeproject.com/KB/architecture/csdespat_1/dpcs_fm.gif&quot; alt=&quot;Factory Method Pattern&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;활용성&quot;&gt;&lt;a href=&quot;#활용성&quot; class=&quot;headerlink&quot; title=&quot;활용성&quot;&gt;&lt;/a&gt;활용성&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때&lt;/li&gt;
&lt;li&gt;생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때&lt;/li&gt;
&lt;li&gt;객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="design pattern" scheme="https://wickso.me/tags/design-pattern/"/>
    
      <category term="creational pattern" scheme="https://wickso.me/tags/creational-pattern/"/>
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring 01</title>
    <link href="https://wickso.me/2016/04/07/spring-01/"/>
    <id>https://wickso.me/2016/04/07/spring-01/</id>
    <published>2016-04-06T17:32:16.000Z</published>
    <updated>2017-05-03T05:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center><br>    <h2 style="text-align: center;" id="spring-in-action">Spring in Action</h2><br>    <strong>chapter 1</strong><br><br>    스프링 속으로<br></center><br><br><br><div style="text-align: right;"><br>    <p><strong>@date</strong>    2016.04.07</p><br></div><br><br>—<br><br>## readme<br><br>Spring in Action 으로 공부하면서 어려웠던 부분, 기억해야 할 것같은 부분 위주로 정리한 ppt이다. 상단 제목의 번호는 필요할 때 책을 참고하고자 동일하게 적어두었다.<br><br>—<br><br>## 1.1 자바 개발 간소화<br><br>자바 복잡도 간소화를 지원하기 위한 주요 전략<br><br>1. POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive)인 개발<sup><em></em></sup><br>2. DI와 인터페이스 지향(interface orientation)을 통한 느슨한 결합도(loose coupling)<br>3. 애스펙트와 공통 규약을 통한 선언적(declarative) 프로그래밍<br>4. 애스팩트와 템플릿(template)을 통한 반복적인 코드 제거<br><br><small>비침투적 개발이란, 바탕이 되는 기술을 사용하는 클래스, 인터페이스, API 등을 코드에 직접 나타내지 않는 방법으로 복잡함을 분리할 수 있다.</small><br><br>–<br><br>## 1.1.2 종속객체 주입<br><br>- <strong>종속객체 주입(DI, Dependency Injection)</strong><br>- 객체는 종속객체를 생성하거나 얻지 않는다. 즉, 종속객체는 종속객체가 필요한 객체에 주입된다.<br><br>–<br><br>### 1.1.2-1<br><strong>생성자 주입(constructor injection)</strong><br><br>    public class BraveKnight implements Knight {<br>        private Quest quest;<br>        public BraveKnight(Quest quest) { // Quest 주입<br>            this.quest = quest;<br>        }<br>        public void embarkOnQuest() {<br>            quest.embark();<br>        }<br>    }<br><br>–<br><br>### 1.1.2-2<br>BraveNight 테스트<br><br>    public class BraveKnightTest {<br>        @Test<br>        public void knightShouldEmbarkOnQuest() {<br>            Quest mockQuest = mock(Quest.class); // 모의 Quest 생성<br>            BraveKnight knight = new BraveKnight(mockQuest); // 모의 Quest 주입<br>            knight.embarkOnQuest();<br>            verify(mockQuest, time(1)).embark();<br>        }<br>    }<br><br>강한 결합으로 생성자 안에서 quest를 생성할 때는 테스트가 불가능 했지만 DI를 이용하고 테스트가 가능하다. embarkOnQuest()를 호출한 후에 Mockito에게 Quest의 embark()가 정확히 한 번 호출됐는지 확인한다.<br><br>–<br><br>### 1.1.2-3<br><br>    public class SlayDragonQuest implements Quest {<br>        private PrintStream stream;<br>        public SlayDragonQuest(PrintStream stream) {<br>            this.stream = stream;<br>        }<br>        public void embark() {<br>            stream.println(“Embarking on quest to slay the dragon!”);<br>        }<br>    }<br><br>위와 같은 클래스가 있을 때, 어떻게 BraveKnight에게 SlayDragonQuest를 줄 수 있는가? 그리고 어떻게 SlayDragonQuest에게 PrintStrean을 줄 수 있는가?<br><br>–<br><br>### 1.1.2-4<br><strong>와이어링(wiring)</strong>: 애플리케이션 컴포넌트 간의 관계를 정의하는 것(xml or java를 이용한 방법)<br><br>xml<br><br>    &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>    <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd"><br>        <bean id="knight" class="com.test.knights.BraveKnight"><br>            <constructor-arg ref="quest"> <!-- 빈 주입 --><br>        </constructor-arg></bean><br><br>        <bean id="quest" class="com.test.knights.SlayDragonQuest"> <!-- SlayDragonQuest 생성 --><br>            <constructor-arg value="#{T(System).out}"><br>        </constructor-arg></bean><br>    </beans><br><br>–<br><br>### 1.1.2-5<br>java<br><br>    @Configuration<br>    public class KnightConfig {<br>        @Bean<br>        public Knight knight() {<br>            return new BraveKnight(quest());<br>        }<br><br>        @Bean<br>        public Quest quest() {<br>            return new SlayDragonQuest(System.out);<br>        }<br>    }<br><br>–<br><br>### 1.1.2-6<br><strong>실행해 보기</strong><br><br><strong>application context</strong>은 빈에 관한 정의들을 바탕으로 빈들을 엮어 준다. 스프링 애플리케이션 컨텍스트는 애플리케이션을 구성하는 객체의 생성과 와이어링을 전적으로 책임진다.<br><br>xml: ClassPathXmlApplicationContext()<br><br>java: AnnotationConfigApplicationContext()<br><br>    public static void main(String[] args) {<br>        ClassPathXmlApplicationContext context = // 스프링 컨텍스트 로드<br>            new ClassPathXmlApplicationContext(<br>                    “META-INF/spring/knights.xml”);<br>        Knight k = context.getBean(Knight.class); // 빈 얻기<br>        k.embarkOnQuest(); // 사용<br>        context.close();<br>    }<br><br>–<br><br>## 1.1.3 애스펙트 적용<br>AOP(Aspect-Oriented Programming)은 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용할 수 있는 컴포넌트에 담는다. 즉, 소프트웨어 내부의 관심사들을 서로 분리하는 기술이다. 예를 들어 로깅, 트랜잭션 관리, 보안 등의 시스템 서비스(이렇게 여러 컴포넌트에 관련되는 것을 <em>*횡단 관심사(cross-cutting concerns)</em>라고 한다. 이러한 관심사가 각각의 컴포넌트에 퍼지게 되면 다음과 같은 문제점이 있다.<br><br>1. 관심사를 구현하는 코드가 시스템 전반에 중복되어 걸쳐있어, 변경해야하는 경우 모두 변경해야 한다.<br>2. 컴포넌트의 코드가 본연의 기능과 관련 없응 코드로 지저분해진다.<br><br>–<br><br>### 1.1.3-1<br>AOP를 이용하면 응집도가 높고 본연의 관심사에 집중하는 컴포넌트를 만든다. 즉, 애스펙트는 확실히 POJO를 단순화한다.<br><center><br><img src="http://www.geekmantra.com/staticcontent/contentimages/Spring-Aspect-Oriented1.gif" alt="aspect-exam"><br></center>

<p>–</p>
<h3 id="113-2"><a href="#1-1-3-2" class="headerlink" title="1.1.3-2"></a>1.1.3-2</h3><p>ex) 기사가 원정전,후에 노래가 울려야 할 경우</p>
<pre><code>public class BraveKnight implements Knight {
    ...
    public void embarkOuest() {
        sing.beforeQuest(); // 기사가 이것까지 관리해야할까?
        quest.embark();
        sing.afterQuest();
    }
}
</code></pre><p>–</p>
<h3 id="113-3"><a href="#1-1-3-3" class="headerlink" title="1.1.3-3"></a>1.1.3-3</h3><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    ...&gt;
    &lt;bean id=&quot;sing&quot; class=&quot;com.test.Sing&quot;&gt;
        ...
    &lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;aop:aspect ref=&quot;sing&quot;&gt;
            &lt;aop:pointcut id=&quot;embark&quot;
                expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt; &lt;!-- 포인트커트 정의 --&gt;
            &lt;aop:before pointcut-ref=&quot;embark&quot;
                method=&quot;beforeQuest&quot;/&gt;
            &lt;aop:after pointcut-ref=&quot;embark&quot;
                method=&quot;afterQuest&quot;/&gt;
        &lt;/sop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/bean&gt;
</code></pre><hr>
<h2 id="12-빈은-담는-그릇-컨테이너"><a href="#1-2-빈은-담는-그릇-컨테이너" class="headerlink" title="1.2 빈은 담는 그릇, 컨테이너"></a>1.2 빈은 담는 그릇, 컨테이너</h2><p>스프링 기반 애플리케이션은 spring container 안에서 객체가 태어나고, 자라고, 소멸한다. 그래서 spring container는 객체를 생성하고, 엮어주고, 이들의 전체 생명주기를 관리한다.</p>
<p>–</p>
<h3 id="12-1"><a href="#1-2-1" class="headerlink" title="1.2-1"></a>1.2-1</h3><p>스프링에는 여러 컨테이너 구현체가 존재하며, 이들은 크게 두 가지로 분류된다.</p>
<ol>
<li>빈 팩토리(org.springframework.beans.factory.BeanFactory)<ul>
<li>인터페이스에 의해 정의</li>
<li>DI에 대한 기본적인 지원을 제공하는 가장 단순한 컨테이너</li>
</ul>
</li>
<li>애플리케이션 컨텍스트(org.springframework.context.ApplicationContext)<ul>
<li>인터페이스에 의해 정의</li>
<li>빈 팩토리를 확장해 애플리케이션 프레임워크 서비스를 제공하는 컨테이너</li>
</ul>
</li>
</ol>
<p>–</p>
<h3 id="121-애플리케이션-컨텍스트"><a href="#1-2-1-애플리케이션-컨텍스트" class="headerlink" title="1.2.1 애플리케이션 컨텍스트"></a>1.2.1 애플리케이션 컨텍스트</h3><p>애플리케이션의 설정을 제공하기 위한 중앙 인터페이스로, 실행중일땐 읽기만 가능하지만, 실행이 지원되면 리로드될 수 있다.</p>
<ul>
<li>AnnotationConfigApplicationContext<br>  <small>하나 이상의 자바 기반 설정 클래스에서 스코프 애플리케이션 컨텍스트를 로드</small></li>
<li>AnnotationConfigWebApplicationContext<br>  <small>하나 이상의 자바 기반 설정 클래스에서 스프링 웹 애플리케이션 컨텍스트를 로드</small></li>
<li>ClassPathXmlApplicationContext<br>  <small>클래스패스에 위치한 xml 파일에서 컨텍스트 정의 내용을 로드</small></li>
<li>FileSystemXmlApplicationContext<br>  <small>파일 경로로 지정된 xml 파일에서 컨텍스트 정의 내용 로드</small></li>
<li>XmlWebApplicationContext<br>  <small>웹 어플리케이션에 포함된 xml 파일에서 컨텍스트 정의 내용 로드</small></li>
</ul>
<p>–</p>
<h3 id="122-빈의-생명주기"><a href="#1-2-2-빈의-생명주기" class="headerlink" title="1.2.2 빈의 생명주기"></a>1.2.2 빈의 생명주기</h3><center><img src="https://premaseem.files.wordpress.com/2013/02/spring-bean-lifecycle.png" style="border:0px; width:60%; height:60%"></center>

<p>–</p>
<h3 id="122-1-life-cycle"><a href="#1-2-2-1-life-cycle" class="headerlink" title="1.2.2-1 life-cycle"></a>1.2.2-1 life-cycle</h3><ol>
<li>스프링이 빈 인스턴스화</li>
<li>스프링이 값과 빈의 레퍼런스를 빈의 프로퍼티에 주입</li>
<li>빈이 BeanNameAware를 구현하면 스프링이 빈의 ID를 setBEanName()에 넘김</li>
<li>빈이 BeanFactoryAware를 구현하면 setBEanFactory() 호출하여 빈팩토리 자체를 넘김</li>
<li>빈이 ApplicationContextAware를 구현하면 스프링이 setApplicationContext()를 호출하고 둘러싼 애플리케이션컨텍스트에 대한 참조를 넘김</li>
<li>빈이 BeanPostProcessor 인터페이스를 구현하면 스프링은 postProcessBeforeInitialzation()을 호출</li>
</ol>
<p>–</p>
<h3 id="122-2-life-cycle"><a href="#1-2-2-2-life-cycle" class="headerlink" title="1.2.2-2 life-cycle"></a>1.2.2-2 life-cycle</h3><ol start="7"><br><li>빈이 InitialzingBean 인터페이스를 구현하면 스프링은 afterPropertiesSet() 호출, 빈이 init-method와 함께 선언됐으면 지정한 초기화 메소드가 호출</li><br><li>빈이 BeanPostProcessor를 구현하면 스프링은 postProcessAfterInitialization() 호출</li><br><li>이 상태가 되면 빈은 애플리케이션에서 사용될 준비가 된 것이며, 애플리케이션 컨텍스트가 소멸될 때까지 애플리케이션 컨텍스트에 남아 있다.</li><br><li>빈이 DisposableBean 인터페이스를 구현하면 스프링은 destroy()를 호출한다. 마찬가지고 빈이 destroy-method와 함께 선언됬으면 지정 메소드가 호출</li><br></ol>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;center&gt;&lt;br&gt;    &lt;h2 style=&quot;text-align: ce
    
    </summary>
    
      <category term="slide" scheme="https://wickso.me/categories/slide/"/>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="spring" scheme="https://wickso.me/tags/spring/"/>
    
  </entry>
  
</feed>
