<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wicksome Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wickso.me/"/>
  <updated>2018-02-21T06:20:00.000Z</updated>
  <id>https://wickso.me/</id>
  
  <author>
    <name>Yeongjun Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell Script Cookbook</title>
    <link href="https://wickso.me/2018/02/21/shell-script-cook-book/"/>
    <id>https://wickso.me/2018/02/21/shell-script-cook-book/</id>
    <published>2018-02-21T06:20:00.000Z</published>
    <updated>2018-02-21T06:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>두번 작성하기 귀찮아서 모아놓은 스크립트</p>
</blockquote>
<h4 id="2018-02-21-0500-~-2018-02-21-0509-로그-보기"><a href="#2018-02-21-05-00-2018-02-21-05-09-로그-보기" class="headerlink" title="2018-02-21 05:00 ~ 2018-02-21 05:09 로그 보기"></a>2018-02-21 05:00 ~ 2018-02-21 05:09 로그 보기</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">grep -E <span class="string">"^2018-02-21 05:0[0-9]:[0-9]&#123;2&#125; "</span> catalina.out &gt; temp.$(hostname).out</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;두번 작성하기 귀찮아서 모아놓은 스크립트&lt;/p
    
    </summary>
    
    
      <category term="shell script" scheme="https://wickso.me/tags/shell-script/"/>
    
      <category term="bash" scheme="https://wickso.me/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>Java8에서 타임존(Time-Zone) 다루기</title>
    <link href="https://wickso.me/2018/02/20/time-zone-with-java8/"/>
    <id>https://wickso.me/2018/02/20/time-zone-with-java8/</id>
    <published>2018-02-20T14:30:00.000Z</published>
    <updated>2018-02-21T08:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Standard_World_Time_Zones.png/800px-Standard_World_Time_Zones.png" alt="Time Zone Map"></p>
<h2 id="타임존이란"><a href="#타임존이란" class="headerlink" title="타임존이란?"></a>타임존이란?</h2><p>타임존은 여러 가지 다른 것을 설명하는 데 사용할 수 있지만 대개 지역 또는 국가의 현지 시간을 나타내며, 주로 해당 국가에 의해 법적으로 지정된다.</p>
<h2 id="utc-vs-gmt"><a href="#UTC-vs-GMT" class="headerlink" title="UTC vs GMT"></a>UTC vs GMT</h2><blockquote>
<p>GMT is a <b>time zone</b> and UTC is a <b>time standard</b>.</p>
</blockquote>
<p>GMT와 UTC는 같은 시간을 공유하고(동일하진 않고 초의 소숫점단위에서 차이가 난다) 혼용되서 사용되지만 엄밀히 구분하자면 다르다.</p>
<h4 id="gmtgreenwich-mean-time"><a href="#GMT-Greenwich-Mean-Time" class="headerlink" title="GMT(Greenwich Mean Time)"></a>GMT(Greenwich Mean Time)</h4><p>경도 0도에 위치한 영국 런던 그리니치에 있는 왕립 천문대의 시간으로, 모든 시간대의 시작점을 나타내며, 일년내내 DST(Daylight Saving Time)의 영향을 받지 않는다. GMT는 1925년 2월 5일부터 사용하기 시작했으며, 1972년 1월 1일까지 세계 표준시로 사용되었다.</p>
<h4 id="utc"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h4><p>UTC(협정 세계시, 協定世界時)는 국제 표준시로 타임존이 아니다. 즉, UTC를 공식적으로 현지 시간으로 사용하는 국가나 지역은 없다. 협정 세계시를 영어권에서는 Coordinated Universal Time(CUT)라고, 프랑스어권에서는 Temps Universel Coordonné(TUC)라고 하는데, 혼돈을 방지하기 위해서 공식적으로 UTC라고 정해졌다.</p>
<h2 id="dstdaylight-saving-time"><a href="#DST-Daylight-Saving-time" class="headerlink" title="DST(Daylight Saving time)"></a>DST(Daylight Saving time)</h2><p>DST는 자연 일광을 보다 잘 활용하기 위해서 여름철에 표준 시간에서 1시간 앞으로, 그리고 다시 가을에 시간을 1시간 전으로 설정하는 것을 말한다.<br>DST와 “summer time”은 같은 말을 뜻하며 특정 나라에서 주로 불린다. 영국에서 썸머타임이라고 많이 사용하며, DST가 적용되지 않는 표준시는 “winter time”이라고 사용되기도 한다. DST를 독일에서는 “sommerzeit”, 스칸디나비아에서는 “sommertid”라고도 사용한다.</p>
<h2 id="java8의-타임존"><a href="#Java8의-타임존" class="headerlink" title="Java8의 타임존"></a>Java8의 타임존</h2><p>Time-Zone은 정부에 의해 변경되는 경우가 있는데, Java는 <a href="https://www.iana.org/time-zones" rel="external nofollow noopener noreferrer" target="_blank">IANA 데이터베이스</a>를 사용하고, 따로 버전업 없이 독립적으로 시간대 데이터베이스를 업데이트 한다. 즉, 하드코딩으로 관리하지 않아도 된다. 또한, Java8에서는 타임존, DST를 좀 더 편하게 사용하기 위해 <code>ZoneId</code>, <code>ZonedDateTime</code>, <code>LocalDateTime</code> 등이 추가되었다.<br>이용할 수 있는 Time-Zone은 <code>ZoneId.getAvilableIds()</code>로 확인할 수 있으며, 현재 시점 등록된 ID는 600개이다.</p>
<table>
<thead>
<tr>
<th>class</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ZoneId</code></td>
<td>시간대를 나타낸다.</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td>지역 시간을 나타낸다. 즉, 시간대 정보가 없다.</td>
</tr>
<tr>
<td><code>ZonedDateTime</code></td>
<td>구역 시간을 나타낸다.</td>
</tr>
<tr>
<td><code>TemporalAdjuster</code></td>
<td>달력 계산에 사용한다. (e.g. 다음 달의 첫번째 날)</td>
</tr>
<tr>
<td><code>DateTimeFormatter</code></td>
<td>날짜와 시간의 서식을 지정하기 위해 사용한다.</td>
</tr>
</tbody>
</table>
<p>아래는 타임존 관련된 몇 가지 예제이다.</p>
<h4 id="사용자에게-타임존offset을-표시할-때-어떻게-보여줄-것인가"><a href="#사용자에게-타임존-offset-을-표시할-때-어떻게-보여줄-것인가" class="headerlink" title="사용자에게 타임존(+offset)을 표시할 때 어떻게 보여줄 것인가?"></a>사용자에게 타임존(+offset)을 표시할 때 어떻게 보여줄 것인가?</h4><p>예를 들어, 타임존을 <code>GMT+09:00 Seoul</code> 형식에 맞게 출력하려고 한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 현재 시간 기준(2018/03/21)</span></div><div class="line"><span class="keyword">final</span> List&lt;ZoneId&gt; timeZones = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">timeZones.add(ZoneId.of(<span class="string">"America/Santiago"</span>));</div><div class="line">timeZones.add(ZoneId.of(<span class="string">"Asia/Seoul"</span>));</div><div class="line">timeZones.add(ZoneId.of(<span class="string">"Australia/Sydney"</span>));</div><div class="line"></div><div class="line">timeZones.forEach(zoneId -&gt; &#123;</div><div class="line">    <span class="keyword">final</span> ZoneOffset offset = zoneId.getRules().getStandardOffset(Instant.now());</div><div class="line">    System.out.println(String.format(<span class="string">"GMT%s %s"</span>, offset.getId(), zoneId.getId().split(<span class="string">"/"</span>)[<span class="number">1</span>]));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GMT-04:00 Santiago</div><div class="line">GMT+09:00 Seoul</div><div class="line">GMT+10:00 Sydney</div></pre></td></tr></table></figure>
<p>위 코드에는 한 가지 이슈가 있다. 현재 시점(2018년 2월 21일)에 Santiago는 DST가 시행중으로 offset은 1시간 당긴 <code>-03:00</code>이다. 하지만, <code>getStandardOffset()</code>은 표준 오프셋을 가져오므로 <code>-04:00</code>를 출력한다(Sydney도 동일하다). 아래와 같이 <code>offset</code>을 선언하면 DST가 적용된 offset을 가져올 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> ZoneOffset offset = LocalDateTime.now().atZone(zoneId).getOffset();</div></pre></td></tr></table></figure>
<p>(+) <a href="https://www.timeanddate.com/time/gmt-utc-time.html" rel="external nofollow noopener noreferrer" target="_blank">이 글</a>을 보면 GMT는 DST로 변하지 않는다고 말한다. 그러면 위 코드처럼 DST가 적용된 시간을 <code>GMT{offset}</code>으로 출력해도 되는가? 여러가지 생각해봤지만 어느것이 맞는지 더 찾아봐야겠다.</p>
<ul>
<li>각 나라의 표준시를 보여줄 것인가?</li>
<li>DST를 적용한 GMT를 보여줄 것인가?</li>
<li>DST를 적용한 UTC를 보여줄 것인가?</li>
<li>따로 DST 적용기간 아이콘을 보여줄 것인가?</li>
</ul>
<p>구글 캘린더에서는 <code>(GMT-03:00) 산티아고</code>라고 DST를 적용한 GMT시간을 보여준다.</p>
<h4 id="localdatetime에-zoneid-설정하기"><a href="#LocalDateTime에-ZoneId-설정하기" class="headerlink" title="LocalDateTime에 ZoneId 설정하기"></a><code>LocalDateTime</code>에 <code>ZoneId</code> 설정하기</h4><p>특정 지역 시간(localDateTime)에 Zone-ID를 추가하려면 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">localDateTime.atZone(ZoneId zoneId);</div><div class="line">ZonedDateTime.of(LocalDateTime localDateTime, ZoneId zoneId);</div></pre></td></tr></table></figure>
<p><em>예제</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2017</span>, Month.OCTOBER, <span class="number">18</span>, <span class="number">9</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">final</span> ZonedDateTime zonedDateTime1 = localDateTime.atZone(ZoneId.of(<span class="string">"UTC"</span>));</div><div class="line"><span class="keyword">final</span> ZonedDateTime zonedDateTime2 = ZonedDateTime.of(localDateTime, ZoneId.of(<span class="string">"Asia/Seoul"</span>));</div><div class="line">System.out.println(zonedDateTime1);</div><div class="line">System.out.println(zonedDateTime2);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2017-10-18T09:00Z[UTC]</div><div class="line">2017-10-18T09:00+09:00[Asia/Seoul]</div></pre></td></tr></table></figure>
<div class="tip"><br>    아래 코드와 같은 실수는 하지말자. <code>atZone()</code>은 Zone 정보만 추가할뿐 시간을 변경하지 않는다. 그러므로 <code>localDateTime1</code>과 <code>localDateTime2</code>는 동일하다.<br><br>    <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> LocalDateTime localDateTime1 = localDateTime.atZone(seoul).toLocalDateTime();</div><div class="line"><span class="keyword">final</span> LocalDateTime localDateTime2 = localDateTime.atZone(utc).toLocalDateTime();</div></pre></td></tr></table></figure><br><br></div>


<h4 id="특정-구역-시간의-다른-구역-시간-구하기"><a href="#특정-구역-시간의-다른-구역-시간-구하기" class="headerlink" title="특정 구역 시간의 다른 구역 시간 구하기"></a>특정 구역 시간의 다른 구역 시간 구하기</h4><p>예를 들어, 로스앤젤레스 시간으로 오전 9시가 서울 시간으로 몇시일지 확인하려고 하려고 한다. 아래와 같이 <code>withZoneSameInstant(ZoneId)</code>를 사용하여 시간을 구할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2017</span>, Month.OCTOBER, <span class="number">18</span>, <span class="number">9</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">final</span> ZonedDateTime losAngeles = localDateTime.atZone(ZoneId.of(<span class="string">"America/Los_Angeles"</span>));</div><div class="line"><span class="keyword">final</span> ZonedDateTime seoul = losAngeles.withZoneSameInstant(ZoneId.of(<span class="string">"Asia/Seoul"</span>));</div><div class="line">System.out.println(seoul.toLocalDateTime());</div></pre></td></tr></table></figure>
<h4 id="시간대zoneid-변경하기"><a href="#시간대-ZoneId-변경하기" class="headerlink" title="시간대(ZoneId) 변경하기"></a>시간대(<code>ZoneId</code>) 변경하기</h4><p>시간대만 변경하고자할 땐, <code>withZoneSameLocal(ZoneId)</code>를 사용한다. 즉, 아래 코드에서 <code>losAngeles</code>와 <code>seoul</code>의 <code>localDateTime</code>은 같다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2017</span>, Month.OCTOBER, <span class="number">18</span>, <span class="number">9</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">final</span> ZonedDateTime losAngeles = localDateTime.atZone(ZoneId.of(<span class="string">"America/Los_Angeles"</span>));</div><div class="line"><span class="keyword">final</span> ZonedDateTime seoul = losAngeles.withZoneSameLocal(ZoneId.of(<span class="string">"Asia/Seoul"</span>));</div><div class="line">System.out.println(losAngeles);</div><div class="line">System.out.println(seoul);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2017-10-18T09:00-07:00[America/Los_Angeles]</div><div class="line">2017-10-18T09:00+09:00[Asia/Seoul]</div></pre></td></tr></table></figure>
<h4 id="1주일뒤-회의시간-예약하기"><a href="#1주일뒤-회의시간-예약하기" class="headerlink" title="1주일뒤 회의시간 예약하기"></a>1주일뒤 회의시간 예약하기</h4><p>예를 들어, Santiago에서 2018년 5월 10일 10시 기준으로 7주일 이후에 회의를 잡으려고 한다. 이 경우에는 <code>Period.ofDays(int)</code>을 사용한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// santiago 2018/05/13 00:00:00 이후로 DST 적용</span></div><div class="line"><span class="keyword">final</span> ZonedDateTime now = ZonedDateTime.of(<span class="number">2018</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneId.of(<span class="string">"America/Santiago"</span>));</div><div class="line"><span class="keyword">final</span> ZonedDateTime nextMeeting = now.plus(Period.ofDays(<span class="number">7</span>));</div><div class="line"></div><div class="line">System.out.println(now);</div><div class="line">System.out.println(nextMeeting);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2018-05-10T10:00-03:00[America/Santiago]</div><div class="line">2018-05-17T10:00-04:00[America/Santiago]</div></pre></td></tr></table></figure>
<p>만약 <code>Duration</code>을 사용했다면 Santiago의 DST가 적용되지 잘못된 시간에 회의를 예약하게 된다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> ZonedDateTime nextMeeting = now.plus(Duration.ofDays(<span class="number">7</span>));</div><div class="line">System.out.println(nextMeeting);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2018-05-17T09:00-04:00[America/Santiago]</div></pre></td></tr></table></figure>
<h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul>
<li>timeanddate - What is a Time Zone?: <a href="https://www.timeanddate.com/time/time-zones.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/time-zones.html</a></li>
<li>위키피디아 - 시간대: <a href="https://ko.wikipedia.org/wiki/시간대" rel="external nofollow noopener noreferrer" target="_blank">https://ko.wikipedia.org/wiki/시간대</a></li>
<li>: <a href="https://greenwichmeantime.com/what-is-gmt/" rel="external nofollow noopener noreferrer" target="_blank">https://greenwichmeantime.com/what-is-gmt/</a></li>
<li>: <a href="https://www.timeanddate.com/time/gmt-utc-time.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/gmt-utc-time.html</a></li>
<li>: <a href="https://community.akamai.com/groups/korea-user-group/blog/2015/06/30/gmt-vs-utc" rel="external nofollow noopener noreferrer" target="_blank">https://community.akamai.com/groups/korea-user-group/blog/2015/06/30/gmt-vs-utc</a></li>
<li>: <a href="https://www.timeanddate.com/time/utc-abbreviation.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/utc-abbreviation.html</a></li>
<li>: <a href="https://www.timeanddate.com/time/dst/" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/dst/</a></li>
<li>: <a href="https://www.timeanddate.com/time/dst/summer-time.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/dst/summer-time.html</a></li>
<li>: <a href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html</a></li>
<li>: <a href="http://d2.naver.com/helloworld/645609" rel="external nofollow noopener noreferrer" target="_blank">http://d2.naver.com/helloworld/645609</a></li>
<li>Toast - 자바스크립트에서 타임존 다루기 (1): <a href="http://meetup.toast.com/posts/125" rel="external nofollow noopener noreferrer" target="_blank">http://meetup.toast.com/posts/125</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="java8" scheme="https://wickso.me/tags/java8/"/>
    
      <category term="timezone" scheme="https://wickso.me/tags/timezone/"/>
    
  </entry>
  
  <entry>
    <title>Optional.orElse vs Optional.orElseGet</title>
    <link href="https://wickso.me/2018/02/05/optional-orelse-orelseget/"/>
    <id>https://wickso.me/2018/02/05/optional-orelse-orelseget/</id>
    <published>2018-02-05T06:20:00.000Z</published>
    <updated>2018-02-05T07:08:30.994Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>orElseGet()</code>는 <code>null</code>일 경우에만 호출되고, <code>orElse()</code>는 무조건 호출된다.</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalTest</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"1."</span>);</div><div class="line">    Optional.ofNullable(<span class="keyword">null</span>).orElse(<span class="keyword">new</span> TestObject());</div><div class="line">    System.out.println(<span class="string">"2."</span>);</div><div class="line">    Optional.ofNullable(<span class="keyword">new</span> TestObject()).orElse(<span class="keyword">new</span> TestObject());</div><div class="line">    System.out.println(<span class="string">"3."</span>);</div><div class="line">    Optional.ofNullable(<span class="keyword">null</span>).orElseGet(TestObject::<span class="keyword">new</span>);</div><div class="line">    System.out.println(<span class="string">"4."</span>);</div><div class="line">    Optional.ofNullable(<span class="keyword">new</span> TestObject()).orElseGet(TestObject::<span class="keyword">new</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String str;</div><div class="line">    TestObject() &#123;</div><div class="line">      System.out.println(<span class="string">"new"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1.</div><div class="line">new</div><div class="line">2.</div><div class="line">new</div><div class="line">new</div><div class="line">3.</div><div class="line">new</div><div class="line">4.</div><div class="line">new</div></pre></td></tr></table></figure>
<p>불필요한 호출을 줄이기 위해 <code>null</code>일 경우 반환할 값이 primitive type이면 <code>orElse()</code>, 객체를 생성해야한다면 <code>orElseGet()</code>를 사용하면 될 것 같다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> value = Optional.ofNullable(obj1).orElse(<span class="number">123</span>);</div><div class="line">TestObject object = Optional.ofNullable(obj2).orElseGet(() -&gt; <span class="keyword">new</span> TestObject());</div><div class="line">TestObject object = Optional.ofNullable(obj2).orElseGet(TestObject::<span class="keyword">new</span>);</div></pre></td></tr></table></figure>
<h4 id="reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li>fb-contrib:OI_OPTIONAL_ISSUES_USES_IMMEDIATE_EXECUTION</li>
<li><a href="http://multifrontgarden.tistory.com/131" rel="external nofollow noopener noreferrer" target="_blank">http://multifrontgarden.tistory.com/131</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;orElseGet()&lt;/code&gt;는 &lt;code&gt;null&lt;/code&gt;일 경우에만 호출되고, &lt;code&gt;orElse()&lt;/code&gt;는 무조건 호출된다.&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="java8" scheme="https://wickso.me/tags/java8/"/>
    
      <category term="Optional" scheme="https://wickso.me/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>SonarQube 설치</title>
    <link href="https://wickso.me/2018/01/12/sonarqube-install/"/>
    <id>https://wickso.me/2018/01/12/sonarqube-install/</id>
    <published>2018-01-11T16:00:00.000Z</published>
    <updated>2018-01-11T16:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center><img src="https://www.sonarsource.com/images/common/sonarqube-logo-black.svg"></center>

<blockquote>
<p>open source quality management platform</p>
</blockquote>
<p>이번에 서버를 새로 받으면서 버전업도 하고 설치 순서도 다시 정리해보려한다. 소나큐브란 코드 중복, 유닛 테스트, 복잡고, 코딩 규칙, 취약점등 프로젝트의 품질을 관리할 수 있는 정적 분석 도구이다. 소나큐브에 대한 자세한 내용은 <a href="https://docs.sonarqube.org/display/SONAR/Documentation" rel="external nofollow noopener noreferrer" target="_blank">문서</a>를 참고하자. 공식적이진 않지만, <a href="https://sonarqubekr.atlassian.net/wiki/spaces/SON/overview" rel="external nofollow noopener noreferrer" target="_blank">한국어 문서</a>도 정말 잘 되어 있다👍</p>
<a id="more"></a>
<p><strong>Feature</strong></p>
<ul>
<li>정적 분석 툴(CheckStyle, FindBugs, PMD, …)을 Plug‑in으로 제공</li>
<li>각종 Plug‑in의 결과를 통합해서 직관적인 UI의 Dashboard로 확인</li>
<li>코드 품질 지표를 실시간으로 확인</li>
<li>webhook 제공</li>
<li>프로젝트를 한눈에 보기(관리자를 위한 도구?)</li>
<li>보안성: <a href="https://docs.sonarqube.org/display/SONAR/Security‑related+rules" rel="external nofollow noopener noreferrer" target="_blank">https://docs.sonarqube.org/display/SONAR/Security‑related+rules</a></li>
</ul>
<p><strong>정적분석을 통해 발견되는 결함</strong></p>
<ul>
<li>정의되지 않은 값으로 변수 참조</li>
<li>모듈과 컴포넌트 간에 일관되지 않은 인터페이스</li>
<li>사용되지 않는 변수</li>
<li>사용되지 않는 코드 (Dead Code)</li>
<li>코딩 표준 위반</li>
<li>보안 취약성</li>
<li>코드와 소프트웨어 모델의 syntax 위반</li>
</ul>
<p><strong>Structure</strong></p>
<p><img src="https://docs.sonarqube.org/download/attachments/6961766/SQArchitecture5.5.png?version=1&amp;modificationDate=1459863102000&amp;api=v2" alt="SonarQube Structure"></p>
<p><a href="https://docs.sonarqube.org/display/SONARQUBE56/Architecture+and+Integration" rel="external nofollow noopener noreferrer" target="_blank">https://docs.sonarqube.org/display/SONARQUBE56/Architecture+and+Integration</a></p>
<p><strong>Work Flow</strong></p>
<p><img src="https://docs.sonarqube.org/download/attachments/6961766/SQ55Integration.png?version=1&amp;modificationDate=1459863190000&amp;api=v2" alt="workflow"></p>
<ul>
<li>SonarQube: 분석 결과 관리</li>
<li>SonarQube Scanner: 코드 분석<ul>
<li>CheckStyle: 코딩 룰을 잘 따르고 있는지 분석</li>
<li>FindBugs: 잠재적인 에러 타입 검사</li>
<li>PMD: 미사용 변수, 비어있는 코드 블락, 불필요한 오브젝트 생성과 같은 Defect을 유발할 수 있는 코드를 검사</li>
<li>Junit</li>
</ul>
</li>
</ul>
<h2 id="requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><blockquote>
<p><a href="https://docs.sonarqube.org/display/SONAR/Requirements" rel="external nofollow noopener noreferrer" target="_blank">https://docs.sonarqube.org/display/SONAR/Requirements</a></p>
</blockquote>
<ul>
<li>JAVA 8</li>
<li>DB</li>
</ul>
<h4 id="os-확인"><a href="#OS-확인" class="headerlink" title="OS 확인"></a>OS 확인</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ cat /etc/*-release | uniq</div><div class="line">CentOS release 6.9 (Final)</div><div class="line"><span class="comment">#DO NOT remove/modify this file.</span></div><div class="line">Ncloud 1.1</div><div class="line">IDC=<span class="string">"krlgp"</span></div><div class="line">PRODUCT=<span class="string">"Internal"</span></div><div class="line">SERVICE=<span class="string">"NAVER"</span></div><div class="line">CentOS release 6.9 (Final)</div><div class="line">$ uname -m</div><div class="line">x86_64</div></pre></td></tr></table></figure>
<h4 id="java-설치"><a href="#Java-설치" class="headerlink" title="Java 설치"></a>Java 설치</h4><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" rel="external nofollow noopener noreferrer" target="_blank">여기</a>서 Java 다운로드 링크 복사.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">cd</span></div><div class="line">$ mkdir apps &amp;&amp; <span class="built_in">cd</span> apps</div><div class="line">$ wget --no-cookies --no-check-certificate --header <span class="string">"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie"</span> http://download.oracle.com/otn-pub/java/jdk/8u151-b12/e758a0de34e24606bca991d704f6dcbf/jdk-8u151-linux-x64.tar.gz</div><div class="line">$ tar -xvzf jdk-8u151-linux-x64.tar.gz &amp;&amp; rm jdk-8u151-linux-x64.tar.gz</div><div class="line">$ ln <span class="_">-s</span> ./jdk1.8.0_151/ ~/apps/jdk8</div></pre></td></tr></table></figure>
<p>환경변수 설정.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">"/home1/irteam/apps/jdk8"</span></div><div class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span>"</span></div></pre></td></tr></table></figure>
<p><strong>Reference:</strong></p>
<ul>
<li><a href="https://tecadmin.net/install-java-8-on-centos-rhel-and-fedora/" rel="external nofollow noopener noreferrer" target="_blank">https://tecadmin.net/install-java-8-on-centos-rhel-and-fedora/</a></li>
<li><a href="https://www.linode.com/docs/development/install-java-on-centos" rel="external nofollow noopener noreferrer" target="_blank">https://www.linode.com/docs/development/install-java-on-centos</a></li>
</ul>
<h4 id="mysql-설치"><a href="#MySQL-설치" class="headerlink" title="MySQL 설치"></a>MySQL 설치</h4><p>사내 DB 스크립트로 설치했다.. 그레서 MySQL은 구글링을 통해…🙏</p>
<h2 id="sonarqube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h2><h4 id="install-sonarqube"><a href="#Install-SonarQube" class="headerlink" title="Install SonarQube"></a>Install SonarQube</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/apps/</div><div class="line">$ wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-6.7.zip</div><div class="line">$ unzip sonarqube-6.7.1.zip &amp;&amp; rm sonarqube-6.7.1.zip</div><div class="line">$ ln <span class="_">-s</span> ./sonarqube-6.7.1 ./sonarqube</div></pre></td></tr></table></figure>
<p><strong>Reference:</strong></p>
<ul>
<li><a href="https://www.sonarqube.org/" rel="external nofollow noopener noreferrer" target="_blank">https://www.sonarqube.org/</a></li>
<li><a href="https://docs.sonarqube.org/display/SONAR/Installing+the+Server" rel="external nofollow noopener noreferrer" target="_blank">https://docs.sonarqube.org/display/SONAR/Installing+the+Server</a></li>
</ul>
<h4 id="settings-mysql"><a href="#Settings-MySQL" class="headerlink" title="Settings MySQL"></a>Settings MySQL</h4><p>Create sonar, allow external access.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ mysql -u root</div><div class="line">mysql&gt; use mysql;</div><div class="line">mysql&gt; INSERT INTO user(host,user,authentication_string,ssl_cipher,x509_issuer,x509_subject) VALUES(&apos;%&apos;,&apos;sonar&apos;,password(&apos;sonar&apos;),&apos;&apos;,&apos;&apos;,&apos;&apos;);</div><div class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;sonar&apos;@&apos;%&apos;;</div><div class="line">mysql&gt; FLUSH PRIVILEGES;</div><div class="line">mysql&gt; CREATE DATABASE sonarqube CHARACTER SET utf8 COLLATE utf8_bin;</div></pre></td></tr></table></figure>
<h4 id="settings-sonarqube"><a href="#Settings-SonarQube" class="headerlink" title="Settings SonarQube"></a>Settings SonarQube</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/apps/sonarqube/conf</div><div class="line">vi sonar.properties</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">...</div><div class="line">sonar.jdbc.username=sonar</div><div class="line">sonar.jdbc.password=sonar</div><div class="line">...</div><div class="line">sonar.jdbc.url=jdbc:mysql://localhost:13306/sonarqube?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</div><div class="line">...</div><div class="line">sonar.web.host=10.111.111.11</div><div class="line">sonar.web.port=15001</div></pre></td></tr></table></figure>
<h4 id="run-sonarqube"><a href="#Run-SonarQube" class="headerlink" title="Run SonarQube"></a>Run SonarQube</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cd ~/apps/sonarqube/bin/linux-x86-64</div><div class="line">$ ./sonar.sh start</div></pre></td></tr></table></figure>
<h2 id="result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p><img src="https://user-images.githubusercontent.com/5036939/34835783-3777b054-f739-11e7-8d12-8272cd67b1ea.png" alt="works sonarqube"></p>
<p>(DNS, SSL 설정, 사내 링크, 각종 셋팅을 모두 지우고나니 명령어 몇개 밖에 없고, 이게 가이드인지..😱)</p>
<p>도입하기 전에는 IntelliJ에 <a href="http://findbugs.sourceforge.net/" rel="external nofollow noopener noreferrer" target="_blank">FindBug</a>, <a href="http://checkstyle.sourceforge.net/" rel="external nofollow noopener noreferrer" target="_blank">Checkstyle</a>, <a href="http://junit.org/" rel="external nofollow noopener noreferrer" target="_blank">JUnit</a> 따로따로 실행하고 확인했었는데, <a href="https://github.com/sonar-intellij-plugin/sonar-intellij-plugin" rel="external nofollow noopener noreferrer" target="_blank">SonarQube IntelliJ Community Plugin</a>을 통해 한번에 확인 가능하고, 주니어 입장에서 코드 한줄한줄 리뷰 받는 느낌이다..</p>
<p>앞으로 SonarQube를 통해서… QP(Quality Practice: 소스코드의 정적 분석 결과, 코드 복잡도, 코드 커버리지 개선을 통해 소프트웨어 품질을 높이는 활동)를 신경써보자. 마지막으로 와닿은 말(<a href="https://prezi.com/rv_ce5akpvq6/quality-practice/" rel="external nofollow noopener noreferrer" target="_blank">참고</a>)..</p>
<ul>
<li>QP 활동은 개발자 부담을 늘리기 위한 것이 아닙니다.</li>
<li>QP 도구를 활용해 문제를 사전에 발견해 조치할 수 있습니다.</li>
<li>QP 지수를 통해 현재 품질 상태를 파악할 수 있습니다.</li>
<li>QP를 통해 좋은 품질의 소프트웨어를 만듭시다.</li>
</ul>
<blockquote>
<p><strong>나중은 결코 오지 않는다 ‑ 르블랑의법칙</strong></p>
</blockquote>
<h2 id="references"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://moseskim.github.io/sonarqube/2016/04/18/stop‑planning‑fix‑the‑leak.html" rel="external nofollow noopener noreferrer" target="_blank">http://moseskim.github.io/sonarqube/2016/04/18/stop‑planning‑fix‑the‑leak.html</a></li>
<li>SonarQube in Action PDF ‑ <a href="http://dl.finebook.ir/book/6d/12427.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://dl.finebook.ir/book/6d/12427.pdf</a></li>
<li>SonarQube를 이용한 지속적인 품질 관리 ‑ <a href="http://www.nextree.co.kr/p2963/NHN" rel="external nofollow noopener noreferrer" target="_blank">http://www.nextree.co.kr/p2963/NHN</a></li>
<li><a href="https://www.sw.or.kr/ftp/conference/3_주제_3_Quality Practice 적용사례_NHN.pdf" rel="external nofollow noopener noreferrer" target="_blank">Quality Practice 적용 사례</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;https://www.sonarsource.com/images/common/sonarqube-logo-black.svg&quot;&gt;&lt;/center&gt;

&lt;blockquote&gt;
&lt;p&gt;open source quality management platform&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번에 서버를 새로 받으면서 버전업도 하고 설치 순서도 다시 정리해보려한다. 소나큐브란 코드 중복, 유닛 테스트, 복잡고, 코딩 규칙, 취약점등 프로젝트의 품질을 관리할 수 있는 정적 분석 도구이다. 소나큐브에 대한 자세한 내용은 &lt;a href=&quot;https://docs.sonarqube.org/display/SONAR/Documentation&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;문서&lt;/a&gt;를 참고하자. 공식적이진 않지만, &lt;a href=&quot;https://sonarqubekr.atlassian.net/wiki/spaces/SON/overview&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;한국어 문서&lt;/a&gt;도 정말 잘 되어 있다👍&lt;/p&gt;
    
    </summary>
    
    
      <category term="sonarqube" scheme="https://wickso.me/tags/sonarqube/"/>
    
      <category term="quality" scheme="https://wickso.me/tags/quality/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 9장. 예외 - 3</title>
    <link href="https://wickso.me/2017/12/28/exceptions-3/"/>
    <id>https://wickso.me/2017/12/28/exceptions-3/</id>
    <published>2017-12-28T01:30:00.000Z</published>
    <updated>2017-12-28T01:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/12/28/exceptions-3/#63-어떤-오류인지를-드러내는-정보를-상세한-메시지에-담으라">규칙 63</a> - 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라<br><a href="../../../../2017/12/28/exceptions-3/#64-실패-원자성-달성을-위해-노력하라">규칙 64</a> - 실패 원자성 달성을 위해 노력하라<br><a href="../../../../2017/12/28/exceptions-3/#65-예외를-무시하지-마라">규칙 65</a> - 예외를 무시하지 마라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="63-어떤-오류인지를-드러내는-정보를-상세한-메시지에-담으라"><a href="#63-어떤-오류인지를-드러내는-정보를-상세한-메시지에-담으라" class="headerlink" title="63. 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라"></a>63. 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라</h2><ul>
<li>오류 정보를 포착해 내기 위해서는, 오류의 상세 메시지(e.g. <code>toString()</code>)에 “예외에 관계된” 모든 인자와 필드의 값을 포함시켜야 한다.</li>
<li>오류 포착에 필요한 상세한 정보를 요구하는 생성자를 만드는 숙어를 추천한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">IndexOutOfBoundsException</span><span class="params">(<span class="keyword">int</span> lowerBound, <span class="keyword">int</span> upperBound, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(<span class="string">"Lower bound: "</span> + lowerBound + <span class="string">", Upper bound: "</span> + upperBound + <span class="string">", Index: "</span> + index);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="64-실패-원자성-달성을-위해-노력하라"><a href="#64-실패-원자성-달성을-위해-노력하라" class="headerlink" title="64. 실패 원자성 달성을 위해 노력하라"></a>64. 실패 원자성 달성을 위해 노력하라</h2><blockquote>
<ul>
<li>예외를 던지고 난 뒤에도 객체의 상태가 잘 정의된, 사용 가능한 상태로 남아있으면 좋다 =&gt; 실패원자성(failuer atomicity)</li>
<li>실패 원자성은 일반적으로 권장되는 덕목이지만 언제나 달성할 수 있는 것은 아니다. (e.g. 여러 스레드에서 동기화 없이 동시에 변경할 경우)</li>
</ul>
</blockquote>
<p><strong>실패원자성을 달성하는 방법들</strong></p>
<ul>
<li>변경 불가능한 객체로 설계</li>
<li>실패할 가능성있는 코드를 객체 상태를 바꾸는 코드 앞에 배치</li>
<li>연산 수행 도중에 발생하는 오류를 가로채는 복구 코드(recovery code) 작성</li>
<li>객체의 임시 복사본상에서 필요한 연산을 수행하고, 연산이 끝난 다음 복사본의 내용으로 객체 상태를 변경</li>
</ul>
<hr>
<h2 id="65-예외를-무시하지-마라"><a href="#65-예외를-무시하지-마라" class="headerlink" title="65. 예외를 무시하지 마라"></a>65. 예외를 무시하지 마라</h2><ul>
<li>적어도 catch 블록 안에는 예외를 무시해도 괜찮은 이유라도 주석으로 남겨 두어야 한다.</li>
<li>PMD: <a href="http://pmd.sourceforge.net/pmd-4.3.0/rules/basic.html" rel="external nofollow noopener noreferrer" target="_blank">EmptyCatchBlock</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/12/28/exceptions-3/#63-어떤-오류인지를-드러내는-정보를-상세한-메시지에-담으라&quot;&gt;규칙 63&lt;/a&gt; - 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라&lt;br&gt;&lt;a href=&quot;../../../../2017/12/28/exceptions-3/#64-실패-원자성-달성을-위해-노력하라&quot;&gt;규칙 64&lt;/a&gt; - 실패 원자성 달성을 위해 노력하라&lt;br&gt;&lt;a href=&quot;../../../../2017/12/28/exceptions-3/#65-예외를-무시하지-마라&quot;&gt;규칙 65&lt;/a&gt; - 예외를 무시하지 마라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 9장. 예외 - 2</title>
    <link href="https://wickso.me/2017/11/19/exceptions-2/"/>
    <id>https://wickso.me/2017/11/19/exceptions-2/</id>
    <published>2017-11-19T12:00:00.000Z</published>
    <updated>2017-11-19T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/11/19/exceptions-2/#60-표준-예외를-사용하라">규칙 60</a> - 표준 예외를 사용하라<br><a href="../../../../2017/11/19/exceptions-2/#61-추상화-수준에-맞는-예외를-던져라">규칙 61</a> - 추상화 수준에 맞는 예외를 던져라<br><a href="../../../../2017/11/19/exceptions-2/#62-메서드에서-던져지는-모든-예외에-대해-문서를-남겨라">규칙 62</a> - 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="60-표준-예외를-사용하라"><a href="#60-표준-예외를-사용하라" class="headerlink" title="60. 표준 예외를 사용하라"></a>60. 표준 예외를 사용하라</h2><h4 id="이미-있는-예외들을-재사용하면-좋은-점"><a href="#이미-있는-예외들을-재사용하면-좋은-점" class="headerlink" title="이미 있는 예외들을 재사용하면 좋은 점"></a>이미 있는 예외들을 재사용하면 좋은 점</h4><ul>
<li>배우기 쉽고, 사용하기 편리한 API를 만들 수 있다(관습)</li>
<li>가독성이 높다</li>
<li>예외 클래스 갯수를 줄이면 프로그램의 메모리 요구량이 줄어들고, 클래스를 로딩하는 시간도 줄어든다</li>
</ul>
<h4 id="널리-재사용되는-예외"><a href="#널리-재사용되는-예외" class="headerlink" title="널리 재사용되는 예외"></a>널리 재사용되는 예외</h4><blockquote>
<p><strong>재사용 할 수 있는 예외라 생각된다면 사용하도록 하라.</strong> 하지만 예외를 발생시키는 조건이 해당 예외의 문서에 기술된 것과 일치해야 한다. 이름만 보고 재사용하면 곤란하며, 의미적으로도 재사용이 가능해야 한다.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Excpetion</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>IllegalArgumentException</td>
<td>null이 아닌 인자의 값이 잘못되었을 때<br>(e.g. 어떤 동작의 실행 횟수를 나타내는 인자에 음수가 전달되었을 때)</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>객체 상태가 메서드 호출을 처리하기에 적절치 않을 때<br>(e.g. 아직 적절히 초기화되지 않은 객체를 사용하려고 시도할 때)</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>null 값을 받으면 안 되는 인사에 null이 전달되었을 때</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>인자로 주어진 첨자가 허용 범위를 벗어났을 때</td>
</tr>
<tr>
<td>ConcurrentModificationException</td>
<td>병렬적 사용이 금지된 객체에 대한 병렬 접근이 탐지되었을 때</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>객체가 해당 메서드를 지원하지 않을 때<br>(e.g. 객체를 추가하는 것만 가능한 리스트에서 원소를 삭제하려고 할 때)</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="61-추상화-수준에-맞는-예외를-던져라"><a href="#61-추상화-수준에-맞는-예외를-던져라" class="headerlink" title="61. 추상화 수준에 맞는 예외를 던져라"></a>61. 추상화 수준에 맞는 예외를 던져라</h2><ul>
<li><strong>상위 계층에서는 하위 계층에서 발생하는 예외를 반드시 받아서 상위 계층 추상화 수준에 맞는 예외로 바꿔서 던져야 한다.</strong> == 예외 변환(exception translation)</li>
<li>가장 좋은 방법은 하위 계층에서 예외가 안생기는 것.</li>
<li>어쩔수 없다면 격리 시킬 것, 나중에 분석에 용이하도록 로그를 남기고 최종 사용자에게는 예외를 감춘다.</li>
</ul>
<hr>
<h2 id="62-메서드에서-던져지는-모든-예외에-대해-문서를-남겨라"><a href="#62-메서드에서-던져지는-모든-예외에-대해-문서를-남겨라" class="headerlink" title="62. 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라"></a>62. 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라</h2><ul>
<li>점검지정 예외는 독립적으로 선언하고, 해당 예외가 발생하는 상황은 Javadoc <code>@throws</code> 태그를 사용해서 정확하게 밝혀라.</li>
<li>무점검 예외도 <code>@throws</code> 태그를 이용하며 문서를 남겨라. 하지만 메서드 선언부의 throws 뒤에 무점검 예외를 나열하진 마라.</li>
<li>같은 이유로 동일한 예외를 던지는 메서드가 많다면, 메서드마다 문서를 만드는 대신, 해당 예외에 대한 문서는 클래스의 문서화 주석에 남겨도 된다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/11/19/exceptions-2/#60-표준-예외를-사용하라&quot;&gt;규칙 60&lt;/a&gt; - 표준 예외를 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/11/19/exceptions-2/#61-추상화-수준에-맞는-예외를-던져라&quot;&gt;규칙 61&lt;/a&gt; - 추상화 수준에 맞는 예외를 던져라&lt;br&gt;&lt;a href=&quot;../../../../2017/11/19/exceptions-2/#62-메서드에서-던져지는-모든-예외에-대해-문서를-남겨라&quot;&gt;규칙 62&lt;/a&gt; - 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 9장. 예외 - 1</title>
    <link href="https://wickso.me/2017/11/05/exceptions-1/"/>
    <id>https://wickso.me/2017/11/05/exceptions-1/</id>
    <published>2017-11-05T09:00:00.000Z</published>
    <updated>2017-11-05T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/11/05/exceptions-1/#57-예외는-예외적-상황에만-사용하라">규칙 57</a> - 예외는 예외적 상황에만 사용하라<br><a href="../../../../2017/11/05/exceptions-1/#58-복구-가능-상태에는-점검지정-예외를-사용하고-프로그래밍-오류에는-실행시점-예외를-이용하라">규칙 58</a> - 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라<br><a href="../../../../2017/11/05/exceptions-1/#59-불필요한-점검지정-예외-사용은-피하라">규칙 59</a> - 불필요한 점검지정 예외 사용은 피하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="57-예외는-예외적-상황에만-사용하라"><a href="#57-예외는-예외적-상황에만-사용하라" class="headerlink" title="57. 예외는 예외적 상황에만 사용하라"></a>57. 예외는 예외적 상황에만 사용하라</h2><h4 id="예외는-예외적인-상황에만-사용하라-평상시-제어-흐름ordinary-control-flow에-이용해서는-안된다"><a href="#예외는-예외적인-상황에만-사용하라-평상시-제어-흐름-ordinary-control-flow-에-이용해서는-안된다" class="headerlink" title="예외는 예외적인 상황에만 사용하라. 평상시 제어 흐름(ordinary control flow)에 이용해서는 안된다."></a><strong>예외는 예외적인 상황에만 사용하라.</strong> 평상시 제어 흐름(ordinary control flow)에 이용해서는 안된다.</h4><ul>
<li>예외는 예외적 상황을 위해 고안된 것이기 때문에, JVM을 구현하는 사람 입장에서 보면 명시적 테스트만큼 빠르게 만들 이유가 별로 없다.</li>
<li>쉽게 이해할 수 있는 표준적인 숙어대로 코딩해야지, 더 좋은 성능을 내 보려고 너무 머리를 많이 굴리면 곤란하다는 것이다.</li>
<li>너무 머리를 많이 굴린 기법일수록 묘한 버그가 생길 가능성이 높고 유지보수 때문에 골치 아플 일도 많은 법.</li>
</ul>
<h4 id="클라이언트에게-제어-흐름의-일부로-예외를-사용하도록-강요하는-api를-만들지-말아라"><a href="#클라이언트에게-제어-흐름의-일부로-예외를-사용하도록-강요하는-API를-만들지-말아라" class="headerlink" title="클라이언트에게 제어 흐름의 일부로 예외를 사용하도록 강요하는 API를 만들지 말아라."></a>클라이언트에게 제어 흐름의 일부로 <strong>예외를 사용하도록 강요하는 API를 만들지 말아라.</strong></h4><ul>
<li><p>특정한 예측 불가능 조건이 만족될 때만 호출할 수 있는 “상태 종속적(state-dependent)” 메서드를 가진 클래스에는 보통 해당 메서드를 호출해도 되는지를 알기 위한 <strong>“상태 검사(state-testing)”</strong> 메서드가 별도로 갖춰져 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (Iterator&lt;Foo&gt; i = collection.iterator(); i.hasNext(); ) &#123;</div><div class="line">  Foo foo = i.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em><code>i.hasNexe()</code>와 같은 상태 검사 메서드가 없을 경우</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  Iterator&lt;Foo&gt; i = collection.iterator();</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    Foo foo = i.next();</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>상태 검사 메서드를 제공하기 싫다면 부적절한 상태의 객체에 상태 종속적 메서드를 호출하면 null 같은 <strong>특이값(distinguished value)이 반환</strong>되도록 구현하는 방법도 있다.<br><code>Iterator</code>에서 <code>null</code>은 <code>next()</code>의 정상적 반환값일 수 있기 때문에 사용할 수 없다.</p>
</li>
<li><p><strong>특이값 방식</strong></p>
<p>외부적인 동기화 메커니즘 없이 병렬적으로 사용될 수 있는 객체거나, 외부적인 요인으로 상태 변화가 일어날 수 있는 객체라면 반드시 특이값 방식으로 구현. (상태 검사 메서드를 호출한 다음 상태 종속적 메서드를 호출하기까지의 시간 동안 객체 상태가 변할 수 있기 때문)</p>
<p>상태 종속적 메서드가 하는 일을 상태 검사 메서드가 중복해서 하는 바람에 성능이 떨어질까 우려될 경우.</p>
</li>
<li><p><strong>상태 검사 메서드</strong></p>
<p>다른 모든 조건이 동일하다면 상태 검사 메서드를 두는 편이 대체로 바람직. 가독성 측면에서도 조금 더 낫고, API를 잘못 이용하는 경우도 쉽게 찾아낼 수 있기 때문.</p>
<p>상태 검사 메서드를 실수로 호출하지 않으면 상태 종속적 메서드에서 예외가 발생하니까 버그가 분명하게 드러난다.</p>
<p>실수로 특이값 검사를 생략하는 버그는 찾기 어려울 수 있다.(null 체크를 안할 경우?)</p>
</li>
</ul>
<hr>
<h2 id="58-복구-가능-상태에는-점검지정-예외를-사용하고-프로그래밍-오류에는-실행시점-예외를-이용하라"><a href="#58-복구-가능-상태에는-점검지정-예외를-사용하고-프로그래밍-오류에는-실행시점-예외를-이용하라" class="headerlink" title="58. 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라"></a>58. 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라</h2><p><strong>핵심</strong></p>
<blockquote>
<p> 복구 가능한 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류를 나타내고 싶을 때는 실행지점 예외를 사용하라.</p>
<p> 잘 모르겠다면 무점검 예외를 이용하는 편이 나을 것이다(규칙 59).</p>
</blockquote>
<p><strong>Java는 세 가지 종류의 throwable을 제공한다.</strong></p>
<blockquote>
<p>점검지정 예외(checked exception), 실행시점 예외(runtime exception), 오류(error)</p>
</blockquote>
<p>무엇을 사용해야 하는지 딱 떨어지는 기준이 있는 것은 아니지만, 훌륭한 지침으로 삼을 만한 일반 규칙이 있다.</p>
<p><strong>호출자(caller) 측에서 복구할 것으로 여겨지는 상황에 대해서는 <em>점검지정 예외</em>를 이용해야 한다.</strong></p>
<ul>
<li><p>점검지정 예외를 사용할 것인지 무점검 예외(unchecked exception)를 사용할 것인지에 대한 가장 기본적인 규칙</p>
</li>
<li><p>메서드에 선언된 점검지정 예외는 메서드를 호출하면 해당 예외와 관련된 상황이 발생할 수 있음을 API 사용자에게 알리는 구실을 한다.</p>
<p>API 사용자에게 검점지정 예외를 준다는 것은, 그 상태를 복구할 권한을 준다는 뜻.<br>사용자는 그 권한을 무시할 수 있지만 일반적으로 그렇게 하면 곤란하다(규칙 65, 예외를 무시하지 마라).</p>
</li>
<li><p>점검지정 예외는 일반적으로 복구 가능한 상태를 나타내기 때문에, 호출자 측에서 상태를 복구하는 데 이용할 정보를 제공하는 메서드를 갖춰놓는 것이 아주 중요하다.</p>
</li>
</ul>
<p><strong>프로그래밍 오류를 표현할 때는 <em>실행시점 예외</em>를 사용하라.</strong></p>
<ul>
<li><p>대부분의 런타임 예외는 선행조건 위반(precondition violation)을 나타낸다.</p>
<p>클라이언트가 API 명세에 기술된 규악을 지키지 않았다는 뜻. (e.g. <code>ArrayIndexOutOfBoundsException</code>)</p>
</li>
</ul>
<p><strong>사용자 정의 무점검 throwable은 RuntimeException의 하위 클래스로 만들어야 한다.</strong></p>
<ul>
<li><p>자바 언어 명세에 강제된 사항은 아니지만, 보통 오류(error)는 JVM이 자원 부족이나 불변식 위한 등, 더 이상 프로그램을 실행할 수 없는 상태에 도달했음을 알리기 위해 사용.</p>
<p>이 관습은 거의 보편적으로 받아들여지고 있어서, Error의 하위 클래스는 새로 만들지 않는 것이 최선이다.</p>
</li>
<li><p>예외를 만들 경우, 예외 정보 문자열을 파싱하는 것은 위험한 방법이다(규칙 10). 객체가 어떤 형식의 문자열로 변환되는지 상세히 명시하는 클래스는 별로 없다. 따라서 문자열 변환 결과는 구현마다, 그리고 릴리스마다 달라질 수 있기 때문에 <em>예외를 문자열로 나타낸 결과를 파싱하는 코드는 이식성도 없고 깨지기도 쉽다.</em></p>
</li>
</ul>
<hr>
<h2 id="59-불필요한-점검지정-예외-사용은-피하라"><a href="#59-불필요한-점검지정-예외-사용은-피하라" class="headerlink" title="59. 불필요한 점검지정 예외 사용은 피하라"></a>59. 불필요한 점검지정 예외 사용은 피하라</h2><p>점검지정 예외는 프로그래머 하여금 예외적인 상황을 처리하도록 장제함으로써 안정성을 높인다.</p>
<p>아래 경우에 해당하지 않을 경우 무점검 예외를 이용하는 것이 좋다.</p>
<ul>
<li>API를 제대로 이용해도 예외 상황이 벌어지는 것을 막을 수 없을 때</li>
<li>API 사용자가 예외상황에 대한 조치를 취할 수 있을 때</li>
</ul>
<p>API 사용자가 이보다 좋은 코드를 만들 수 없다면, 무점검 예외가 적당하다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&#125; <span class="keyword">catch</span> (TheCheckedException e) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&#125; <span class="keyword">catch</span> (TheCheckedException e) &#123;</div><div class="line">  e.printStackTrace();</div><div class="line">  System.exit(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>메서드가 던지는 예외가 하나뿐일 경우, 점검지정 예외를 없앨 방법이 없을지 고민해보는 것이 좋다.</p>
<ul>
<li><p>예외를 던지는 메서드를 둘로 나눠서 첫 번째 메서드가 boolean값을 반환 하도록 만드는 것</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* as-is */</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  obj.action(args);</div><div class="line">&#125; <span class="keyword">catch</span> (TheCheckedException e) &#123;</div><div class="line">  <span class="comment">// 예외적 상황 처리</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* to-be: 상태 검사 메서드를 거쳐서 무점검 예외 메서드를 호출 */</span></div><div class="line"><span class="keyword">if</span> (obj.actionPermitted(args)) &#123;</div><div class="line">  obj.action(args);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 예외적 상황 처리</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>결과적으로 만들어지는 API는 규칙 57에서 설명한 상태 검사 메서드와 본질적으로 같기 때문에, 동일한 문제를 갖는다.<br>그러므로, 외부적인 동기화 수단 없이 병렬적으로 이용될 가능성이 있는 객체거나, 외부에서 그 상태를 바꿀 가능성이 있는 객체라면 위의 리팩토링 기법은 적용할 수 없다.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/11/05/exceptions-1/#57-예외는-예외적-상황에만-사용하라&quot;&gt;규칙 57&lt;/a&gt; - 예외는 예외적 상황에만 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/11/05/exceptions-1/#58-복구-가능-상태에는-점검지정-예외를-사용하고-프로그래밍-오류에는-실행시점-예외를-이용하라&quot;&gt;규칙 58&lt;/a&gt; - 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/11/05/exceptions-1/#59-불필요한-점검지정-예외-사용은-피하라&quot;&gt;규칙 59&lt;/a&gt; - 불필요한 점검지정 예외 사용은 피하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 8장. 일반적인 프로그래밍 원칙들 - 4</title>
    <link href="https://wickso.me/2017/11/01/general-programming-4/"/>
    <id>https://wickso.me/2017/11/01/general-programming-4/</id>
    <published>2017-11-01T14:13:00.000Z</published>
    <updated>2017-11-11T10:45:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/11/01/general-programming-4/#54-네이티브-메서드는-신중하게-사용하라">규칙 54</a> - 네이티브 메서드는 신중하게 사용하라<br><a href="../../../../2017/11/01/general-programming-4/#55-신중하게-최적화하라">규칙 55</a> - 신중하게 최적화하라<br><a href="../../../../2017/11/01/general-programming-4/#56-일반적으로-통용되는-작명-관습을-따르라라">규칙 56</a> - 일반적으로 통용되는 작명 관습을 따르라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="54-네이티브-메서드는-신중하게-사용하라"><a href="#54-네이티브-메서드는-신중하게-사용하라" class="headerlink" title="54. 네이티브 메서드는 신중하게 사용하라"></a>54. 네이티브 메서드는 신중하게 사용하라</h2><blockquote>
<p>JNI(Java native interface): C나 C++ 등의 네이티브 프로그래밍 언어로 작성된 네이티브 메서드를 호출하는 데 이용되는 기능.</p>
</blockquote>
<p>전통적으로 네이티브 메서드는 세 가지 용도로 쓰였다.</p>
<ol>
<li>레지스트리나 파일 락 같은 특정 플랫폼에 고유한 기능 이용 가능</li>
<li>이미 구현되어 있는 라이브러리 이용 가능</li>
<li>성능이 중요한 부분의 처리를 네이티브 언어로 처리 가능</li>
</ol>
<p>하지만 자바 플렛폼이 발전하면서 자바로 대체 가능</p>
<ol>
<li>java.util.prefs를 이용하면 레지스트리 기능 이용 가능(java 1.4)</li>
<li>java.awt.SystemTray를 사용하면 시스템 트레이 영역 이용 가능(java 1.6)</li>
</ol>
<h4 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h4><p>네이티브 메서드를 통해 성능을 개선하는 것은 추천하고 싶지 않다.</p>
<ul>
<li>자바 발전에 따라 그에 필적하는 성능을 낸다</li>
<li>네이티브 언어는 안전하지 않다(규칙 39). 메모리 훼손 문제로부터 자유로울 수 없다</li>
<li>종속적이다</li>
<li>디버깅이 어렵다</li>
</ul>
<hr>
<h2 id="55-신중하게-최적화하라"><a href="#55-신중하게-최적화하라" class="headerlink" title="55. 신중하게 최적화하라"></a>55. 신중하게 최적화하라</h2><p>최적화 관련 격언(자바 언어가 나오기 20년 전에 나온 것들)</p>
<blockquote><p>맹목적인 어리석음(blind stupidity)을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다(효율성을 반드시 성취하는 것도 아니면서 말이다).</p>
<footer><strong>윌리엄 울프(William A. Wulf)</strong></footer></blockquote>
<blockquote><p>작은 효율성(small effciency)에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화(premature optimization)는 모든 악의 근원이다.</p>
<footer><strong>도널드 커누스(Donald E. Knuth)</strong></footer></blockquote>
<blockquote><p>최적화를 할 때는 아래의 두 규칙을 따르라.<br>규칙 1: 하지 마라.<br>규칙 2: (전문가들만 따를 것)아직은 하지 마라 - 완벽히 명료한, 최적화되지 않은 해답을 얻을 때까지는.</p>
<footer><strong>M.A. 잭슨(M. A. Jackson)</strong></footer></blockquote>
<h4 id="핵심"><a href="#핵심" class="headerlink" title="핵심"></a>핵심</h4><ul>
<li><p>빠른 프로그램이 아닌, 좋은 프로그램을 만들려 노력하라.</p>
<p>  좋은 프로그램은 정보 은닉 원칙을 지킨다. 따라서 그 설계는 시스템의 다른 부분에는 영향을 주지 않으면서 독립적으로 변경될 수 있다.</p>
</li>
<li><p>설계를 할 때는 성능을 제약할 가능성이 있는 결정들은 피하라.</p>
<p>  고치기 가장 까다로운 부분이 모듈 간 상호작용이나 외부와의 상호작용을 명시하는 부분. API, 통신 프로토콜 등</p>
</li>
<li><p>API를 설계할 때 내리는 결정들이 성능에 어떤 영향을 끼칠지를 생각하라.</p>
<ul>
<li>변경 가능한 자료형을 만들면 쓸데없이 방어적 복사를 많이 할 수 있다.(규칙 39)</li>
<li>compotision이 적절한 곳에 inheritance를 하지 말아라(규칙 16).</li>
<li>인터페이스가 적절한 곳에 구현 자료형을 사용하지 말아라(규칙 52).</li>
</ul>
</li>
<li><p>좋은 성능을 내기 위해 API를 급진적으로 바꾸는 것은 바람직하지 않다.</p>
</li>
<li>최적화를 시도할 때마다, 전후 성능을 측정하고 비교하라.<ul>
<li>자바는 강력한 성능 모델이 없으며, 다양한 환경, 설정에 따라 성능이 다르다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="56-일반적으로-통용되는-작명-관습을-따르라"><a href="#56-일반적으로-통용되는-작명-관습을-따르라" class="headerlink" title="56. 일반적으로 통용되는 작명 관습을 따르라"></a>56. 일반적으로 통용되는 작명 관습을 따르라</h2><blockquote>
<p>The Java Language Specification[JSL, 6.8]에도 언급되어 있듯이, 작명 관습이 잘 정립되어 있다.</p>
</blockquote>
<h4 id="철자"><a href="#철자" class="headerlink" title="철자"></a>철자</h4><p><strong>Package</strong></p>
<ul>
<li>알파벳 소문자</li>
<li>숫자는 거의 사용하지 않음</li>
<li>인터넷 도메인으로 시작(예외적으로, 표준 라이브러리와 그 옵션 패키지 명은 java와 javax로 시작)</li>
<li>패키지명 컴포넌트는 짧아야하며, 보통 8문자 이하도 만듦(하나의 단어 또는 약어)</li>
<li>의미가 확실한 약어 활용(e.g. utilities -&gt; util)</li>
</ul>
<p><strong>Enum, Annotation, Class, Interface</strong></p>
<ul>
<li>하나 이상의 단어</li>
<li>첫글자 대문자</li>
<li>널리 쓰는 약어(e.g. max, min)외에 다른 약어는 사용을 피함</li>
</ul>
<p><strong>Method, Field</strong></p>
<ul>
<li>Class와 규칙 같음, 다만 첫글자 소문자</li>
<li>상수는 대문자와 단어 사이에 <code>_</code></li>
</ul>
<p><strong>Local variable</strong></p>
<ul>
<li>Filed와 동일</li>
<li>약어 허용</li>
</ul>
<p><strong>Generic type</strong></p>
<ul>
<li>대문자</li>
<li>임의 자료형: <code>T</code></li>
<li>컬렉션의 요소 자료형: <code>E</code></li>
<li>맵의 키와 값: <code>K</code>, ‘V’</li>
<li>예외: <code>X</code></li>
<li>임의 자료형이 연속되는 경우: <code>T</code>, <code>U</code>, <code>V</code> 혹은 <code>T1</code>, <code>T2</code>, <code>T3</code></li>
</ul>
<h4 id="문법"><a href="#문법" class="headerlink" title="문법"></a>문법</h4><p><strong>Package</strong></p>
<ul>
<li>굳이 없음</li>
</ul>
<p><strong>Enum, Class</strong></p>
<ul>
<li>단수형의 명사, 명사구</li>
</ul>
<p><strong>Interface</strong></p>
<ul>
<li>Class와 동일</li>
<li><code>-able</code>, <code>-ible</code> 같은 형용사격 어미가 붙기도 함(e.g. <code>Runnable</code>, <code>Iterable</code>)</li>
</ul>
<p><strong>Annotation</strong></p>
<ul>
<li>명사, 동사, 전치사, 형용사 어느것이나 널리 사용</li>
</ul>
<p><strong>Method</strong></p>
<ul>
<li>동사, 동사구(e.g. <code>append</code>)</li>
<li>boolean을 반환하는 메서드는 보통 <code>is-</code>, (드물게)<code>has-</code>(e.g. <code>isEmpty</code>, <code>isDigit</code>)</li>
<li>기능이나 객체 속성을 반환하는 메서드는 명사, 명사구, <code>get-</code>(e.g. <code>size()</code>, <code>hasCode</code>)</li>
<li>Bean 클래스에 속한 메서드는 getter(<code>get-</code>), setter(<code>set-</code>)</li>
<li>객체의 자료형을 반환하거나 다른 자료형의 독립적 객체는 반환하는 경우 <code>toType</code>(e.g. <code>toString</code>, <code>toArray</code>)</li>
<li>인자로 전달받은 객체와 다른 다료형의 뷰(view) 객체를 반환하는 메서드의 경우 <code>asType</code>(e.g. <code>asList</code>)</li>
<li>호출 대상 각체와 동일한 기본 자료형 값을 반환하는 메서드의 경우 <code>typeValue</code>(e.g. <code>intValue</code>)</li>
<li>정적 팩터리 메서드는 <code>valueOf</code>, <code>of</code>, <code>getInstance</code>, <code>newInstance</code>, <code>getType</code>, <code>newType</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/11/01/general-programming-4/#54-네이티브-메서드는-신중하게-사용하라&quot;&gt;규칙 54&lt;/a&gt; - 네이티브 메서드는 신중하게 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/11/01/general-programming-4/#55-신중하게-최적화하라&quot;&gt;규칙 55&lt;/a&gt; - 신중하게 최적화하라&lt;br&gt;&lt;a href=&quot;../../../../2017/11/01/general-programming-4/#56-일반적으로-통용되는-작명-관습을-따르라라&quot;&gt;규칙 56&lt;/a&gt; - 일반적으로 통용되는 작명 관습을 따르라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 8장. 일반적인 프로그래밍 원칙들 - 3</title>
    <link href="https://wickso.me/2017/10/27/general-programming-3/"/>
    <id>https://wickso.me/2017/10/27/general-programming-3/</id>
    <published>2017-10-27T01:50:00.000Z</published>
    <updated>2017-11-05T07:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/10/27/general-programming-3/#51-문자열-연결-시-성능에-주의하라">규칙 51</a> - 문자열 연결 시 성능에 주의하라<br><a href="../../../../2017/10/27/general-programming-3/#52-객체를-참조할-때는-그-인터페이스를-사용하라">규칙 52</a> - 객체를 참조할 때는 그 인터페이스를 사용하라<br><a href="../../../../2017/10/27/general-programming-3/#53-리플렉션-대신-인터페이스를-이용하라">규칙 53</a> - 리플렉션 대신 인터페이스를 이용하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="51-문자열-연결-시-성능에-주의하라"><a href="#51-문자열-연결-시-성능에-주의하라" class="headerlink" title="51. 문자열 연결 시 성능에 주의하라"></a>51. 문자열 연결 시 성능에 주의하라</h2><ul>
<li>문자열을 연결할 때는 <code>String</code>보다 <code>StringBuilder</code>의 <code>append()</code>를 사용하라.</li>
<li>n개의 문자열에 연결 연산자를 반복 적용해서 연결하는 데 드는 시간은 n<sup>2</sup>에 비례한다 - 문자열은 변경 불가능하기 때문(규칙 15)</li>
<li><a href="http://www.pellegrino.link/2015/08/22/string-concatenation-with-java-8.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.pellegrino.link/2015/08/22/string-concatenation-with-java-8.html</a></li>
</ul>
<hr>
<h2 id="52-객체를-참조할-때는-그-인터페이스를-사용하라"><a href="#52-객체를-참조할-때는-그-인터페이스를-사용하라" class="headerlink" title="52. 객체를 참조할 때는 그 인터페이스를 사용하라"></a>52. 객체를 참조할 때는 그 인터페이스를 사용하라</h2><ul>
<li>적당한 인터페이스나 자료형이 있다면 Parameter, Return value, Variable, Field의 자료형은 클래스 대신 인터페이스로 선언하자.</li>
<li>인터페이스를 자료형으로 쓰는 습관을 들이면 프로그램은 더욱 유연해진다.<ul>
<li>구현체를 변경할 경우, 인터페이스의 일반 규약에 없는 특별한 기능을 제공하고 있었고, 그것을 코드에서 사용하고 있었다면 새로운 구현체에도 같은 기능을 제공해야 한다.</li>
<li>특별한 기능을 이용하도록 코드를 작성했다면, 변수를 선언할 때 그 사실을 주석으로 남겨야 한다.</li>
</ul>
</li>
<li>적당한 인터페이스가 없는 경우에는 객체를 클래스로 참조하는 것이 당연하다.</li>
<li>클래스 기반 프레임워크(class-based framework)에 속한 객체는, 구현 클래스 대신에 보통 abstract인 기반 클래스(base class)로 참조하는 것이 바람직하다(e.g. java.util.TimerTask).</li>
</ul>
<hr>
<h2 id="53-리플렉션-대신-인터페이스를-이용하라"><a href="#53-리플렉션-대신-인터페이스를-이용하라" class="headerlink" title="53. 리플렉션 대신 인터페이스를 이용하라"></a>53. 리플렉션 대신 인터페이스를 이용하라</h2><h4 id="리플렉션의-단점"><a href="#리플렉션의-단점" class="headerlink" title="리플렉션의 단점"></a>리플렉션의 단점</h4><ul>
<li>type checking, exception checking 불가능</li>
<li>가독성 떨어짐</li>
<li>성능이 떨어짐</li>
</ul>
<h4 id="핵심"><a href="#핵심" class="headerlink" title="핵심"></a>핵심</h4><ul>
<li>객체 생성은 리플렉션으로 하고 객체 참조는 인터페이스나 상위클래스를 통하라</li>
<li>일반적인 프로그램은 런타임중에 리플렉션을 통해 객체를 이용하려 하지말아라.</li>
<li>NoArgsConstructor를 호출할때는 java.lang.relect를 이용할 필요도 없다. Class.newInstance()를 호출하는 것으로 충분하다.</li>
<li>리플렉션을 아주 제한적으로만 사용하면 오버헤드는 피하면서도 리플렉션의 다양한 장점을 누릴 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; cl = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        cl = Class.forName(args[<span class="number">0</span>]);</div><div class="line">    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</div><div class="line">        System.err.println(“Class not found.”);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Set&lt;String&gt; s = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        s = (Set&lt;String&gt;) cl.newInstance();</div><div class="line">    &#125; <span class="keyword">catch</span>(IllegalAccessException | InstantiationException a) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    s.addAll(Arrays.asList(args).subList(<span class="number">1</span>, args.length));</div><div class="line">    System.out.println(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>객체 사용은 인터페이스인 Set을 사용하고, 객체는 리플렉션으로 생성한다.</li>
<li>Set의 구현체에 따라 정렬을 달리 사용할 수 있다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/10/27/general-programming-3/#51-문자열-연결-시-성능에-주의하라&quot;&gt;규칙 51&lt;/a&gt; - 문자열 연결 시 성능에 주의하라&lt;br&gt;&lt;a href=&quot;../../../../2017/10/27/general-programming-3/#52-객체를-참조할-때는-그-인터페이스를-사용하라&quot;&gt;규칙 52&lt;/a&gt; - 객체를 참조할 때는 그 인터페이스를 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/10/27/general-programming-3/#53-리플렉션-대신-인터페이스를-이용하라&quot;&gt;규칙 53&lt;/a&gt; - 리플렉션 대신 인터페이스를 이용하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 8장. 일반적인 프로그래밍 원칙들 - 2</title>
    <link href="https://wickso.me/2017/10/09/general-programming-2/"/>
    <id>https://wickso.me/2017/10/09/general-programming-2/</id>
    <published>2017-10-09T09:56:00.000Z</published>
    <updated>2017-10-09T11:42:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/10/09/general-programming-2/#48-정확한-답이-필요하다면-float와-double은-피하라">규칙 48</a> - 정확한 답이 필요하다면 float와 double은 피하라<br><a href="../../../../2017/10/09/general-programming-2/#49-객체화된-기본-자료형-대신-기본-자료형을-이용하라">규칙 49</a> - 객체화된 기본 자료형 대신 기본 자료형을 이용하라<br><a href="../../../../2017/10/09/general-programming-2/#50-다른-자료형이-적절하다면-문자열-사용은-피하라">규칙 50</a> - 다른 자료형이 적절하다면 문자열 사용은 피하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="48-정확한-답이-필요하다면-float와-double은-피하라"><a href="#48-정확한-답이-필요하다면-float와-double은-피하라" class="headerlink" title="48. 정확한 답이 필요하다면 float와 double은 피하라"></a>48. 정확한 답이 필요하다면 float와 double은 피하라</h2><ul>
<li><code>float</code>와 <code>double</code>은 이진 부동 소수점 연산(binary floating-point arithmetic)을 수행하는데, 이것은 넓은 범위의 값(magnitude)에서 대해 정확도가 높은 근사치를 제공할 수 있도록 세심하게 설계된 연산이다. 하지만 <strong>정확한 결과를 제공하지 않기 때문에</strong> 정확한(exact) 결과가 필요한 곳에는 사용하면 안 된다.</li>
<li><strong>정확한 답을 요구하는 문제를 풀 때(e.g. 돈 계산)는 <code>BigDecimal</code>, <code>int</code> 또는 <code>long</code>을 사용하라.</strong></li>
<li><code>BigDecimal</code>: 소수점 이하 처리를 시스템에서 알아서 해 줬으면 하고, 기본 자료형보다 불편하고 조금 느려도 상관 없을 경우 사용하라.</li>
<li><code>int</code>: 관계된 수치들이 십진수 아홉 개 이하로 표현이 가능할 때 사용하라.</li>
<li><code>long</code>: 관계된 수치들이 십진수 18개 이하로 표현 가능할 때 사용하라. 그 이상일 경우 <code>BigDecimal</code>을 써야 한다.</li>
</ul>
<hr>
<h2 id="49-객체화된-기본-자료형-대신-기본-자료형을-이용하라"><a href="#49-객체화된-기본-자료형-대신-기본-자료형을-이용하라" class="headerlink" title="49. 객체화된 기본 자료형 대신 기본 자료형을 이용하라"></a>49. 객체화된 기본 자료형 대신 기본 자료형을 이용하라</h2><ul>
<li>기본 자료형(<code>int</code>, <code>double</code>, <code>boolean</code>, …)에 대응되는 참조 자료형(reference type)을 boxed primitive type(혹은 wrapper class)이라 부른다(e.g. <code>Integer</code>, <code>Double</code>, <code>Boolean</code>, …).</li>
<li>기본 자료형이 더 단순하고 빠르다.</li>
<li>객체화된 기본 자료형에 == 연산자를 사용하는 것은 거의 항상 오류라고 봐야 한다.</li>
<li>기본 자료형과 객체화된 기본 자료형을 한 연산 안에 엮어 놓으면 객체화된 기본 자료형은 자동으로 기본 자료형으로 변환되며, 그 과정에서 NPE이 발생할 수 있다.</li>
<li>autoboxing은 객체화된 기본 자료형을 사용할 때 생길 수 있는 문제들까지 없애주진 않는다.</li>
</ul>
<hr>
<h2 id="50-다른-자료형이-적절하다면-문자열-사용은-피하라"><a href="#50-다른-자료형이-적절하다면-문자열-사용은-피하라" class="headerlink" title="50. 다른 자료형이 적절하다면 문자열 사용은 피하라"></a>50. 다른 자료형이 적절하다면 문자열 사용은 피하라</h2><blockquote>
<p>제대로 사용하지 못한 경우 문자열은 다른 자료형에 비해 다루기 성가시고, 유연성도 떨어지며, 느리고, 오류 발생 가능성도 높다.</p>
</blockquote>
<h4 id="문자열은-값-자료형value-type을-대신하기에는-부족하다"><a href="#문자열은-값-자료형-value-type-을-대신하기에는-부족하다" class="headerlink" title="문자열은 값 자료형(value type)을 대신하기에는 부족하다."></a>문자열은 값 자료형(value type)을 대신하기에는 부족하다.</h4><ul>
<li>숫자라면 int, 예/아니오를 묻는 질문의 답이라면 boolean으로 변환해야 한다. 즉, 적절한 값 자료형이 있다면 그것을 사용해야 한다. </li>
<li>당연해 보이는 지침인데 지켜지지 않는 일이 많다.</li>
</ul>
<h4 id="문자열은-enum-자료형을-대신하기에는-부족하다"><a href="#문자열은-enum-자료형을-대신하기에는-부족하다" class="headerlink" title="문자열은 enum 자료형을 대신하기에는 부족하다."></a>문자열은 enum 자료형을 대신하기에는 부족하다.</h4><ul>
<li>규칙 30에서 설명한 대로, enum은 문자열보다 훨씬 좋은 열거 자료형 상수를 만들어 낸다.</li>
</ul>
<h4 id="문자열은-혼합-자료형aggregate-type을-대신하기엔-부족하다"><a href="#문자열은-혼합-자료형-aggregate-type-을-대신하기엔-부족하다" class="headerlink" title="문자열은 혼합 자료형(aggregate type)을 대신하기엔 부족하다."></a>문자열은 혼합 자료형(aggregate type)을 대신하기엔 부족하다.</h4><ul>
<li><code>String id = name + &quot;#&quot; + id;</code> 이러한 코드에는 많은 문제가 있다.</li>
<li>필드 구분자로 들어간 문자가 필드 안에 들어가면 문제가 생긴다.</li>
<li>parsing하는데 시간 및 오류 발생 가능성도 높다.</li>
<li><code>equals</code>, <code>compareTo</code> 같은 메서드를 제공할 수 없고, String이 제공하는 기능들만 사용해야 한다.</li>
</ul>
<h4 id="문자열은-권한capability을-표현하기엔-부족하다"><a href="#문자열은-권한-capability-을-표현하기엔-부족하다" class="headerlink" title="문자열은 권한(capability)을 표현하기엔 부족하다."></a>문자열은 권한(capability)을 표현하기엔 부족하다.</h4><ul>
<li>문자열을 사용해 기능 접근 권한을 표현하는 것은 어렵다.</li>
<li>(참고) ThreadLocal 사용법과 활용: <a href="http://javacan.tistory.com/entry/ThreadLocalUsage" rel="external nofollow noopener noreferrer" target="_blank">http://javacan.tistory.com/entry/ThreadLocalUsage</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/10/09/general-programming-2/#48-정확한-답이-필요하다면-float와-double은-피하라&quot;&gt;규칙 48&lt;/a&gt; - 정확한 답이 필요하다면 float와 double은 피하라&lt;br&gt;&lt;a href=&quot;../../../../2017/10/09/general-programming-2/#49-객체화된-기본-자료형-대신-기본-자료형을-이용하라&quot;&gt;규칙 49&lt;/a&gt; - 객체화된 기본 자료형 대신 기본 자료형을 이용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/10/09/general-programming-2/#50-다른-자료형이-적절하다면-문자열-사용은-피하라&quot;&gt;규칙 50&lt;/a&gt; - 다른 자료형이 적절하다면 문자열 사용은 피하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 8장. 일반적인 프로그래밍 원칙들 - 1</title>
    <link href="https://wickso.me/2017/09/16/general-programming-1/"/>
    <id>https://wickso.me/2017/09/16/general-programming-1/</id>
    <published>2017-09-16T01:00:00.000Z</published>
    <updated>2017-09-17T10:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/09/16/general-programming-1/#45-지역-변수의-유효범위를-최소화하라">규칙 45</a> - 지역 변수의 유효범위를 최소화하라<br><a href="../../../../2017/09/16/general-programming-1/#46-for문보다는-for-each문을-사용하라">규칙 46</a> - for문보다는 for-each문을 사용하라<br><a href="../../../../2017/09/16/general-programming-1/#47-어떤-라이브러리가-있는지-파악하고-적절히-활용하라">규칙 47</a> - 어떤 라이브러리가 있는지 파악하고 적절히 활용하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="45-지역-변수의-유효범위를-최소화하라"><a href="#45-지역-변수의-유효범위를-최소화하라" class="headerlink" title="45. 지역 변수의 유효범위를 최소화하라"></a>45. 지역 변수의 유효범위를 최소화하라</h2><h4 id="처음-사용하는-곳에서-선언하라"><a href="#처음-사용하는-곳에서-선언하라" class="headerlink" title="처음 사용하는 곳에서 선언하라"></a>처음 사용하는 곳에서 선언하라</h4><ul>
<li>사용하기 전에(처음 사용하는 곳 말고 이전에) 선언하면 실제 사용될 때쯤 그 변수의 자료형과 초깃값이 무엇이었는지 잊어버린다</li>
<li>너무 빨리 선언하면 유효범위가 너무 커진다.</li>
</ul>
<h4 id="거의-모든-지역-변수-선언에는-초깃값initalizer이-표함되어야-한다"><a href="#거의-모든-지역-변수-선언에는-초깃값-initalizer-이-표함되어야-한다" class="headerlink" title="거의 모든 지역 변수 선언에는 초깃값(initalizer)이 표함되어야 한다"></a>거의 모든 지역 변수 선언에는 초깃값(initalizer)이 표함되어야 한다</h4><ul>
<li>while문보다는 for문을 쓰는 것이 좋다. -&gt; 순환문 변수(loop variable)을 사용할 수 있기 때문</li>
<li><code>try-catch</code>: 특정값이 catch에서 초기화해야 하는 경우와 같은 코드에서는 예외</li>
</ul>
<p><strong>유효범위를 최소화하는 숙어</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; n = expensiveComputation(); i &lt; n; i++&gt;) &#123;</div><div class="line">    doSomthing(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>두 개의 순환문 변수가 사용됨, <code>i</code>와 <code>n</code>의 유효범위는 정확히 for문으로 제한</li>
<li><code>expensiveComputation()</code>의 비용이 크고, 매번 안에서 재계산할 필요가 없어짐</li>
</ul>
<h4 id="메서드의-크기를-줄이고-특정한-기능에-집중하라"><a href="#메서드의-크기를-줄이고-특정한-기능에-집중하라" class="headerlink" title="메서드의 크기를 줄이고 특정한 기능에 집중하라"></a>메서드의 크기를 줄이고 특정한 기능에 집중하라</h4><ul>
<li>두 가지 서로 다른 기능을 넣지 말자</li>
<li>각 기능을 나눠서 별도 메서드로 구현하자</li>
</ul>
<h4 id="ie"><a href="#i-e" class="headerlink" title="i.e"></a>i.e</h4><ul>
<li>지역 변수의 유효범위를 최소화하면 가독성(readability)과 유지보수성(maintainability)이 좋아지고, 오류 발생 가능성도 줄어든다.</li>
</ul>
<hr>
<h2 id="46-for문보다는-for-each문을-사용하라"><a href="#46-for문보다는-for-each문을-사용하라" class="headerlink" title="46. for문보다는 for-each문을 사용하라"></a>46. for문보다는 for-each문을 사용하라</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 컬렉션이나 배열을 순회할 때는 이 숙어를 따르자</span></div><div class="line"><span class="keyword">for</span> (Element e : elements) &#123;</div><div class="line">    doSomething(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>java 1.5부터 도입된 for-each문은 성가신 코드를 제거하고 반복자나 첨자 변수를 제거해서 오류 가능성을 없앤다</li>
<li>for-each에서 <code>:</code> 기호는 “in”이라고 읽는다</li>
<li>for문에 비해 명료하고 버그 발생 가능성도 적으며, 성능도 for문에 뒤지지 않는다.</li>
<li><p>for-each의 장점은 여러 컬렉션에 중첩되는 순환문을 만들어야 할 때 더 빛이 난다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 굉장히 간결하다</span></div><div class="line"><span class="keyword">for</span> (Suit suit : suits) &#123;</div><div class="line">    <span class="keyword">for</span> (Rank rank : ranks) &#123;</div><div class="line">        deck.add(<span class="keyword">new</span> Card(suit, rank));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Iterable 인터페이스를 구현하면 for-each를 사용할 수 있다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 이 Iterable 안에 있는 원소들에 대한 반복자 반환</span></div><div class="line">    <span class="function">Iteraor&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>for-each를 적용할 수 없는 경우</strong></p>
<ol>
<li>Filtering: 순회하다가 특정 원소를 삭제하기 위해 <code>remove()</code>를 호출해야하므로</li>
<li>Transforming: 원소 일부의 값을 변환하기 위해 리스트 반복자나 배열 첨자가 필요하므로</li>
<li>Parallel iteration: 병렬적으로 순회해야 하고 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구현해야 한다면 반복자나 첨자 변수를 명시적으로 제어할 필요가 있을 것이므로</li>
</ol>
<hr>
<h2 id="47-어떤-라이브러리가-있는지-파악하고-적절히-활용하라"><a href="#47-어떤-라이브러리가-있는지-파악하고-적절히-활용하라" class="headerlink" title="47. 어떤 라이브러리가 있는지 파악하고 적절히 활용하라"></a>47. 어떤 라이브러리가 있는지 파악하고 적절히 활용하라</h2><blockquote>
<p>바퀴를 다시 발명하지 말라(Don’t reinvent the wheel)</p>
</blockquote>
<p>표준 라이브러리를 사용하면,</p>
<ul>
<li>일과 큰 관련성 없는 문제에 대한 해결 방법을 구현하는데 시간을 소비하지 않는다</li>
<li>별다른 노력을 하지 않아도 그 성능은 점차 개선된다</li>
<li>새로운 기능이 추가된다</li>
<li>팀원과 같은 코드를 사용하게 되기 때문에 가독성, 유지보수, 재사용성이 높아진다</li>
</ul>
<p>표준 라이브러리를 사용하기 위해,</p>
<ul>
<li>중요한 새 릴리즈가 나올 때마다 어떤 기능이 추가되었는지 알아두자</li>
<li>다 공부할 순 없지만 핵심 혹은 개발 관련 라이브러리는 알아두자(<code>java.lang</code>, <code>java.util.*</code>, <code>java.util.collections</code>, <code>java.util.concurrent</code>, …)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/09/16/general-programming-1/#45-지역-변수의-유효범위를-최소화하라&quot;&gt;규칙 45&lt;/a&gt; - 지역 변수의 유효범위를 최소화하라&lt;br&gt;&lt;a href=&quot;../../../../2017/09/16/general-programming-1/#46-for문보다는-for-each문을-사용하라&quot;&gt;규칙 46&lt;/a&gt; - for문보다는 for-each문을 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/09/16/general-programming-1/#47-어떤-라이브러리가-있는지-파악하고-적절히-활용하라&quot;&gt;규칙 47&lt;/a&gt; - 어떤 라이브러리가 있는지 파악하고 적절히 활용하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 7장. 메서드 - 3</title>
    <link href="https://wickso.me/2017/08/13/methods-3/"/>
    <id>https://wickso.me/2017/08/13/methods-3/</id>
    <published>2017-08-13T01:00:00.000Z</published>
    <updated>2017-08-13T13:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/08/13/methods-3/#규칙-43-null-대신-빈-배열이나-컬렉션을-반환하라">규칙 43</a> - null 대신 빈 배열이나 컬렉션을 반환하라<br><a href="../../../../2017/08/13/methods-3/#규칙-44-모든-API-요소에-문서화-주석을-달라">규칙 44</a> - 모든 API 요소에 문서화 주석을 달라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-43-null-대신-빈-배열이나-컬렉션을-반환하라"><a href="#규칙-43-null-대신-빈-배열이나-컬렉션을-반환하라" class="headerlink" title="규칙 43. null 대신 빈 배열이나 컬렉션을 반환하라"></a>규칙 43. null 대신 빈 배열이나 컬렉션을 반환하라</h2><blockquote>
<p>Null References</p>
<p><em>“I call it my billion-dollar mistake.”</em> - Tony Hoare</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// as-is</span></div><div class="line"><span class="keyword">if</span> (values != <span class="keyword">null</span> &amp;&amp; Arrays.asList(values).contains(Value.IMAGE)) &#123;&#125;</div><div class="line"><span class="comment">// to-be</span></div><div class="line"><span class="keyword">if</span> (Arrays.asList(values).contains(Value.IMAGE)) &#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>반환값이 null인 경우를 항상 대비해야한다.</li>
<li>빈 배열이나 컬렉션 대신 null을 반환하는 메서드는 구현하기도 더 까다롭다.</li>
<li><p>배열 할당 비용을 피할 수 있으니 null을 반환해야 한다?</p>
<ul>
<li><p>프로파일링 결과로 해당 메서드가 성능 저하의 주범이라는 것이 밝혀지지 않는 한, 그런 수준까지 성능 걱정을 하는 것은 바람직하지 않다(규칙 55 - 신중하게 최적화하라).</p>
<blockquote>
<p><strong>모든 프로그래머가 알아둬야 하는 최적화 관련 격언 세 가지</strong></p>
<p><em>“맹목적인 어리석음을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다(효율성을 반드시 성취하는 것도 아니면서 말이다).”</em><br>윌리엄 울프(William A. Wulf[Wulf72])</p>
<p><em>“작은 효율성(small efficiency)에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 석부른 최적화(premature optimzation)은 모든 악의 근원이다.”</em><br>도널드 커누스(Donald E. Knuth)[Kunth74]</p>
<p><em>“최적화를 할 때는 아래의 두 규칙을 따르라.</em><br><em>규칙 1: 하지마라.</em><br><em>규칙 2: (전문가들만 따를 것) 아직은 하지 마라 - 완벽히 명료한, 최적화되지 않은 해답을 얻을 때까지는.”</em><br>M. A. 잭슨(M. A. Jackson)[Jackson75]</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>길이가 0인 배열은 변경이 불가능하므로 아무 제약 없이 재사용할 수 있다(규칙 15).</p>
<blockquote>
<p><strong>컬렉션에서 배열을 만들어 반환하는 올바른 방법</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Cheese&gt; cheeseInStock = ...;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cheese[] EMPTY_CHEESE_ARRAY = <span class="keyword">new</span> Cheese[<span class="number">0</span>];</div><div class="line"><span class="keyword">public</span> Cheese[] getCheese() &#123;</div><div class="line">    <span class="keyword">return</span> cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드에서 <code>toArray()</code>에 전달되는 빈 매열 상수는 반환값의 자료형을 명시하는 구실을 한다. 보통 <code>toArray()</code>는 반환되는 원소가 담길 배열을 스스로 할당하는데, 컬렉션이 비어 있는 경우에는 인자로 주어진 빈 배열을 쓴다. 그리고 인자로 주어진 배열이 컬렉션의 모든 원소를 담을 정도로 큰 경우에는 해당 배열을 반환값으로 사용한다. 따라서 위의 숙어대로 하면 빈 배열은 절대로 자동 할당되지 않는다.</p>
<p><em>ArrayList.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</div><div class="line">  <span class="keyword">if</span> (a.length &lt; size)</div><div class="line">    <span class="comment">// Make a new array of a's runtime type, but my contents:</span></div><div class="line">    <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</div><div class="line">  System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</div><div class="line">  <span class="keyword">if</span> (a.length &gt; size)</div><div class="line">    a[size] = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>컬렉션 복사본을 반환하는 올바른 방법</strong></p>
<p>  컬렉션을 반환하는 메서드도 빈 컬렉션을 반환해야 할 때마다 동일한 변경 불가능 빈 컬렉션 객체를 반환하도록 구현할 수 있다. <code>Collections.emptySet()</code>, <code>Collections.emptyList()</code>, <code>Collections.emptyMap()</code>가 그런 용도로 사용된다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheeseList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (cheeseInSrock.isEmpty()) &#123;</div><div class="line">    <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// 언제나 같은 리스트 반환</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Cheese&gt;(cheeseInStock);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>null 대신에 빈 배열이나 빈 컬렉션을 반환하자.</strong> null 값을 반환하는 것은 C 언어에서 전해진 관습으로, C에서는 배열의 길이가 배열과 따로 반환된다. 길이 0인 배열을 할당해서 반환하더라도 아무 이득이 없다.</p>
<hr>
<h2 id="규칙-44-모든-api-요소에-문서화-주석을-달라"><a href="#규칙-44-모든-API-요소에-문서화-주석을-달라" class="headerlink" title="규칙 44. 모든 API 요소에 문서화 주석을 달라"></a>규칙 44. 모든 API 요소에 문서화 주석을 달라</h2><blockquote>
<p><strong>좋은 API 문서를 만들려면 API에 포함된 모든 클래스, 인터페이스, 생성자, 메서드, 그리고 필드 선언에 문서화 주석을 달아야 한다.</strong></p>
</blockquote>
<ul>
<li>문서화 주석과 javadoc을 통해 API 문서를 자동으로 만들 수 있다. 문서화 주석 문법은 자바 언어의 일부는 아니지만, 모든 프로그래머가 알아야 하는 실질적인 표준 API다. (<a href="http://www.oracle.com/technetwork/articles/java/index-137868.html" rel="external nofollow noopener noreferrer" target="_blank">How to Write Doc Comments - Oracle 웹사이트</a>)</li>
</ul>
<h4 id="공통"><a href="#공통" class="headerlink" title="공통"></a>공통</h4><p><em>List.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the hash code value for this list.  The hash code of a list</div><div class="line"> * is defined to be the result of the following calculation:</div><div class="line"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></div><div class="line"> *     int hashCode = 1;</div><div class="line"> *     for (E e : list)</div><div class="line"> *         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());</div><div class="line"> * &#125;&lt;/pre&gt;</div><div class="line"> * This ensures that &lt;tt&gt;list1.equals(list2)&lt;/tt&gt; implies that</div><div class="line"> * &lt;tt&gt;list1.hashCode()==list2.hashCode()&lt;/tt&gt; for any two lists,</div><div class="line"> * &lt;tt&gt;list1&lt;/tt&gt; and &lt;tt&gt;list2&lt;/tt&gt;, as required by the general</div><div class="line"> * contract of &#123;<span class="doctag">@link</span> Object#hashCode&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> the hash code value for this list</div><div class="line"> * <span class="doctag">@see</span> Object#equals(Object)</div><div class="line"> * <span class="doctag">@see</span> #equals(Object)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p><strong>코드는 <code>{@code }</code> 태그를 사용하라.</strong></p>
<ul>
<li><p>코드 서체로 표시되도록 한다.</p>
</li>
<li><p>태그 안에 포함된 모든 HTML 마크업이나 javadoc 태그가 위력을 발휘하지 못하도록 한다.</p>
</li>
<li><p>여러 줄로 나뉜 코드를 문서화 주석에 넣을 때는 <code>{@code }</code> 태그를 HTML <code>&lt;pre&gt;</code> 태그 안에 넣어라.</p>
</li>
<li><p><code>&lt;tt&gt;</code>  태그는 HTML5 에서 더이상 지원하지 않는다(고정폭을 보여줘야 할 경우에는 일반적으로 <code>&lt;code&gt;</code> 태그).</p>
<p><em>\<tt\> - MDN</tt\></em></p>
<blockquote>
<p><strong>Obsolete</strong><br>This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.</p>
</blockquote>
</li>
</ul>
<p><strong>주석을 달 때 명심해야 할 일반적 원칙은, 문서화 주석은 소스 코드로 보나 javadoc으로 변환한 결과물로 보나 읽을 만해야 한다는 것이다. 그럴수 없는 상황이라면, javadoc으로 변환한 결과물의 가독성을 우선시하기 바란다.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The triangle inequality is &#123;<span class="doctag">@literal</span> |x + y| &lt; |x| + |y|&#125;.</div><div class="line"> ...</div><div class="line"> */</div></pre></td></tr></table></figure>
<ul>
<li>HTML 메타문자들을 사용할 때는 <code>{@literal }</code> 태그를 사용하라.</li>
<li><code>&lt;</code> 기호만 <code>{@literal }</code> 태그로 둘 수도 있었겠지만, 그랬으면 가독성이 떨어졌을 것이다.</li>
<li><code>{@code }</code> 태그와 유사하지만, 코드 서체로 표시되지 않는 차이가 있다.</li>
</ul>
<p><strong>모든 문서화 주석의 첫 번째 “문장”은 해당 주석에 담긴 내용을 요약한 것이다(summary description).</strong></p>
<ul>
<li>혼란을 막기 위해, 클래스나 인터페이스의 맴버나 생성자들 가운데 요약문 같은 것은 없어야 한다.</li>
<li>오버로딩할 경우에는 같은 요약을 쓰는 것이 자연스러울 때가 있으니 주의하라(하지만 문서화 주석의 경우, 동일한 첫 문장은 곤란하다).</li>
</ul>
<p><strong>요약문에 마침표가 여러 번 포함되어야 하는 경우에는 주의하라.</strong></p>
<ul>
<li><p>javadoc은 뒤에 <em>공백</em>, <em>탭</em>, <em>줄바꿈 문자(line terminator)</em>, <em>블록 태그(block tag)</em>가 오는 첫번째 마침표 위치에서 요약문이 끝나는 것으로 생각한다. 이 문제를 푸는 가장 좋은 방법은, <code>{@literal }</code> 태그로 감싸는 것이다.</p>
<p><em>example.</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A college degree, such as B.S., M.S. or Ph.D.</div><div class="line"> * College is a fountain of knowledge where many go to drink.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Degree</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A college degree, such as B.S., &#123;<span class="doctag">@literal</span> M.S.&#125; or Ph.D.</div><div class="line"> * ...</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>엄밀히 따지자면 문서화 주석의 요약문은 첫 번째 “문장”일 필요는 없다. 완벽한 문장일 필요가 없다는 것이다.</strong></p>
<ul>
<li><p><strong>메서드나 생성자의 경우,</strong> 요약문은 메서드가 무슨 일을 하는지 기술하는 (객체를 포함하는) 완전한 동사구(verb phrase)여야 한다.</p>
<p><em>Collection.java - size()</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the number of elements in this collection.  If this collection</div><div class="line"> * contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns</div><div class="line"> * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> the number of elements in this collection</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p><em>ArrayList.java - Constructor</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with the specified initial capacity.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</div><div class="line"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</div><div class="line"> *         is negative</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>클래스와 인터페이스의 요약문은,</strong> 해당 클래스나 인터페이스로 만들어진 객체가 무엇을 나타내는지를 표현하는 명사구여야 한다.</p>
<p>   <em>Collection.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The root interface in the &lt;i&gt;collection hierarchy&lt;/i&gt;.  A collection...</div><div class="line"> */</div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>필드의 요약문은,</strong> 필드가 나타내는 것이 무엇인지를 설명하는 명사구여야 한다.</p>
<p><em>Math.PI</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The &#123;<span class="doctag">@code</span> double&#125; value that is closer than any other to</div><div class="line"> * &lt;i&gt;pi&lt;/i&gt;, the ratio of the circumference of a circle to its</div><div class="line"> * diameter.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>javadoc에는 메서드 주석을 “상속”하는 기능이 있다.</strong></p>
<ul>
<li><p>적용 가능한 문서화 주석 가운데 가장 근접한 것을 찾는다. 이때 상위 클래스보다는 인터페이스 쪽에 우선권이 주어진다.</p>
</li>
<li><p><code>{@inheritDoc }</code> 태그를 사용하면 상위 자료형에 있는 문서화 주석 가운데 일부를 상속할 수도 있다.</p>
<p><em>ArrayList.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* (중간 생략)</div><div class="line">* <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p><em>List.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * (중간 생략)</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</div><div class="line"> *         (&lt;tt&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/tt&gt;)</div><div class="line"> */</div><div class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>API 관련 별도 문서가 있다면, 문서화 주석에 링크를 남긴다.</strong></p>
<blockquote>
<p>  문서화 주석에 관해서, 마지막으로 한 가지 주의사항만 더 살펴보자. 모든 공개 API 요소에는 문서화 주석을 달 필요가 있지만, 항상 그 정도면 충분하지 않다. <strong>관련된 클래스가 많아서 복잡한 API의 경우, API의 전반적인 구조를 설명하는     별도 문서(external document)가 필요한 경우가 많다. 그런 문서가 있다면, 관련 클래스나 패키지의 문서화 주석에는 해당 문서로 연결되는 링크가 있어야 한다.</strong></p>
</blockquote>
<h4 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h4><p><strong>메서드에 대한 문서화 주석은, 메서드와 클라이언트 사이의 규약을 간명하게 설명해야 한다.</strong></p>
<ul>
<li>계승을 위해 설계된 메서드가 아니라면(규칙17) 메서드가 <em>어떻게</em>가 아닌 <em>무엇</em>을 하는지를 설명해야 한다.</li>
<li>해당 메서드의 모든 선행조건(precondition)과 후행조건(postcondition)을 나열해야 한다.<ul>
<li>선행조건: 메서드를 호출하려면 반드시 참(true)이 되어야 하는 조건들</li>
<li>후행조건: 메서드 실행이 성공적으로 끝난 다음에 만족되어야 하는 조건들</li>
</ul>
</li>
<li>보통 선행조건은 무결점 예외(unchecked exception)에 대한 <code>@throw</code> 태그를 통해 암묵적으로 기술한다. 관계된 인자의 <code>@param</code> 태그를 통해 명시할 수도 있다.</li>
</ul>
<ul>
<li>메서드는 부작용(side effect)에 대해서도 문서화 해야 한다. 부작용은 후행조건을 만족하기 위해 필요한 것이 아닌, 시스템의 관측 가능한 상태 변화를 일컫는다.</li>
<li>규칙 70에 설명한 대로, 클래스가 메서드의 스레드 안전성(thread safety)에 대해서도 문서에 남겨야 한다.</li>
</ul>
<p><strong>메서드의 규약(contract)을 완벽하게 기술하려면, 문서화 주석에는 인자마다 <code>@param</code> 태그를 달아야 하고, 반환값 자료형이 void 가 아니라면 <code>@return</code> 태그도 달아야 하고, 무점검/점검 여부에 상관없이 모든 예외에는 <code>@throws</code> 태그도 붙어야 한다(규칙 62).</strong></p>
<p><strong>관습적으로,</strong></p>
<p><em>List.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Removes the element at the specified position in this list (optional</div><div class="line"> * operation).  Shifts any subsequent elements to the left (subtracts one</div><div class="line"> * from their indices).  Returns the element that was removed from the</div><div class="line"> * list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> index the index of the element to be removed</div><div class="line"> * <span class="doctag">@return</span> the element previously at the specified position</div><div class="line"> * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;remove&lt;/tt&gt; operation</div><div class="line"> *         is not supported by this list</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</div><div class="line"> *         (&lt;tt&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/tt&gt;)</div><div class="line"> */</div><div class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><code>@param</code> 태그나 <code>@return</code> 태그 다음에는 인자나 반환값을 설명하는 명사구(noun phrase)가 와야 한다.</li>
<li><code>@throw</code> 태그 다음에는 어떤 조건에서 예외가 발생하는지를 설명하는 if 절이 온다.</li>
<li>명사구 대신 산술 표현식(arithmetic expression)이 쓰일 때도 있다.</li>
<li><code>@param</code>, <code>@return</code>, <code>@throws</code> 태그 다음에 오는 구나 절에는 마침표를 찍지 않는다.</li>
</ul>
<h4 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h4><p><strong>클래스가 스레드에 안전하건 그렇지 않건 간에, 그 안전성 수준을 문서로 남겨야 한다(규칙 70).</strong></p>
<p><strong>직렬화(serialization)가 가능한 클래스라면 직렬화 형식도 밝혀야 한다(규칙 75).</strong></p>
<p><strong>제네릭 자료형이나 메서드에 주석을 달 때는 모든 자료형 인자들을 설명해야 한다.</strong></p>
<p><em>Map.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * An object that maps keys to values.  A map cannot contain duplicate keys;</div><div class="line"> * each key can map to at most one value.</div><div class="line"> *</div><div class="line"> * (중간 생략)</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</div><div class="line"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p><strong>enum 자료형에 주석을 달 때는 자료형이나 public 메서드뿐 아니라 상수 각각에도 주석을 달아 주어야 한다.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 조직 연동에 사용되는 서비스.</div><div class="line"> * 어드민에서 조직연동 API와 같이 내려오는 값도 포함(SSO, IPT)</div><div class="line"> * <span class="doctag">@author</span> yeongjun on 2016. 11. 2.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrgSyncType &#123;</div><div class="line">  <span class="comment">/** 조직/구성원의 조직 */</span></div><div class="line">  GROUP,</div><div class="line"></div><div class="line">  <span class="comment">/** 조직/구성원의 구성원 */</span></div><div class="line">  MEMBER,</div><div class="line"></div><div class="line">  <span class="comment">/** 직급/직책 */</span></div><div class="line">  JOB</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>어노테이션 자료형에 주석을 달 때는 자료형뿐 아니라 모든 멤버에도 주석을 달아야 한다.</strong></p>
<ul>
<li>멤버에는 필드인 것처럼 명사구 주석을 달아라.</li>
<li>자료형 요약문에는 동사구를 써서, 언제 이 자료형을 어노테이션으로 붙여야 하는지 설명하라.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 조직연동시 접근제한이 필요한 API라는 것을 명시.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> yeongjun on 2016. 11. 2.</div><div class="line"> */</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;java.lang.annotation.ElementType.METHOD&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OrgSyncUsersDenied &#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 어노테이션 붙은 메서드가 제한되어야 하는 조직연동 서비스 타입.</div><div class="line">   */</div><div class="line">  OrgSyncType[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>릴리즈 1.5부터는 <em>패키지 수준 문서화 주석(package-level doc comment)</em>은 <code>package-info.java</code>에 두어야 한다.</strong></p>
<ul>
<li>패키지 선언 및 패키지 어노테이션을 넣을 수 있다.</li>
</ul>
<h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><ul>
<li><a href="http://swagger.io/" rel="external nofollow noopener noreferrer" target="_blank">Swagger</a>: API Document을 만들어 주는 툴</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/08/13/methods-3/#규칙-43-null-대신-빈-배열이나-컬렉션을-반환하라&quot;&gt;규칙 43&lt;/a&gt; - null 대신 빈 배열이나 컬렉션을 반환하라&lt;br&gt;&lt;a href=&quot;../../../../2017/08/13/methods-3/#규칙-44-모든-API-요소에-문서화-주석을-달라&quot;&gt;규칙 44&lt;/a&gt; - 모든 API 요소에 문서화 주석을 달라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 7장. 메서드 - 2</title>
    <link href="https://wickso.me/2017/08/12/methods-2/"/>
    <id>https://wickso.me/2017/08/12/methods-2/</id>
    <published>2017-08-12T02:00:00.000Z</published>
    <updated>2018-01-11T15:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/08/12/methods-2/#규칙-41-오버로딩할-때는-주의하라">규칙 41</a> - 오버로딩할 때는 주의하라<br><a href="../../../../2017/08/12/methods-2/#규칙-42-varargs는-신중히-사용하라">규칙 42</a> - varargs는 신중히 사용하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-41-오버로딩할-때는-주의하라"><a href="#규칙-41-오버로딩할-때는-주의하라" class="headerlink" title="규칙 41. 오버로딩할 때는 주의하라"></a>규칙 41. 오버로딩할 때는 주의하라</h2><ul>
<li>오버로딩: 동일한 이름의 메서드나 생성자를 정의하고, 파라미터의 타입과 갯수만 다르게 정의하는 것</li>
<li>오버라이딩: 상위 클래스의 메서드를 재정의하는 것</li>
</ul>
<blockquote>
<p><strong>요약</strong></p>
<ul>
<li>인자 갯수가 같은 오버로딩 메서드를 추가하는 것은 일반적으로 피함</li>
<li>같은 인자를 넘겨 호출했을 때 모든 오버로딩 메서드가 똑같이 동작하도록 해야 한다</li>
</ul>
</blockquote>
<p><em>e.g. overloading code</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Set"</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; lis)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"List"</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Unknown Collection"</span>; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Collection&lt;?&gt;[] collections = &#123;</div><div class="line">                <span class="keyword">new</span> HashSet&lt;String&gt;(),</div><div class="line">                <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</div><div class="line">                <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Collection&lt;?&gt; c : collections)</div><div class="line">            System.out.println(classify(c));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Unknown Collection</div><div class="line">Unknown Collection</div><div class="line">Unknown Collection</div></pre></td></tr></table></figure>
<p><em>e.g. override code</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wine</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"wine"</span>; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparklingWine</span> <span class="keyword">extends</span> <span class="title">Wine</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"sparkling wine"</span>; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Champagne</span> <span class="keyword">extends</span> <span class="title">SparklingWine</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"champagne"</span>; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overriding</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Wine[] wines = &#123; <span class="keyword">new</span> Wine(), <span class="keyword">new</span> SparklingWine(), <span class="keyword">new</span> Champagne() &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Wine wine : wines)</div><div class="line">            System.out.println(wine.name());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">wine</div><div class="line">sparkling wine</div><div class="line">champagne</div></pre></td></tr></table></figure>
<p><strong>“두 코드의 결과와 차이점은 무엇일까?”</strong></p>
<ul>
<li><p>오버로딩된 메서드 가운데 어떤 것이 호출될지는 컴파일 시점에 결정된다.</p>
<p>  위 코드(<em>overloading code</em>)에서 각 인자의 실행시점 자료형은 전부 다르겠지만, 선택 과정에는 영향을 끼치지 못한다.</p>
</li>
<li><p>오버로딩된 메서드는 static으로 선택되지만, 오버라이딩된 메서드는 dynamic으로 선택된다.</p>
</li>
<li>오버로딩을 사용할 때는 혼란스럽지 않게 사용할 수 있도록 주의해야 한다.</li>
</ul>
<p><strong>“혼란스러운 상황?”</strong></p>
<ul>
<li>혼란을 피하는 안전하고 보수적인 전략은, 같은 수의 인자를 갖는 두 개의 오버로딩 메서드를 API에 포함시키지 않는 것</li>
</ul>
<p><strong>“그럼 작명 패턴을 쓰는 것이 더 낫지 않은가?”</strong></p>
<ul>
<li>각 메서드에 대응되는 메서드를 정의할 수 있다.</li>
</ul>
<p><strong>“생성자에서는?”</strong></p>
<ul>
<li>정적 팩터리 메서드 사용</li>
</ul>
<h4 id="또-다른-문제점autoboxing-도입-후"><a href="#또-다른-문제점-autoboxing-도입-후" class="headerlink" title="또 다른 문제점(autoboxing 도입 후)"></a>또 다른 문제점(autoboxing 도입 후)</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetList</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">3</span>; i &lt; <span class="number">3</span>; i ++) &#123;</div><div class="line">            set.add(i);</div><div class="line">            list.add(i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</div><div class="line">            set.remove(i);</div><div class="line">            list.remove(i);</div><div class="line">        &#125;</div><div class="line">        System.out.println(set + <span class="string">" "</span> + list);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[-<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>] [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>]</div></pre></td></tr></table></figure>
<ul>
<li><code>list.remove(int)</code>는 인덱스의 위치를 삭제.</li>
<li><code>list.remove((Integer) i)</code>로 형변환을 해야 오버로딩된 메서드가 실행된다.</li>
<li>이런 상황을 고려하며 코드를 작성하자.</li>
</ul>
<hr>
<h2 id="규칙-42-varargs는-신중히-사용하라"><a href="#규칙-42-varargs는-신중히-사용하라" class="headerlink" title="규칙 42. varargs는 신중히 사용하라"></a>규칙 42. varargs는 신중히 사용하라</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... args)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> arg : args) &#123; ... &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Java1.5부터 가변 인자 메서드(variable arity method)라고 부르는 varargs 메서드가 추가되었다[JLS, 8.4.1].</li>
<li><p>하나 이상을 받는 메서드를 구현하려면 아래와 같이 사용한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> firstArg, <span class="keyword">int</span>... remainingArgs)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>마지막 인자가 배열이라고 해서 무조건 뜯어고칠 생각은 버려라. vaarargs는 정말로 임의 갯수의 인자를 처리할 수 있는 메서드를 만들어야 할 때만 사용하라.</p>
</li>
<li><p>성능이 중요한 환경이라면 varargs 사용에 더욱 신중해야 한다. 인자 갯수가 3개 보다 클때 varargs 를 활용하고 나머지는 오버로딩을 하는 것이 좋다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span>... rest)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/08/12/methods-2/#규칙-41-오버로딩할-때는-주의하라&quot;&gt;규칙 41&lt;/a&gt; - 오버로딩할 때는 주의하라&lt;br&gt;&lt;a href=&quot;../../../../2017/08/12/methods-2/#규칙-42-varargs는-신중히-사용하라&quot;&gt;규칙 42&lt;/a&gt; - varargs는 신중히 사용하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 7장. 메서드 - 1</title>
    <link href="https://wickso.me/2017/08/12/methods-1/"/>
    <id>https://wickso.me/2017/08/12/methods-1/</id>
    <published>2017-08-12T01:00:00.000Z</published>
    <updated>2018-01-11T15:55:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/08/12/methods-1/#규칙-38-인자의-유효성을-검사하라">규칙 38</a> - 인자의 유효성을 검사하라<br><a href="../../../../2017/08/12/methods-1/#규칙-39-필요하다면-방어적-복사본을-만들라">규칙 39</a> - 필요하다면 방어적 복사본을 만들라<br><a href="../../../../2017/08/12/methods-1/#규칙-40-메서드-시그니처는-신중하게-설계하라">규칙 40</a> - 메서드 시그니처는 신중하게 설계하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-38-인자의-유효성을-검사하라"><a href="#규칙-38-인자의-유효성을-검사하라" class="headerlink" title="규칙 38. 인자의 유효성을 검사하라"></a>규칙 38. 인자의 유효성을 검사하라</h2><blockquote>
<p><strong>요약</strong></p>
<ul>
<li>메서드나 생성자를 구현할 때 받을 수 있는 인자에 제한이 있는지 따져볼 것</li>
<li>제한이 있다면 문서에 남기고, 메서드 앞부분에서 검사</li>
</ul>
</blockquote>
<p>invalid 인자가 전달되어도, 메서드 앞부분에서 인자 유효성 검사를 하면 적정한 예외를 통해 깔끔하고 신속하게 오류를 검출할수 있다. 그렇지 않으면 처리 도중에 이상한 예외를 내면서 죽거나, 제대로 실행하는 것 같은데 잘못된 결과가 나오거나, 다른 값에 영향을 주거나, 아무 상관 없는 부분에서 오류가 발생하는데 그 시간과 위치를 프로그램을 실행할 때마다 다를 수도 있다.</p>
<p>public 메서드라면 인자 유효성이 위반되었을 경우에 발생하는 예외를 javadoc의 @throws 태그를 사용해서 문서화하라(규칙 62).</p>
<p>public이 아닌 메서드는 일반적으로 인자 유효성을 검사할 때 assertion을 이용한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span> a[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> a != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">assert</span> offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt;= a.length;</div><div class="line">    <span class="keyword">assert</span> length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= a.length - offset;</div><div class="line">    ... <span class="comment">// 계산 수행</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>assertion은 클라이언트가 패키지를 어떻게 이용하던 확증 조건(asserted condition)은 항상 참이 되어야 한다고 주장하는 것</li>
<li>통상적인 유효성 검사와는 달리, 확증문은 확증 조건이 만족되지 않으면 AssertionError를 발생.</li>
<li>통상의 유효성 검사와는 달리, 활성화되지 않은 확증문은 실행되지 않으므로 비용이 0이다.</li>
<li>확증문을 활성화시키려면 java 인터프리터에 -ea(-enableassertions) 옵션을 주어야 한다.</li>
</ul>
<hr>
<h2 id="규칙-39-필요하다면-방어적-복사본을-만들라"><a href="#규칙-39-필요하다면-방어적-복사본을-만들라" class="headerlink" title="규칙 39. 필요하다면 방어적 복사본을 만들라"></a>규칙 39. 필요하다면 방어적 복사본을 만들라</h2><ul>
<li>만드는 클래스의 클라이언트가 불변식을 망가뜨리기 위해 최선을 다할 것이라는 가정하에, 방어적 프로그래밍해야 한다.</li>
<li>객체 내부를 보호하려면 생성자로 전달되는 변경 가능 객체를 반드시 방어적으로 복사한다.</li>
<li>접근자는 내부 필드에 대한 방어적 복사본을 반환하도록 한다.</li>
<li>객체의 컴포넌트로는 가능하다면 변경 불가능 객체를 사용하라.</li>
<li>오버헤그가 크거나, 사용자가 부적절하게 사용하지 않는다는 보장이 있을 때는, 문서에 명시하고 넘어갈 수 있다.</li>
</ul>
<hr>
<h2 id="규칙-40-메서드-시그니처는-신중하게-설계하라"><a href="#규칙-40-메서드-시그니처는-신중하게-설계하라" class="headerlink" title="규칙 40. 메서드 시그니처는 신중하게 설계하라"></a>규칙 40. 메서드 시그니처는 신중하게 설계하라</h2><p>API 설계할 때 참고하면 좋은 팁, 잘 적용하면 배우기도 쉽고 사용하기도 쉽고 오류가 날 가능성도 적은 API를 만드는데 도움이 될 것</p>
<h4 id="메서드-이름은-신중하게-고르라"><a href="#메서드-이름은-신중하게-고르라" class="headerlink" title="메서드 이름은 신중하게 고르라."></a>메서드 이름은 신중하게 고르라.</h4><ul>
<li>모든 이름은 표준 작명 관습(standard naming convention)을 따아야 한다(규칙 56).</li>
<li>최우선 목표는 이해하기 쉬우면서도 같은 패키지 안의 다른 이름들과 일관성이 유지되는 이름으로 선택</li>
<li>좀 더 널리 합의된 사항에도 부합하는 이름으로 고를 것, 자바 라이브러리 확인</li>
</ul>
<h4 id="편의-메서드convenience-method를-제공하는데-너무-열-올리지-마라"><a href="#편의-메서드-convenience-method-를-제공하는데-너무-열-올리지-마라" class="headerlink" title="편의 메서드(convenience method)를 제공하는데 너무 열 올리지 마라."></a>편의 메서드(convenience method)를 제공하는데 너무 열 올리지 마라.</h4><ul>
<li>모든 메서드는 “맡은 일이 명확하고 거기 충실해야(pull its weight)” 한다.</li>
<li>클래스에 너무 메서드가 많으면 학습, 사용, 테스트, 유지보수 등의 모든 측면에서 어렵다.</li>
<li>인터페이스의 경우에는 메서드가 많으면 문제가 두 배는 더 심각하다(구현하는 사람에게도 그렇고, 사용자에게도 그렇다).</li>
<li>수행해야 하는 동작 각각에 대해서 기능적으로 완전한 메서드를 제공하라.</li>
<li>“단축(shorthand)” 메서드는 자주 쓰일 때문 추가하라. 그럴지 잘 모르겠다면, 빼버려라.</li>
</ul>
<h4 id="인자-리스트parameter-list를-길게-만들지-마라"><a href="#인자-리스트-parameter-list-를-길게-만들지-마라" class="headerlink" title="인자 리스트(parameter list)를 길게 만들지 마라."></a>인자 리스트(parameter list)를 길게 만들지 마라.</h4><ul>
<li>4개 이하가 되도록 애쓰라.</li>
<li>자료형이 같은 인자들이 길게 연결된 인자 리스트는 특히 더 위험하다.</li>
</ul>
<p><strong>긴 인자 리스트를 짧게 줄이는 방법</strong></p>
<ol>
<li>여러 메서드로 나누는 것<ul>
<li>여러 메서드가 생길수 있지만, 직교성(orthogonality) 향상을 통해 줄일 수 있다.</li>
</ul>
</li>
<li>helper class를 만들어 인자들을 그룹별로 나누는 것<ul>
<li>보통 이 helper class들은 static 맴버 클래스다(규칙 22).</li>
<li>이 기법은 자주 등장하는 일련의 인자들이 어떤 별도 개체(entity)를 나타낼 때 쓰면 좋다.<ul>
<li>카드의 rank와 suit를 인자로 받는 메서드가 있다면, 카드를 나타내는 helper class를 만들어서 인자로 사용</li>
</ul>
</li>
</ul>
</li>
<li>builder pattern을 고쳐서 객체 생성 대신 메서드 호출에 적용하는 것<ul>
<li>많은 인자가 필요하지만 그 인자들 가운데 상당수는 옵션이라면, 모든 인자를 표현하는 객체 하나를 정의하고 그 객체의 setter 메서드를 클라이언트가 여러 번 호출할 수 있도록 하면 좋다.</li>
<li>인자가 설정되고 나면 클라이언트를 “execute” 메서드를 호출하여 최종적인 유효성 검사를 실행한 뒤 실제 계산 진행</li>
</ul>
</li>
</ol>
<h4 id="인자의-자료형으로는-클래스보다-인터페이스가-좋다"><a href="#인자의-자료형으로는-클래스보다-인터페이스가-좋다" class="headerlink" title="인자의 자료형으로는 클래스보다 인터페이스가 좋다."></a>인자의 자료형으로는 클래스보다 인터페이스가 좋다.</h4><ul>
<li>인자를 정의하기에 적합한 인터페이스가 있다면, 구현 클래스 대신 인터페이스를 인자 자료형으로 쓰자.</li>
</ul>
<h4 id="인자-자료형으로-boolean을-쓰는-것보다-원소가-2개인-enum-자료형을-쓰는-것이-낫다"><a href="#인자-자료형으로-boolean을-쓰는-것보다-원소가-2개인-enum-자료형을-쓰는-것이-낫다" class="headerlink" title="인자 자료형으로 boolean을 쓰는 것보다, 원소가 2개인 enum 자료형을 쓰는 것이 낫다."></a>인자 자료형으로 boolean을 쓰는 것보다, 원소가 2개인 enum 자료형을 쓰는 것이 낫다.</h4><ul>
<li>좀 더 읽기 편한 코드가 만들어진다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/08/12/methods-1/#규칙-38-인자의-유효성을-검사하라&quot;&gt;규칙 38&lt;/a&gt; - 인자의 유효성을 검사하라&lt;br&gt;&lt;a href=&quot;../../../../2017/08/12/methods-1/#규칙-39-필요하다면-방어적-복사본을-만들라&quot;&gt;규칙 39&lt;/a&gt; - 필요하다면 방어적 복사본을 만들라&lt;br&gt;&lt;a href=&quot;../../../../2017/08/12/methods-1/#규칙-40-메서드-시그니처는-신중하게-설계하라&quot;&gt;규칙 40&lt;/a&gt; - 메서드 시그니처는 신중하게 설계하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 6장. 열거형과 어노테이션 - 1</title>
    <link href="https://wickso.me/2017/08/05/enums-and-annotations-1/"/>
    <id>https://wickso.me/2017/08/05/enums-and-annotations-1/</id>
    <published>2017-08-05T01:00:00.000Z</published>
    <updated>2017-09-17T11:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/08/05/enums-and-annotations-1/#규칙-30-int-상수-대신-enum을-사용하라">규칙 30</a> - int 상수 대신 enum을 사용하라<br><a href="../../../../2017/08/05/enums-and-annotations-1/#규칙-31-ordinal-대신-객체-필드를-사용하라">규칙 31</a> - ordinal 대신 객체 필드를 사용하라<br><a href="../../../../2017/08/05/enums-and-annotations-1/#규칙-32-비트-필드-bit-field-대신-EnumSet을-사용하라">규칙 32</a> - 비트 필드(bit field) 대신 EnumSet을 사용하라<br><a href="../../../../2017/08/05/enums-and-annotations-1/#규칙-33-ordinal을-배열-첨자로-사용하는-대신-EnumMap을-이용하라">규칙 33</a> - ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라<br><a href="../../../../2017/08/05/enums-and-annotations-1/#규칙-34-확장-가능한-enum을-만들어야-한다면-인터페이스를-이용하라">규칙 34</a> - 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="규칙-30-int-상수-대신-enum을-사용하라"><a href="#규칙-30-int-상수-대신-enum을-사용하라" class="headerlink" title="규칙 30. int 상수 대신 enum을 사용하라"></a>규칙 30. int 상수 대신 enum을 사용하라</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_FUJI = <span class="number">0</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_PIPPIN = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>예전처럼 int/String enum 패턴을 사용하면,</p>
<ul>
<li>상수의 값이 바뀌면 클라이언트도 다시 컴파일 해야한다</li>
<li>디버깅이 어렵다(문자열로 변환해야하는 번거로움)</li>
</ul>
<h4 id="enum-자료형"><a href="#enum-자료형" class="headerlink" title="enum 자료형"></a>enum 자료형</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Apple &#123; FUJI, PIPPIN &#125;</div></pre></td></tr></table></figure>
<ul>
<li>자료형의 개체 수는 엄격히 통제된다(규칙 1)</li>
<li>싱글턴 패턴을 일반화한 것이다(규칙 3)</li>
<li>형안정 enum 패턴(typesafe enum pattern)을 자바 문법에 포함시킨 것이다(규칙 21)</li>
<li>임의의 메서드나 필드도 추가할 수 있다</li>
<li>임의의 인터페이스를 구현할 수 있다</li>
<li>Object에 정의된 모든 헤서드들이 포함되어 있다(3장 내용 전부)</li>
<li>Comparable 인터페이스와(규칙 12) Serializable 인터페이스(11장)가 구현되어 있다</li>
<li>직렬화 형식은 enum 자료형상의 변화 대부분을 견딜 수 있도록 설계되어 있다</li>
<li>문자열로 쉽게 변환할 수 있다</li>
<li>enum 자료형은 상수 묶음에서 출발해서 점차로 완전한 기능을 갖춘 추상화 단위로 진화해 나갈 수 있다</li>
<li>enum은 원래 변경 불가능하므로 모든 필드는 final로 선언되어야 한다(규칙 15)</li>
<li>필드는 private로 선언하고 public 접근자를 두는 편이 더 낫다(규칙 14)</li>
<li>특정한 클래스에서만 쓰인다면 해당 클래스의 맴버클래스로 선언하라(규칙 22)</li>
<li>외부(external) enum 자료형 상수별로 달리 동작하는 코드를 만들어야 할 때는 enum 상수에 switch문을 적용하면 좋다</li>
<li>일반적으로 enum은 int 상수와 성능면에서 비등하다</li>
<li><strong>고정된 상수 집합이 필요할 때 enum을 사용하라</strong></li>
</ul>
<h4 id="활용"><a href="#활용" class="headerlink" title="활용"></a>활용</h4><ul>
<li>상수별 클래스 몸체안에 메서드 재정의: 상수별 메서드 구현(constant-specific method impelementation)</li>
<li>전략 enum(strategy enum)</li>
</ul>
<hr>
<h2 id="규칙-31-ordinal-대신-객체-필드를-사용하라"><a href="#규칙-31-ordinal-대신-객체-필드를-사용하라" class="headerlink" title="규칙 31. ordinal 대신 객체 필드를 사용하라"></a>규칙 31. ordinal 대신 객체 필드를 사용하라</h2><ul>
<li>모든 <code>enum</code>에는 <code>ordinal()</code>이 있음.</li>
<li><code>ordinal()</code>은 자료형 안에서 <code>enum</code>상수의 위치를 나타내는 정수값을 반환하는 메서드.</li>
</ul>
<h4 id="as-is"><a href="#as-is" class="headerlink" title="as-is"></a>as-is</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Medal &#123;</div><div class="line">  GOLD, SILVER, BRONZE;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ordinal() + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>상수로 사용할 값은 <code>ordinal()</code>를 사용하지 말고, 객체 필드(instance field)에 저장하라.</p>
<h4 id="to-be"><a href="#to-be" class="headerlink" title="to-be"></a>to-be</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Medal &#123;</div><div class="line">  GOLD(<span class="number">1</span>), SILVER(<span class="number">2</span>), BRONZE(<span class="number">3</span>);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rank;</div><div class="line"></div><div class="line">  Medal(<span class="keyword">int</span> rank) &#123;</div><div class="line">    <span class="keyword">this</span>.rank = rank;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> rank;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// lombok</span></div><div class="line"><span class="meta">@AllArgsConstructor</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Medal &#123;</div><div class="line">  GOLD(<span class="number">1</span>), SILVER(<span class="number">2</span>), BRONZE(<span class="number">3</span>);</div><div class="line"></div><div class="line">  <span class="meta">@Getter</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rank;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>자바의 <code>Enum</code> 관련 명세에 <code>ordinal()</code>에 대해 이렇게 설명되어 있다.</p>
<blockquote>
<p>대부분의 프로프래머는 이 메서드를 사용할 일이 없을 것이다. <code>EnumSet</code>이나 <code>EnumMap</code>처럼 일반적인 용도의 enum 기반 자료 구조에서 사용할 목적으로 설계한 메서드다.</p>
</blockquote>
<hr>
<h2 id="규칙-32-비트-필드bit-field-대신-enumset을-사용하라"><a href="#규칙-32-비트-필드-bit-field-대신-EnumSet을-사용하라" class="headerlink" title="규칙 32. 비트 필드(bit field) 대신 EnumSet을 사용하라"></a>규칙 32. 비트 필드(bit field) 대신 EnumSet을 사용하라</h2><h4 id="as-is"><a href="#as-is-1" class="headerlink" title="as-is"></a>as-is</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOLD          = <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 0001</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITALIC        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// 0010</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNDERLINE     = <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 0100</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRIKETHROUGH = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 1000</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(<span class="keyword">int</span> style)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">text.applyStyles(Text.BOLD | Text.ITALIC);</div></pre></td></tr></table></figure>
<p><strong>장점</strong></p>
<ul>
<li>비트 필드로 나타내면 비트 단위 산술 연산을 통해 집합 연산을 효율적으로 실행할 수 있다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>int enum 패턴과 똑같은 단점(규칙 30)</li>
<li>비트 필드를 출력한 결과는 int enum 상수를 출력한 결과보다 이해하기 어려움</li>
<li>비트 필드에 포함된 모든 요소를 순차적으로 살펴보기도 어려움</li>
</ul>
<h4 id="to-be"><a href="#to-be-1" class="headerlink" title="to-be"></a>to-be</h4><p><code>EnumSet</code>을 사용하자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 어느 Set 객체도 인자로 전달할 수 있으나, EnumSet이 분명 최선</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</div></pre></td></tr></table></figure>
<p><strong>장점</strong></p>
<ul>
<li><code>Set</code> 인터페이스를 구현하기 때문에 <code>Set</code>의 기능 제공</li>
<li>형 안전성, 다른 Set 구현들과 같은 수준의 상호운용성(interoperability) 제공</li>
<li>내부적으로 bit vector 사용<ul>
<li>enum 갯수가 64 이하인 경우 <code>EnumSet</code>은 long 값 하나만 사용. 그러므로, 비트 필드에 필적하는 성능이 나옴.</li>
<li><code>removeAll()</code>이나 <code>retainAll()</code> 같은 일괄 연산도 비트 단위 산술 연산을 통해 구현</li>
</ul>
</li>
</ul>
<p><strong>특징</strong></p>
<ul>
<li>인자가 Set을 받도록 선언<ul>
<li>인자의 자료형으로는 클래스보다 인터페이스가 좋다(규칙 52) &gt; 다형성</li>
<li>클래스를 사용하면 특정한 구현에 종속</li>
<li>인터페이스를 자료형으로 쓰는 습관을 들이면 프로그램은 더욱 유연해짐</li>
<li>적당한 인터페이스가 없는 경우에는 객체를 클래스로 참조하는 것이 당연</li>
</ul>
</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>자바 1.6에서는 immutable EnumSet 객체를 만들 수 없음<ul>
<li>Collections.unmodifiableSet으로 포장하거나, Guava 라이브러리(Google) 사용</li>
</ul>
</li>
</ul>
<hr>
<h2 id="규칙-33-ordinal을-배열-첨자로-사용하는-대신-enummap을-이용하라"><a href="#규칙-33-ordinal을-배열-첨자로-사용하는-대신-EnumMap을-이용하라" class="headerlink" title="규칙 33. ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라"></a>규칙 33. ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라</h2><p><strong>as-is</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Herb[] garden = ...;</div><div class="line">Set&lt;Herb&gt;[] herbsByType = (Set&lt;Herb&gt;[]) <span class="keyword">new</span> Set[Herb.Type.values().length];</div><div class="line"></div><div class="line"><span class="comment">// 배열 초기화</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; herbsByType.length; i++) &#123;</div><div class="line">  herbsByType[i] = <span class="keyword">new</span> HashSet&lt;Herb&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (Herb h : garden) &#123;</div><div class="line">  herbsByType[h.type.ordinal()].add(h);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; herbsByType.length; i++) &#123;</div><div class="line">  System.out.println(Herb.Type.values()[i] + <span class="string">": "</span> + herbsByType[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>ordinal()</code>를 그냥 왠만하면 사용하지 말자.</li>
</ul>
<p><strong>to-be</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;Herb.Type, Set&lt;Herb&gt;&gt; herbsByType = <span class="keyword">new</span> EnumMap&lt;Herb.Type, Set&lt;Herb&gt;&gt;(Herb.Type.class);</div><div class="line"></div><div class="line"><span class="comment">// 배열 초기화</span></div><div class="line"><span class="keyword">for</span> (Herb.Type t : Herb.Type.values()) &#123;</div><div class="line">  herbsByType.pyt(t, <span class="keyword">new</span> HashSet&lt;Herb&gt;());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (Herb h : garden) &#123;</div><div class="line">  herbsByType.get(h.type).add(h);</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println(herbsByType);</div></pre></td></tr></table></figure>
<ul>
<li>속도면에서도 별 차이 없음</li>
<li><code>EnumMap</code> 생성자는 키워 자료형을 나타내는 Class 객체를 인자로 받음<ul>
<li>이런 Class 객체를 한정적 자료형 토큰(bounded type token)이라 부르는데, 실행시점 제네릭 자료형 정보를 제공한다(규칙 29).</li>
</ul>
</li>
<li><code>ordinal()</code> 값을 배열 인덱스로 사용하지 말고, <code>EnumMap</code>을 쓰자</li>
</ul>
<hr>
<h2 id="규칙-34-확장-가능한-enum을-만들어야-한다면-인터페이스를-이용하라"><a href="#규칙-34-확장-가능한-enum을-만들어야-한다면-인터페이스를-이용하라" class="headerlink" title="규칙 34. 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라"></a>규칙 34. 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라</h2><ul>
<li>계승 가능 enum 자료형은 만들 수 없지만, 인퍼테이스를 만들고 그 인터페이스를 구현하는 기본 enum 자료형을 만들면 흉내낼 수 있다.</li>
<li>많은 부분이 까다로워지지만, 연산 코드(opcode)를 만들어야 할 때 사용하기 좋다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/08/05/enums-and-annotations-1/#규칙-30-int-상수-대신-enum을-사용하라&quot;&gt;규칙 30&lt;/a&gt; - int 상수 대신 enum을 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/08/05/enums-and-annotations-1/#규칙-31-ordinal-대신-객체-필드를-사용하라&quot;&gt;규칙 31&lt;/a&gt; - ordinal 대신 객체 필드를 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/08/05/enums-and-annotations-1/#규칙-32-비트-필드-bit-field-대신-EnumSet을-사용하라&quot;&gt;규칙 32&lt;/a&gt; - 비트 필드(bit field) 대신 EnumSet을 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/08/05/enums-and-annotations-1/#규칙-33-ordinal을-배열-첨자로-사용하는-대신-EnumMap을-이용하라&quot;&gt;규칙 33&lt;/a&gt; - ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/08/05/enums-and-annotations-1/#규칙-34-확장-가능한-enum을-만들어야-한다면-인터페이스를-이용하라&quot;&gt;규칙 34&lt;/a&gt; - 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 5장. 제네릭 - 2</title>
    <link href="https://wickso.me/2017/06/14/generics-2/"/>
    <id>https://wickso.me/2017/06/14/generics-2/</id>
    <published>2017-06-14T01:00:00.000Z</published>
    <updated>2017-06-28T02:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/06/14/generics-2/#26-가능하면-제네릭-자료형으로-만들-것">규칙 26</a> - 가능하면 제네릭 자료형으로 만들 것<br><a href="../../../../2017/06/14/generics-2/#27-가능하면-제네릭-메서드로-만들-것">규칙 27</a> - 가능하면 제네릭 메서드로 만들 것<br><a href="../../../../2017/06/14/generics-2/#28-한정적-와일드카드를-써서-API-유연성을-높여라">규칙 28</a> - 한정적 와일드카드를 써서 API 유연성을 높여라<br><a href="../../../../2017/06/14/generics-2/#29-">규칙 29</a> - 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="26-가능하면-제네릭-자료형으로-만들-것"><a href="#26-가능하면-제네릭-자료형으로-만들-것" class="headerlink" title="26. 가능하면 제네릭 자료형으로 만들 것"></a>26. 가능하면 제네릭 자료형으로 만들 것</h2><p><strong>제네릭화<sub>gernerification</sub></strong></p>
<p>선언부에 type parameter 추가, 관습적으로 자료형을 나타내는 이름 E(규칙 56)</p>
<p><strong>배열을 사용하는 제네릭 자료형에서 발생하는 오류를 피하는 방법</strong></p>
<p>실체화 불가능 자료형으로는 배열을 생성할 수 없다(규칙 25).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack.java:<span class="number">8</span> generic array creation</div><div class="line">    elements = <span class="keyword">new</span> E[DEFAULT_INITIAL_CAPACITY];</div></pre></td></tr></table></figure>
<ol>
<li><p>Object 배열을 만들어서 제네릭 배열 자료형으로 형변환(cast)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack.java:<span class="number">8</span>: warning: [unchecked] unchecked cast</div><div class="line">found   : Object[], required: E[]</div><div class="line">        elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</div></pre></td></tr></table></figure>
<p> cast를 활용하면 컴파일 오류대신 경고가 발생한다. 문법적으로 문제는 없지만, 일반적으로 형 안전성을 보장하는 방법이 아니다.<br> 하지만 해당 형변환이 프로그램의 형 안전성을 해치지 않는다면 무점검 형변환(unchecked cast)을 한다. 무점검 형전황이 안전함을 증명했다면, 경고를 억제하되 범위는 최소한으로 줄여야 한다(규칙 24).</p>
</li>
<li><p>elements의 자료형을 E[]에서 Object[]로 바꾸는 것이다.</p>
<p> 사용하는 곳마다 Object를 E로 cast 해준다.</p>
</li>
</ol>
<p>제네릭 배열 생성 오류를 피하는 방법중 어떤 것을 쓸지는 취향 문제다. 배열을 사용하는 코드가 클래스 이곳저곳에 흩어져 있다면 첫번째 방법으로는 한번만 형변환하면 되지만, 두 번째는 여기저기서 형변환해야 한다. 그래서 첫 번째 방법이 좀 더 보편적으로 쓰인다[Naftalin07, 6.7]</p>
<p><strong>기타</strong></p>
<ul>
<li>형인자 자료형에 primitive type은 사용할 수 없다. 자바 제네릭 자료형 시스템의 근본적 한계 때문이다. 이런 제약을 피하려면 개체화된 기본 자료형(boxed primitive type)을 사용하면 된다(<a href="">규칙 49</a>).</li>
<li>시간 있을 때마다 기존 자료형을 제네릭 자료형으로 변환하라. 기존 클라이언트 코드를 깨지 않ㄷ고도 새로운 사용자에게 더 좋은 API를 제공할 수 있게 될 것이다(<a href="">규칙 23</a>).</li>
<li><p>형인자를 제한하는 자료형: 아래 코드에서 E를 한정적 형인자(bounded type parameter)라 한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;E extends String&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="27-가능하면-제네릭-메서드로-만들-것"><a href="#27-가능하면-제네릭-메서드로-만들-것" class="headerlink" title="27. 가능하면 제네릭 메서드로 만들 것"></a>27. 가능하면 제네릭 메서드로 만들 것</h2><blockquote>
<p>형인자를 선언하는 type parameter list는 메서드의 수정자(modifier)와 반환값 자료형 사이에 둔다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</div><div class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;E&gt;(s1);</div><div class="line">    result.addAll(s2);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>제네릭 메서드를 호출할 때는 형인자는 전달할 필요가 없다. 컴파일러가 메서드에 전해진 인자의 자료형을 보고 형인자의 값을 알아낸다. 이 과정을 자료형 유추(type inference)라 한다.</p>
<h4 id="generic-singleton-pattern"><a href="#Generic-Singleton-pattern" class="headerlink" title="Generic Singleton pattern"></a>Generic Singleton pattern</h4><p><strong>변경이 불가능하지만 많은 자료형에 적용 가능한 객체를 만들어야 할 때 사용.</strong></p>
<p>제네릭은 자료형 삭제(erasure) 과정을 통해 구현되므로(<a href="">규칙 25</a>) 모든 필요한 형인자화(type parameterization) 과정에 동일 객체를 활용할 수 있는데, 그러려면 우선 필요한 형인자화 과정마다 같은 객체를 나눠주는 정적 팩터리 메서드를 자성해야 한다. 이 패턴은 Collections.reverseOrder 같은 함수 객체(<a href="">규칙 23</a>) 구현에 가장 널리 사용되지만, Collections.emptySet과 같은 컬렉션에도 쓰인다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnaryFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T arg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>항등함수: 받은것 그대로 반환하는 함수<br>제네릭 정적 팰터리 메서드를 사용하면 중복되는 형인자를 제거하여 간결한 코드를 만들 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 제네릭 싱글턴 팩터리 패턴</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> UnaryFunction&lt;Object&gt; IDENTIFY_FUNCTION = <span class="keyword">new</span> UnaryFunction&lt;Object&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(Object arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> arg;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// IDENTIFY_FUNCTION은 무상태 객체고 형인자는 비한정 인자이므로(unbounded)</span></div><div class="line"><span class="comment">// 모든 자료형이 같은 객체를 공유해도 안전하다.</span></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryFunction&lt;T&gt; <span class="title">identityFunction</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (UnaryFunction&lt;T&gt;) IDENTIFY_FUNCTION;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="recursive-type-bound"><a href="#Recursive-type-bound" class="headerlink" title="Recursive type bound"></a>Recursive type bound</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;T extends Comarable&lt;T&gt;&gt;</div></pre></td></tr></table></figure>
<p>위 코드처럼 Type parameter의 범위에 자기자신이 포험된 표현으로, 그 범위가 선언되는 것을 말한다.</p>
<hr>
<h2 id="28-한정적-와일드카드를-써서-api-유연성을-높여라"><a href="#28-한정적-와일드카드를-써서-API-유연성을-높여라" class="headerlink" title="28. 한정적 와일드카드를 써서 API 유연성을 높여라"></a>28. 한정적 와일드카드를 써서 API 유연성을 높여라</h2><p><strong>요약</strong></p>
<ul>
<li><code>Comparable</code>과 <code>Comparator</code>는 소비자이다.</li>
<li><p>유연성을 최대화하려면, 객체 생산자<sub>producer</sub>나 소비자<sub>consumer</sub> 구실을 하는 메서드 인자의 자료형은 와일드 카드 자료형으로 해라.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">PECS (Produce - Extends, Consumer - Super)</div></pre></td></tr></table></figure>
</li>
<li><p>클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스 API가 잘못 설계된 탓을 것이다.</p>
</li>
</ul>
<p><em>에러가 발생하는 코드</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">Iterable&lt;Integer&gt; integers = ...;</div><div class="line">numberStack.pushAll(integers); <span class="comment">// throw exception</span></div></pre></td></tr></table></figure>
<p><em>해결방안</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (E e : src) &#123;</div><div class="line">        push(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!isEmpty()) &#123;</div><div class="line">        dst.add(pop());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>모든 자료형은 자기 자신의 <em>하위 자료형</em>이다.</li>
<li>모든 자료형 E는 자기 자신의 상위 자료형이다([JLS, 4.10]).</li>
</ul>
<p><strong>이원성(duality)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// swap메서드를 선언하는 두 가지 방법</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>간단한 두번째 방법이 더 바람직하다.</li>
<li><code>List&lt;?&gt;</code>에는 null 이외의 어떤 값도 넣을 수 없다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    swapHelper(list, i, j);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 와일드카드 자료형을 포착하기 위한 private helper 메서드</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    list.set(i, list.set(j, list.get(i)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="29-형-안전-다형성-컨테이너를-쓰면-어떨지-따져보라"><a href="#29-형-안전-다형성-컨테이너를-쓰면-어떨지-따져보라" class="headerlink" title="29. 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라"></a>29. 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 형 안전 다형성(heterogeneous) 컨테이너 패턴 - API</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavority</span><span class="params">(Class&lt;T&gt; type)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>보통 형인자는 각 키/값에 대해서 하나씩 필요하다. 하지만 <code>Class</code> 객체로 좀 더 유연하게 사용할 수 있다. 그런 class 리터럴을 <em>자료형 토큰(type token)</em>이라 부른다[Bracha04].</p>
<p>Favorites 객체는 형 안전성을 보장한다. 또한 다형성(heterogeneous)을 갖고 있다. 일반적인 맵과 달리, 모든 키의 자료형이 서로 다르다. 따라서 이러한 클래스를 <em>형 안전 다형성 컨테이너(typesafe heterogeneous container)</em>라 부른다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 형 안전 다형성(heterogeneous) 컨테이너 패턴 - 구현</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</div><div class="line">        favorites.put(type, type.cast(instance)); <span class="comment">// 값에 동적형변환을 하는 이유: 형 안전성 확보</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavority</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Favorites 객체는 내부적으로 <code>private Map&lt;Class&lt;?&gt;, Object&gt;</code> 형의 favorites 필드를 이용한다. 그런데 비한정적 와일드카드 자료형을 사용했으니 이 맵에는 아무것도 넣을 수 없을 것 같지만, 와일드카드 자료형이 쓰인 곳은 맵이 아니라 키다. 다형성이 드러나는 곳이 이곳이다.</li>
<li><p>favorites 맵의 값 자료형이 Object인데, 키와 값 사이의 자료형이 일치되는 것을 보장하지 않는다. 하지만 실제로는 자료형이 같다는 것을 알고 있으므로, 저장된 객체를 꺼낼 때 그 사실을 이용할 수 있다. -&gt; 동적 형변환(dynamic cast)</p>
</li>
<li><p>Favorites 클래스의 단점으로 실체화 불가능 자료형(non-reifiable type)에는 쓰일 수 없다(규칙 25). 따라서 <code>String</code>이나 <code>String[]</code>은 저장할 수 있으나 <code>List&lt;String&gt;</code>은 저장할 수 없다. 이유는 <code>List&lt;String&gt;</code>의 Class 객체를 얻을 수 없기 때문이다.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/06/14/generics-2/#26-가능하면-제네릭-자료형으로-만들-것&quot;&gt;규칙 26&lt;/a&gt; - 가능하면 제네릭 자료형으로 만들 것&lt;br&gt;&lt;a href=&quot;../../../../2017/06/14/generics-2/#27-가능하면-제네릭-메서드로-만들-것&quot;&gt;규칙 27&lt;/a&gt; - 가능하면 제네릭 메서드로 만들 것&lt;br&gt;&lt;a href=&quot;../../../../2017/06/14/generics-2/#28-한정적-와일드카드를-써서-API-유연성을-높여라&quot;&gt;규칙 28&lt;/a&gt; - 한정적 와일드카드를 써서 API 유연성을 높여라&lt;br&gt;&lt;a href=&quot;../../../../2017/06/14/generics-2/#29-&quot;&gt;규칙 29&lt;/a&gt; - 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 5장. 제네릭 - 1</title>
    <link href="https://wickso.me/2017/05/21/generics-1/"/>
    <id>https://wickso.me/2017/05/21/generics-1/</id>
    <published>2017-05-21T01:00:00.000Z</published>
    <updated>2017-08-05T08:26:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/05/21/generics-1/#23-새-코드에는-무인자-제네릭-자료형을-사용하지-마라">규칙 23</a> - 새 코드에는 무인자 제네릭 자료형을 사용하지 마라<br><a href="../../../../2017/05/21/generics-1/#24-무점검-경고-unchecked-warning-를-제거하라">규칙 24</a> - 무점검 경고(unchecked warning)를 제거하라<br><a href="../../../../2017/05/21/generics-1/#25-배열-대신-리스트를-써라">규칙 25</a> - 배열 대신 리스트를 써라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h4 id="제네릭-관련-규칙-목록"><a href="#제네릭-관련-규칙-목록" class="headerlink" title="제네릭 관련 규칙 목록"></a>제네릭 관련 규칙 목록</h4><table>
<thead>
<tr>
<th>용어</th>
<th>예</th>
<th>규칙</th>
</tr>
</thead>
<tbody>
<tr>
<td>형인자 자료형<sub>parameterized type</sub></td>
<td><code>List&lt;String&gt;</code></td>
<td>23</td>
</tr>
<tr>
<td>실 형인자<sub>actual type parameter</sub></td>
<td><code>String</code></td>
<td>23</td>
</tr>
<tr>
<td>제네릭 자료형<sub>generic type</sub></td>
<td><code>List&lt;E&gt;</code></td>
<td>23, 26</td>
</tr>
<tr>
<td>형식 형인자<sub>formal type parameter</sub></td>
<td><code>E</code></td>
<td>23</td>
</tr>
<tr>
<td>비한정적 와일드 카드 자료형<sub>unbounded wildcard type</sub></td>
<td><code>List&lt;?&gt;</code></td>
<td>23</td>
</tr>
<tr>
<td>무인자 자료형<sub>row type</sub></td>
<td><code>List</code></td>
<td>23</td>
</tr>
<tr>
<td>한정적 형인자<sub>bounded type parameter</sub></td>
<td><code>&lt;E extends Number&gt;</code></td>
<td>276</td>
</tr>
<tr>
<td>재귀적 형 한정<sub>recursive type bound</sub></td>
<td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td>
<td>27</td>
</tr>
<tr>
<td>한정적 와일드카드 자료형<sub>bounded wildcard type</sub></td>
<td><code>List&lt;? extends Number&gt;</code></td>
<td>28</td>
</tr>
<tr>
<td>제네릭 메서드<sub>generic method</sub></td>
<td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td>
<td>27</td>
</tr>
<tr>
<td>자료형 토큰<sub>type token</sub></td>
<td><code>String.class</code></td>
<td>29</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="23-새-코드에는-무인자-제네릭-자료형을-사용하지-마라"><a href="#23-새-코드에는-무인자-제네릭-자료형을-사용하지-마라" class="headerlink" title="23. 새 코드에는 무인자 제네릭 자료형을 사용하지 마라"></a>23. 새 코드에는 무인자 제네릭 자료형을 사용하지 마라</h2><blockquote>
<p>Java 1.5부터 사용</p>
</blockquote>
<h4 id="제네릭generic-클래스인터페이스-제네릭-자료형generic-type"><a href="#제네릭generic-클래스-인터페이스-제네릭-자료형generic-type" class="headerlink" title="제네릭generic 클래스/인터페이스 = 제네릭 자료형generic type"></a>제네릭<sub>generic</sub> 클래스/인터페이스 = 제네릭 자료형<sub>generic type</sub></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>선언부에 형인자<sub>type parameter</sub>가 포함된 클래스나 인터페이스를 말한다[JLS, 8.1.2, 9.1.2].</li>
<li>“E의 리스트”라고 읽는다.</li>
</ul>
<h4 id="형인자-자료형parameterized-type"><a href="#형인자-자료형parameterized-type" class="headerlink" title="형인자 자료형parameterized type"></a>형인자 자료형<sub>parameterized type</sub></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; stringList = ...;</div></pre></td></tr></table></figure>
<ul>
<li>각 제네릭 자료형은 <em>형인자 자료형</em> 집합을 정의한다.</li>
<li>이 집합은 이름 뒤에 &lt; 와 &gt; 기호로 감싼 <em>실 형인자</em> 목록이 붙은 클래스나 인터페이스 들로 구성되는데, 이 실 인자들은 제네릭 자료형의 <em>형식 형인자</em> 각각에 대응된다[JLS, 4.4, 4.5].</li>
<li>컴파일 할 때 어떤 경고도 뜨지 않아야(또는, suppressing 경고가 없어야 - 규칙 24 참조) 한다.</li>
</ul>
<h4 id="무인자-자료형raw-type"><a href="#무인자-자료형raw-type" class="headerlink" title="무인자 자료형raw type"></a>무인자 자료형<sub>raw type</sub></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List stringList = ...;</div></pre></td></tr></table></figure>
<ul>
<li>무인자 자료형은 실 형인자 없이 사용되는 제네릭 자료형이다[JLS, 4.8].</li>
<li>위 코드에서 <code>List</code>가 무인자 자료형(stringList는 String 객체만 보관되는데 형인자 자료형을 정의하지 않음)  <div class="tip"><br>      <b><code>List</code> vs <code>List&lt;Object&gt;</code></b><br>      <ul><br>          <li><code>List</code>: 형 검사 절차를 완전히 생략</li><br>          <li><code>List&lt;Object&gt;</code>: 아무 객체나 넣을 수 있다는 것을 컴파일에게 알림</li><br>      </ul><br>  </div></li>
<li><strong>이렇게 사용하지 말자</strong>(엉뚱한 자료형의 객체를 넣어도 컴파일 시에는 문제가 없다).</li>
<li>무인자 자료형을 쓰면 형 안전성이 사라지고, 제네릭의 장점 중 하나인 표현력<sub>expreesiveness</sub> 측면에서 손해를 보게 된다.<ul>
<li>이전 호환성<sub>migration compatibility</sub>으로 알려지니 이 요구사항 때문에 무인자 자료형을 지원할 뿐</li>
</ul>
</li>
</ul>
<h4 id="비한정적-와일드카드-자료형unbounded-wildcard-type"><a href="#비한정적-와일드카드-자료형unbounded-wildcard-type" class="headerlink" title="비한정적 와일드카드 자료형unbounded wildcard type"></a>비한정적 와일드카드 자료형<sub>unbounded wildcard type</sub></h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numElementsInCommon</span><span class="params">(Set&lt;?&gt; s1, Set&lt;?&gt; s2)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Object o1: s1)</div><div class="line">        <span class="keyword">if</span> (s2.contains(o1))</div><div class="line">            result++;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>제네릭 자료형을 쓰고 싶으나 실제 형 인자가 무엇인지 모르거나 신경 쓰고 싶지 않을 때 ‘?’ 사용</li>
<li>그러나, Collection&lt;?&gt;에는 null 이외의 어떤 원소도 넣을 수 없다<ul>
<li>(옮긴이) 어떤 자료형의 객체를 담는 컬렉션인지 알 방법이 없기 때문이다.</li>
<li>TODO: 자세한 내용 확인해볼 것</li>
</ul>
</li>
</ul>
<h4 id="예외"><a href="#예외" class="headerlink" title="예외"></a>예외</h4><p>제네릭 자료형 정보가 프로그램이 실행될 때는 지워지기 때문에(타입소거<sub>type erasure</sub>) 생긴 예외들(규칙 25)</p>
<p><strong>클래스 리터럴<sub>class literal</sub>에는 반드시 무인자 자료형을 사용해야 한다.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 가능</span></div><div class="line">List.class</div><div class="line">String[].class <span class="comment">// 배열 자료형 가능</span></div><div class="line"><span class="keyword">int</span>.class <span class="comment">// 기본 자료형 가능</span></div><div class="line"></div><div class="line"><span class="comment">// 불가능</span></div><div class="line">List&lt;String&gt;.class</div><div class="line">List&lt;?&gt;.class</div></pre></td></tr></table></figure>
<ul>
<li>자바 표준에 따르면, 클래스 리터럴에는 형인자 자료형을 쓸 수 없다[JLS, 15.8.2].</li>
</ul>
<p><strong>제네릭 자료형에 instanceof 연산자를 적용할 때는 다음과 같이 하는 것이 좋다.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set) &#123;     <span class="comment">// 무인자 자료형</span></div><div class="line">    Set&lt;?&gt; m = (Set&lt;?&gt;) o;  <span class="comment">// 와일드카드 자료형</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>실행시 타입소거되기 때문에, instanceof 연산자를 비한정적 와일드 카드 자료형이 이외의 형인자 자료형에 적용할 수 없다.</li>
<li>무인자 자료형 대신 비한정적 와일드카드 자료형을 쓴다고 해서 instanceof 연산자가 다르게 동작하는 것은 아니다.</li>
<li>따라서 &lt;?&gt;를 붙혀봐야 코드만 지저분해질 뿐이다.</li>
</ul>
<hr>
<h2 id="24-무점검-경고unchecked-warning를-제거하라"><a href="#24-무점검-경고-unchecked-warning-를-제거하라" class="headerlink" title="24. 무점검 경고(unchecked warning)를 제거하라"></a>24. 무점검 경고(unchecked warning)를 제거하라</h2><blockquote>
<p>무점검 경고<sub>unchecked warning</sub>는 중요하다. 무시하지 마라.</p>
</blockquote>
<ul>
<li>모든 무점검 경고는 가능하다면 없애야 한다.<ul>
<li>전부 없애고 나면 코드의 형 안전서이 보장되는 것</li>
<li>실행 도중 ClassCastException이 발생하지 않을 것</li>
</ul>
</li>
<li>제거할 수 없는 경고 메시지는 형 안전성이 확실할 때만 @SupressWarnings(“unchecked”) 어노테이션을 사용해 억제한다<ul>
<li>SupressWarnings 어노테이션은 가능한 작은 범위에 적용하라.</li>
<li>SupressWarnings 어노테이션은 return 문에는 붙일 수 없는데, 선언문이 아니기 떄문이다[<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7" rel="external nofollow noopener noreferrer" target="_blank">JLS, 9.7</a>].</li>
</ul>
</li>
<li>@SupressWarnings(“unchecked”) 어노테이션을 사용할 때마다, 왜 형 안정성을 위반하지 않는지 밝히는 주석을 반드시 붙여라</li>
</ul>
<hr>
<h2 id="25-배열-대신-리스트를-써라"><a href="#25-배열-대신-리스트를-써라" class="headerlink" title="25. 배열 대신 리스트를 써라"></a>25. 배열 대신 리스트를 써라</h2><h4 id="배열-vs-제네릭-자료형"><a href="#배열-vs-제네릭-자료형" class="headerlink" title="배열 vs 제네릭 자료형"></a>배열 vs 제네릭 자료형</h4><ul>
<li>배열은 <em>공변 자료형<sub>covariant</sub></em>: <code>class Sub extends Super {}</code>일 때, <code>Sub[]</code>도 <code>Super[]</code>의 하위 자료형이다.</li>
<li>제네릭은 <em>불변 자료형<sub>invariant</sub></em>: <code>List&lt;Sub&gt;</code>은 <code>List&lt;Super&gt;</code>의 하위 자료형이 될 수 없다.</li>
</ul>
<p>아래 코드와 같이, 배열의 경우에는 문법적으로는 문제가 없어 실행중에 예외가 발생하고, 제네릭은 컴파일이 되지 않는다. 즉, 제네릭보다 배열이 취약하다(컴파일시에 문제를 발견하는 편이 더 낫다).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 실행중에 예외 발생</span></div><div class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</div><div class="line">objectArray[<span class="number">0</span>] = <span class="string">"I dont's fit in"</span>; <span class="comment">// ArrayStoreException 발생</span></div><div class="line"></div><div class="line"><span class="comment">// 컴파일 되지 않는 코드</span></div><div class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;(); <span class="comment">// 자료형 불일치</span></div><div class="line">ol.add(<span class="string">"I don't fit in"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>배열은 <em>실체화<sub>reification</sub></em> 되는 자료형이다[<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.7" rel="external nofollow noopener noreferrer" target="_blank">JLS, 4.7</a>].<ul>
<li>즉, 배열의 각 원소의 자료형은 실행시간에 결정</li>
</ul>
</li>
<li>제네릭은 삭제<sub>erasure</sub> 과정을 통해 구현된다[<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6" rel="external nofollow noopener noreferrer" target="_blank">JLS, 4.6</a>].</li>
</ul>
<h4 id="generic-array-creation-오류"><a href="#generic-array-creation-오류" class="headerlink" title="generic array creation 오류"></a>generic array creation 오류</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> List&lt;E&gt;[]</div><div class="line"><span class="keyword">new</span> List&lt;String&gt;[]</div><div class="line"><span class="keyword">new</span> E[]</div></pre></td></tr></table></figure>
<p>위 코드는 전부 컴파일되지 않는다. 컴파일하려고 하면 <code>getneric array creation</code> 오류가 발생할 것이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/05/21/generics-1/#23-새-코드에는-무인자-제네릭-자료형을-사용하지-마라&quot;&gt;규칙 23&lt;/a&gt; - 새 코드에는 무인자 제네릭 자료형을 사용하지 마라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/21/generics-1/#24-무점검-경고-unchecked-warning-를-제거하라&quot;&gt;규칙 24&lt;/a&gt; - 무점검 경고(unchecked warning)를 제거하라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/21/generics-1/#25-배열-대신-리스트를-써라&quot;&gt;규칙 25&lt;/a&gt; - 배열 대신 리스트를 써라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 4장. 클래스와 인터페이스 - 3</title>
    <link href="https://wickso.me/2017/05/15/classes-and-interfaces-3/"/>
    <id>https://wickso.me/2017/05/15/classes-and-interfaces-3/</id>
    <published>2017-05-15T01:20:00.000Z</published>
    <updated>2017-05-17T03:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/05/15/classes-and-interfaces-3/#19-인터페이스는-자료형을-정의할-때만-사용하라">규칙 19</a> - 인터페이스는 자료형을 정의할 때만 사용하라<br><a href="../../../../2017/05/15/classes-and-interfaces-3/#20-태그-달린-클래스-대신-클래스-계층을-활용하라">규칙 20</a> - 태그 달린 클래스 대신 클래스 계층을 활용하라<br><a href="../../../../2017/05/15/classes-and-interfaces-3/#21-전략을-표현하고-싶을-때는-함수-객체를-사용하라">규칙 21</a> - 전략을 표현하고 싶을 때는 함수 객체를 사용하라<br><a href="../../../../2017/05/15/classes-and-interfaces-3/#22-멤버-클래스는-가능하면-static으로-선언하라">규칙 22</a> - 멤버 클래스는 가능하면 static으로 선언하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="19-인터페이스는-자료형을-정의할-때만-사용하라"><a href="#19-인터페이스는-자료형을-정의할-때만-사용하라" class="headerlink" title="19. 인터페이스는 자료형을 정의할 때만 사용하라"></a>19. 인터페이스는 자료형을 정의할 때만 사용하라</h2><ul>
<li><p><strong>상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다.</strong> 클래스가 어떤 상수를 어떻게 사용하느냐 하는 것은 구현 세부사항이다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhysicalConstants</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> AVOGADROS_NUMBER = <span class="number">6.02214199e23</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>상수를 API 일부로 공개하고 싶을 때는 더 좋은 방법이 있다.</p>
<ul>
<li>해당 상수가 이미 존재하는 클래스나 인터페이스에 강하게 연결되어 있을 때는 해당 클래스/인터페이스에 추가한다.</li>
<li>enum 자료형의 멤버가 되어야 바람직할 때는 enum 자료형과 함께 공개한다.</li>
<li>객체 생성이 불가능한 유틸리티 클래스에 넣어서 공개한다.</li>
</ul>
</li>
<li>인터페이스는 자료형을 정의할 때만 사용해야 한다. 특정 상수를 API의 일부로 공개할 목적으로는 적절치 않다.</li>
</ul>
<hr>
<h2 id="20-태그-달린-클래스-대신-클래스-계층을-활용하라"><a href="#20-태그-달린-클래스-대신-클래스-계층을-활용하라" class="headerlink" title="20. 태그 달린 클래스 대신 클래스 계층을 활용하라"></a>20. 태그 달린 클래스 대신 클래스 계층을 활용하라</h2><h4 id="tagged-class"><a href="#Tagged-Class" class="headerlink" title="Tagged Class"></a>Tagged Class</h4><blockquote>
<p>두 가지 이상의 기능을 가지고 있고, 그중 어떤 기능을 제공하는지 표시하는 tag가 달린 클래스</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</div><div class="line">    <span class="keyword">enum</span> Shape &#123; RECTANGLE, CIRCLE &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 태그 필드</span></div><div class="line">    <span class="keyword">final</span> Shape shape;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> length;</div><div class="line">    <span class="keyword">double</span> width;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> radius;</div><div class="line"></div><div class="line">    <span class="comment">// 원을 만드는 생성자</span></div><div class="line">    Figure(<span class="keyword">double</span> radius) &#123;</div><div class="line">        shape = Shape.CIRCLE;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 사각형을 만드는 생성자</span></div><div class="line">    Figure(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</div><div class="line">        shape = Shape.RECTANGLE;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span>(shape) &#123;</div><div class="line">          <span class="keyword">case</span> RECTANGLE:</div><div class="line">        	<span class="keyword">return</span> length * width;</div><div class="line">          <span class="keyword">case</span> CIRCLE:</div><div class="line">        	<span class="keyword">return</span> Math.PI * (radius * radius);</div><div class="line">          <span class="keyword">default</span>:</div><div class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>문제점</strong></p>
<ul>
<li>수정할 때마다 <code>switch</code>문에 새로운 <code>case</code>를 올바르게 넣어야 한다.</li>
<li>객체의 자료형만 봐서 그 객체가 무슨 기능을 제공하는지 알 수 없다.</li>
<li>boilerplate code가 늘어난다.</li>
<li><strong>오류 발생 가능성이 높아지고, 효율적이지 않다.</strong></li>
</ul>
<h4 id="개선-코드"><a href="#개선-코드" class="headerlink" title="개선 코드"></a>개선 코드</h4><p><em>e.g. 클래스 계층으로 변환한 결과(<a href="#item14">규칙 14</a>)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">double</span> radius;</div><div class="line"></div><div class="line">    Circle(<span class="keyword">double</span> radius) &#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.PI * (radius * radius);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// public 클래스인 경우(규칙 14)</span></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">double</span> length;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">double</span> width;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length * width; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>태그 기반 클래스 사용은 피하라.</li>
<li>태그 기반 클래스를 보게 된다면, 리팩토링을 통해 클래스 계층으로 변환할 방법은 없는지 고민하자.</li>
</ul>
<h2 id="21-전략을-표현하고-싶을-때는-함수-객체를-사용하라"><a href="#21-전략을-표현하고-싶을-때는-함수-객체를-사용하라" class="headerlink" title="21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라"></a>21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라</h2><blockquote>
<p>전략을 표현하고 싶을 때는 함수 객체<sub>function object</sub>를 사용하라<br>함수 객체의 주된 용도는 전략 패턴<sub>Strategy pattern</sub>을 구현하는 것.</p>
</blockquote>
<p><strong>strategy pattern</strong></p>
<ul>
<li>인자로 함수를 넘겨줘서 그 함수를 통해 실행 전략을 세우는 방법. 예를 들어 정렬을 한다고 할때, 어떻게 정렬하는가는 넘겨주는 것이 전략패턴.</li>
<li>Java는 함수를 넘겨 줄수 없으나, 함수를 가지고 있는 객체(=함수 객체)를 넘겨주면 됨</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 전략 인터페이스</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(T t1, T t2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>문자 길이로 하고자 할 때, 익명 클래스로 구현할 수 있으나 매번 필요없는 인스턴스를 생성함</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Arrays.sort(stringArray, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s1)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> s1.length() - s2.length();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>그렇다면, 싱글턴으로 만들어서 사용하는 방법. 의도가 뚜렷한 이름을 정할 수 있는 것도 장점.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Arrays.sort(stringArray, StringLengthComparator.INSTANCE);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringLengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringLengthComparator INSTANCE = <span class="keyword">new</span> StringLengthComparator();</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StringLengthComparator</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s1)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> s1.length() - s2.length();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>java 8 lamdba를 이용하면 코드를 좀 더 줄일 수 있음</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Comparator&lt;String&gt; stringLengthComparator = (String s1, String s2) -&gt; s1.length - s2.length;</div><div class="line">Arrays.sort(stringArray, stringLengthComparator);</div></pre></td></tr></table></figure>
<p>전략 인터페이스(<code>Comparator</code>)는 실행 가능 전략 객체들(<code>StringLengthComparator</code>)의 자료형 구실을 한다. 따라서 실행 가능 전략 클래스(<code>StringLengthComparator</code>)는 굳이 public으로 만들어 공개할 필요가 없다. 대신, 전략 인터페이스가 자료형인 public static 필드들을 갖는 “호스트 클래스(host class)”를 정의하는 것도 방법이다. 실행 가능 전략 클래스는 호스트 클래스의 private 중첩 클래스(nested class)로 정의하면 된다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR = (String s1, String s2) -&gt; s1.length - s2.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>String</code> 클래스는 <code>CASE_INSENCITIVE_ORDER</code>라는 필드로 문자열 비교자를 공개함</p>
<hr>
<h2 id="22-멤버-클래스는-가능하면-static으로-선언하라"><a href="#22-멤버-클래스는-가능하면-static으로-선언하라" class="headerlink" title="22. 멤버 클래스는 가능하면 static으로 선언하라"></a>22. 멤버 클래스는 가능하면 static으로 선언하라</h2><h4 id="중첩클래스nested-class-의-종류"><a href="#중첩클래스nested-class-의-종류" class="headerlink" title="중첩클래스nested class 의 종류"></a>중첩클래스<sub>nested class</sub> 의 종류</h4><blockquote>
<p>다른 클래스 안에 정의된 클래스</p>
</blockquote>
<ul>
<li>Static Member Class</li>
<li>Nonstatic Member Class</li>
<li>Anonymous Class</li>
<li>Local Class</li>
</ul>
<h4 id="static-member-class"><a href="#Static-Member-Class" class="headerlink" title="Static Member Class"></a>Static Member Class</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; PrivateStaticMemberClass.print(); &#125; <span class="comment">// (1)</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateStaticMemberClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">            ExternalClass e = <span class="keyword">new</span> ExternalClass();</div><div class="line">            System.out.println(e.value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMemberClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"public"</span>); &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main</span></div><div class="line"><span class="comment">// ExternalClass.PrivateStaticMemberClass.print(); (1) 불가능</span></div><div class="line">ExternalClass.StaticMemberClass.print(); <span class="comment">// (2)</span></div><div class="line">(<span class="keyword">new</span> ExternalClass()).print();</div></pre></td></tr></table></figure>
<ul>
<li>External Class의 모든 맴버에 접근 가능(private 포함)</li>
<li>Static Member Class가 <code>private</code>이라면 External Class에서만 접근 가능 (1)</li>
<li>External Class의 정적맴버 (2)</li>
</ul>
<h4 id="nonstatic-member-class"><a href="#NonStatic-Member-Class" class="headerlink" title="NonStatic Member Class"></a>NonStatic Member Class</h4><ul>
<li>External Class와 독립적으로 존재할 수 있도록 하려면 반드시 <code>static</code>으로 선언</li>
<li>문법으로는 <code>static</code> 여부 차이. 그러나 다르다.</li>
<li><p>External Class와 자동적으로 연결된다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> externalClassValue;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExternalClass</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; <span class="keyword">this</span>.externalClassValue = value; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getExternalClassValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> externalClassValue; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(externalClassValue);</div><div class="line">        NonStaticMemberClass nsmc = <span class="keyword">new</span> NonStaticMemberClass(); <span class="comment">// (3)</span></div><div class="line">        nsmc.setExternalClassValue(<span class="number">3</span>);</div><div class="line">        System.out.println(externalClassValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NonStaticMemberClass</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> nonStaticMemberClassValue;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setExternalClassValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">            ExternalClass.<span class="keyword">this</span>.externalClassValue = value; <span class="comment">// (2)</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main</span></div><div class="line">ExternalClass t = <span class="keyword">new</span> ExternalClass(<span class="number">2</span>);</div><div class="line">t.new NonStaticMemberClass().setExternalClassValue(<span class="number">4</span>); <span class="comment">// (3) 직접 연결도 가능</span></div><div class="line">t.print();</div></pre></td></tr></table></figure>
  <figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 출력결과</span></div><div class="line">4</div><div class="line">3</div></pre></td></tr></table></figure>
<ul>
<li>NonStatic Member Class 안에서 External Class의 메서드 호출 가능 (1)</li>
<li>qualified this로 External Class 객체에 대한 참조 획득 가능 (2)</li>
<li>NonStatic Member Class와 External Class의 연결은 NonStatic Member Class의 객체가 생성될때 확립 (3)</li>
</ul>
</li>
<li><p>Adapter를 정의할 때 많이 사용(External Class를 다른 클래스 객체인 것처럼 보이게하는 용도)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIterator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="anonymous-class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h4><ul>
<li>함수 객체를 정의할 때 널리 쓰인다</li>
<li>표현식 중간에 등장하므로, 10줄 이하로 짧게 작성되어야 한다. 아니면 코드 가독성이 떨어진다</li>
<li><p>nonstatic context 안에서 사용될 때만 External 객체를 갖는다</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> externalClassValue = <span class="number">2</span>;</div><div class="line">    <span class="keyword">private</span> AnonymousClass ac;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAnonymousClassTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        ac = <span class="keyword">new</span> AnonymousClass() &#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">                <span class="keyword">this</span>.value = value;</div><div class="line">                System.out.printf(<span class="string">"Anonymous Class Test %d %d"</span>,</div><div class="line">                ExternalClass.<span class="keyword">this</span>.externalClassValue, <span class="keyword">this</span>.value);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        ac.print(<span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExternalClass t = <span class="keyword">new</span> ExternalClass();</div><div class="line">        t.printAnonymousClassTest();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="local-class"><a href="#Local-Class" class="headerlink" title="Local Class"></a>Local Class</h4><ul>
<li>지역 변수 선언되는 곳에 선언된 클래스</li>
<li><p>static 맴버 불가능, nonstatic context에서만 External Class의 맴버 접근 가능</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> externalClassValue = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLocalClassTest</span><span class="params">()</span> </span>&#123; <span class="comment">// non static context</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalClass</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">      <span class="comment">// private static value; 불가능</span></div><div class="line"></div><div class="line">      LocalClass(<span class="keyword">int</span> value) &#123; <span class="keyword">this</span>.value = value; &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; System.out.println(externalClassValue); &#125; <span class="comment">// External 객체 접근 가능</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LocalClass lc = <span class="keyword">new</span> LocalClass(<span class="number">1</span>);</div><div class="line">    lc.print();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="요약-알아둘-것"><a href="#요약-알아둘-것" class="headerlink" title="요약, 알아둘 것"></a>요약, 알아둘 것</h4><ul>
<li>중첩 클래스를 메서드 밖에서 사용할 수 있어야 하거나, 메서드 안에 놓기에 너무 길 경우 맴버 클래스로 정의</li>
<li>맴버 클래스의 객체들이 External Class의 객체들에 대한 참조를 가져야 하는 경우에서만 NonStatic Member Class로 정의</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/05/15/classes-and-interfaces-3/#19-인터페이스는-자료형을-정의할-때만-사용하라&quot;&gt;규칙 19&lt;/a&gt; - 인터페이스는 자료형을 정의할 때만 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/15/classes-and-interfaces-3/#20-태그-달린-클래스-대신-클래스-계층을-활용하라&quot;&gt;규칙 20&lt;/a&gt; - 태그 달린 클래스 대신 클래스 계층을 활용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/15/classes-and-interfaces-3/#21-전략을-표현하고-싶을-때는-함수-객체를-사용하라&quot;&gt;규칙 21&lt;/a&gt; - 전략을 표현하고 싶을 때는 함수 객체를 사용하라&lt;br&gt;&lt;a href=&quot;../../../../2017/05/15/classes-and-interfaces-3/#22-멤버-클래스는-가능하면-static으로-선언하라&quot;&gt;규칙 22&lt;/a&gt; - 멤버 클래스는 가능하면 static으로 선언하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
  <entry>
    <title>Template Method Pattern</title>
    <link href="https://wickso.me/2017/05/02/template-method-pattern/"/>
    <id>https://wickso.me/2017/05/02/template-method-pattern/</id>
    <published>2017-05-02T03:57:22.000Z</published>
    <updated>2017-05-21T11:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="의도"><a href="#의도" class="headerlink" title="의도"></a>의도</h2><p>연산<sub>operation</sub>에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다.</p>
<h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p><img src="http://www.cs.unc.edu/~stotts/GOF/hires/Pictures/tmethod.gif" alt="Template Method Pattern"></p>
<h2 id="활용성"><a href="#활용성" class="headerlink" title="활용성"></a>활용성</h2><ul>
<li>어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때</li>
<li>서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93]<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC '93), pages 66–73, Indianapolis, IN, February 1993.
">[1]</span></a></sup> “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다.</li>
<li>서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.</li>
</ul>
<a id="more"></a>
<h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><ul>
<li>템플릿 메서드는 코드 재사용을 위한 기본 기술이다(특히 클라스 라이브러리 구현 시 중요).</li>
<li>템플릿 메서드는 IoC(Inversion of Control, 제어 역전) 구조를 이끌어 낸다. 즉, 부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만 반대 방향의 호출은 안 된다.<blockquote><p>Don’t call us, we’ll call you.</p>
<footer><strong>할리우드 원칙(Hollywood principle)</strong></footer></blockquote></li>
<li>템플릿 메서드는 여러 종류의 연산 중 하나를 호출한다.<ul>
<li>구체 연산</li>
<li>AbstractClass 구체 연산</li>
<li>기본 연산</li>
<li>factory method</li>
<li>hook operation: 필요하다면 서브클래스에서 활장할 수 있는 기본 행동을 제공하는 연산. 기본적으로 아무 내용도 정의하지 않는다.</li>
</ul>
</li>
</ul>
<h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><ul>
<li><strong>접근제어자를 이용한다.</strong> - 템플릿 메서드에서 호출하는 기본 연산들을 protected로 구현한다. 이렇게 하면 이 연산들은 템플릿 메서드만 호출할 수 있게 된다. 템플릿 메서드는 재정의하면 안되므로 맴버 함수로 만든다(final로 정의하면 재정의 불가능).</li>
<li><strong>기본 연산의 수를 최소화한다.</strong> - 템플릿 메서드를 설계할 때 중요한 목표 중 하나는 서브클래스가 오버라이드해야 하는 연산의 수를 최소화하는 것이다. 재정의해야 하는 메서드가 많아질수록 사용자는 불편해진다.</li>
<li><strong>네이밍 규칙을 만든다.</strong> - 재정의 연산에 접두어를 추가하여 식별이 잘되도록 할 수 있다. 예를 들어, 매킨토시 응용프로그램의 MapAPP프레임워크[App89]<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994.
">[2]</span></a></sup>의 모든 템플릿 메서드는 <code>Do-</code>로 시작한다. <code>DoCreateDocument</code>, <code>DoRead</code></li>
</ul>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>문서 관리 응용프로그램이 새 문서를 만드는 경우로 예를 들어 보자. 모든 응용프로그램은 파일을 생성하기 전에 파일 존재 확인과 권한 확인을 하며, 특정 응용프로그램은 파일을 열기전에 로그를 출력해야 한다.</p>
<p>이런 경우에 <code>openNewDocument()</code> 템플릿 메서드를 사용할 수 있다. <code>Application.java</code>는 항상 확인해야할 연산(파일 존재 확인, 권한 확인)을 추상 메서드로 정의하고 템플릿 메서드에서 수행한다. Application에서 <code>beforeCreateDocument()</code>는 hook 연산으로 필요에따라 확장해서 사용 가능하다. 이렇게 함으로</p>
<p>추상 연산을 통해 알고리즘의 일부를 정의함으로써, 템플릿 메서드는 각 단계의 순서는 고정하되 각각의 서브클래스는 필요에 따라 이들 단계의 처리를 다양화시킬 수 있다.</p>
<p><em>Application.java(AbstractClass)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">newDcument</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> createDocument(); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Document <span class="title">createDocument</span><span class="params">()</span></span>; <span class="comment">// factory method</span></div><div class="line"></div><div class="line">  <span class="comment">// template method</span></div><div class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> Document <span class="title">openNewDocument</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!existDocument(fileName)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The file doesn't exist: "</span> + fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!canOpenDocument(fileName)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"can't open the document: "</span> + fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    beforeCreateDocument(); <span class="comment">// hook 연산</span></div><div class="line">    Document document = createDocument(); <span class="comment">// template method에서 factory method가 호출된다.</span></div><div class="line">    document.setFileName(fileName);</div><div class="line">    <span class="keyword">return</span> document;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String fileName)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">canOpenDocument</span><span class="params">(String fileName)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeCreateDocument</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// hook: 기본적으로 아무 내용도 정의하지 않는다.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>MyApplication.java(ConcreteClass)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PATH = <span class="string">"/local/path/base"</span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCreateDocument</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"create document"</span>); &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">createDocument</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> WordDocument(); &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> File(BASE_PATH + fileName)).exists();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>[<a href="http://wiki.c2.com/?GangOfFour" rel="external nofollow noopener noreferrer" target="_blank">GOF</a>{kr}:419] - 템플릿 메서드</li><br>        <li>GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.</li><br>    </ul><br></div>

<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC ‘93), pages 66–73, Indianapolis, IN, February 1993.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994.<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;의도&quot;&gt;&lt;a href=&quot;#의도&quot; class=&quot;headerlink&quot; title=&quot;의도&quot;&gt;&lt;/a&gt;의도&lt;/h2&gt;&lt;p&gt;연산&lt;sub&gt;operation&lt;/sub&gt;에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다.&lt;/p&gt;
&lt;h2 id=&quot;구조&quot;&gt;&lt;a href=&quot;#구조&quot; class=&quot;headerlink&quot; title=&quot;구조&quot;&gt;&lt;/a&gt;구조&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.cs.unc.edu/~stotts/GOF/hires/Pictures/tmethod.gif&quot; alt=&quot;Template Method Pattern&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;활용성&quot;&gt;&lt;a href=&quot;#활용성&quot; class=&quot;headerlink&quot; title=&quot;활용성&quot;&gt;&lt;/a&gt;활용성&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때&lt;/li&gt;
&lt;li&gt;서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93]&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-right hint--error hint--large&quot; aria-label=&quot;William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC &#39;93), pages 66–73, Indianapolis, IN, February 1993.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다.&lt;/li&gt;
&lt;li&gt;서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="design pattern" scheme="https://wickso.me/tags/design-pattern/"/>
    
      <category term="befavioral pattern" scheme="https://wickso.me/tags/befavioral-pattern/"/>
    
  </entry>
  
  <entry>
    <title>이펙티브자바 4장. 클래스와 인터페이스 - 2</title>
    <link href="https://wickso.me/2017/04/12/classes-and-interfaces-2/"/>
    <id>https://wickso.me/2017/04/12/classes-and-interfaces-2/</id>
    <published>2017-04-12T01:00:00.000Z</published>
    <updated>2017-04-12T01:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="../../../../2017/04/15/classes-and-interfaces-2/#16-계승하는-대신-구성하라">규칙 16</a> - 계승하는 대신 구성하라<br><a href="../../../../2017/04/15/classes-and-interfaces-2/#17-계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라">규칙 17</a> - 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라<br><a href="../../../../2017/04/15/classes-and-interfaces-2/#18-추상-클래스-대신-인터페이스를-사용하라">규칙 18</a> - 추상 클래스 대신 인터페이스를 사용하라</p>
<a id="more"></a>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>조슈아 블로크, 이병준(옮긴이), Effective Java, 2판, 인사이트, 2015.</li><br>    </ul><br></div>

<hr>
<h2 id="16-계승하는-대신-구성하라"><a href="#16-계승하는-대신-구성하라" class="headerlink" title="16. 계승하는 대신 구성하라"></a>16. 계승하는 대신 구성하라</h2><ul>
<li>즉, 클래스에 대해서 <code>extends</code> 하지 말고 <code>필드</code>로 선언하라.</li>
<li>메서드 호출과 달리, 계승은 캡슐화 원칙을 위반한다.</li>
<li><code>IS-A</code> 관계일 때 계승하고, <code>HAS-A</code> 관계는 구성하라.</li>
</ul>
<hr>
<h2 id="17-계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라"><a href="#17-계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라" class="headerlink" title="17. 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라"></a>17. 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라</h2><ul>
<li>재정의 가능 메서드를 내부적으로 어떻게 사용하는지 반드시 문서에 남겨라.<ul>
<li>관습적으로, 재정의 가능 메서드를 어떤 식으로 호출하는지는 메서드 주석문 마지막에 명시한다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="18-추상-클래스-대신-인터페이스를-사용하라"><a href="#18-추상-클래스-대신-인터페이스를-사용하라" class="headerlink" title="18. 추상 클래스 대신 인터페이스를 사용하라"></a>18. 추상 클래스 대신 인터페이스를 사용하라</h2><ul>
<li>이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다.</li>
<li><p>인터페이스는 믹스인<sub>mixin</sub>을 정의하는 데 이상적이다.</p>
<blockquote>
<p>믹스인은 클래스가 “주 자료형<sub>primary type</sub>“ 이외에 추가로 구현할 수 있는 자료형으로, 어떤 선택적 기능을 제공한다는 사실을 선언하기 위해 쓰인다. (e.g. Comparable)</p>
</blockquote>
</li>
<li><p>인터페이스는 비 계층적인(nonhierarchical) 자료형 프레임워크를 만들 수 있도록 한다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingerSongwriter</span> <span class="keyword">extends</span> <span class="title">Singer</span>, <span class="title">Songwriter</span> </span>&#123;</div><div class="line">  <span class="function">AudioClip <span class="title">strum</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">actSensitive</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>인터페이스를 쓰지 않으려면 필요한 속성 조합마다 별도의 클래스를 만들어 거대한 클래스 계층을 만들어야 한다. 필요한 속성이 n개가 있다면 지원해야 하는 조합의 가짓수는 2<sup>n</sup>개에 달한 것이다. 이런 문제는 <em>조합 폭증<sub>combinatorial explosion</sub></em>이라는 이름으로 알려져 있다.</li>
</ul>
</li>
<li>인터페이스를 사용하면 <em>포장 클래스 숙어<sub>wrapper class idiom</sub></em>를 통해(<a href="#item16">규칙 16</a>) 안전하면서도 강력한 기능 개선이 가능하다.</li>
<li><em>추상 골격 구현 클래스<sub>abstract skeletal implementation</sub></em>를 중요 인터페이스마다 두면, 인터페이스의 장점과 추상 클래스의 장점을 결합할 수 있다.<ul>
<li>인터페이스로는 자료형을 정의하고, 구현하는 일은 골격 구현 클래스에 맡기면 된다.</li>
<li>관습적으로 골격 구현 클래스의 이름은 Abstract<em>Interface</em>와 같이 정한다.<br>  (e.g. Collection Framework에는 인터페이스별로 골격 구현 클래스들이 하나씩 제공된다. <code>AbstractCollection</code>, <code>AbstractSet</code>, <code>AbstractList</code>, <code>AbstractMap</code>)</li>
<li>골격 구현 클래스를 적절히 정의하기만 하면, 프로그래머는 쉽게 인터페이스를 구현할 수 있다.</li>
</ul>
</li>
<li>추상클래스의 장점으로 인터페이스보다 추상 클래스가 발전시키기 쉽다. 하지만 java 1.8에서는 인터페이스에 default 메서드를 추가할 수 있다(하지만 인터페이스당 한 개의 default 메서드).</li>
<li>인터페이스가 공개되고 널리 구현된 다음에는, 인터페이스 수정이 거의 불가능하다. 그러므로, public 인터페이스는 극도로 주의해서 설계해야 하며 실제로 여러 구현을 만들어 보면서 광범위하게 테스트해야 한다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../../../../2017/04/15/classes-and-interfaces-2/#16-계승하는-대신-구성하라&quot;&gt;규칙 16&lt;/a&gt; - 계승하는 대신 구성하라&lt;br&gt;&lt;a href=&quot;../../../../2017/04/15/classes-and-interfaces-2/#17-계승을-위한-설계와-문서를-갖추거나-그럴-수-없다면-계승을-금지하라&quot;&gt;규칙 17&lt;/a&gt; - 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라&lt;br&gt;&lt;a href=&quot;../../../../2017/04/15/classes-and-interfaces-2/#18-추상-클래스-대신-인터페이스를-사용하라&quot;&gt;규칙 18&lt;/a&gt; - 추상 클래스 대신 인터페이스를 사용하라&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="effective java" scheme="https://wickso.me/tags/effective-java/"/>
    
  </entry>
  
</feed>
