<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wicksome Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wickso.me/"/>
  <updated>2017-05-02T13:11:13.000Z</updated>
  <id>https://wickso.me/</id>
  
  <author>
    <name>Yeongjun Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Template Method Pattern</title>
    <link href="https://wickso.me/2017/05/02/template-method-pattern/"/>
    <id>https://wickso.me/2017/05/02/template-method-pattern/</id>
    <published>2017-05-02T03:57:22.000Z</published>
    <updated>2017-05-02T13:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="의도"><a href="#의도" class="headerlink" title="의도"></a>의도</h2><p>연산<sub>operation</sub>에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다.</p>
<h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p><img src="http://www.cs.unc.edu/~stotts/GOF/hires/Pictures/tmethod.gif" alt="Template Method Pattern"></p>
<h2 id="활용성"><a href="#활용성" class="headerlink" title="활용성"></a>활용성</h2><ul>
<li>어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때</li>
<li>서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93]<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC '93), pages 66–73, Indianapolis, IN, February 1993.
">[1]</span></a></sup> “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다.</li>
<li>서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.</li>
</ul>
<a id="more"></a>
<h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><ul>
<li>템플릿 메서드는 코드 재사용을 위한 기본 기술이다(특히 클라스 라이브러리 구현 시 중요).</li>
<li>템플릿 메서드는 IoC(Inversion of Control, 제어 역전) 구조를 이끌어 낸다. 즉, 부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만 반대 방향의 호출은 안 된다.<blockquote><p>Don’t call us, we’ll call you.</p>
<footer><strong>할리우드 원칙(Hollywood principle)</strong></footer></blockquote></li>
<li>템플릿 메서드는 여러 종류의 연산 중 하나를 호출한다.<ul>
<li>구체 연산</li>
<li>AbstractClass 구체 연산</li>
<li>기본 연산</li>
<li>factory method</li>
<li>hook operation: 필요하다면 서브클래스에서 활장할 수 있는 기본 행동을 제공하는 연산. 기본적으로 아무 내용도 정의하지 않는다.</li>
</ul>
</li>
</ul>
<h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><ul>
<li><strong>접근제어자를 이용한다.</strong> - 템플릿 메서드에서 호출하는 기본 연산들을 protected로 구현한다. 이렇게 하면 이 연산들은 템플릿 메서드만 호출할 수 있게 된다. 템플릿 메서드는 재정의하면 안되므로 맴버 함수로 만든다(final로 정의하면 재정의 불가능).</li>
<li><strong>기본 연산의 수를 최소화한다.</strong> - 템플릿 메서드를 설계할 때 중요한 목표 중 하나는 서브클래스가 오버라이드해야 하는 연산의 수를 최소화하는 것이다. 재정의해야 하는 메서드가 많아질수록 사용자는 불편해진다.</li>
<li><strong>네이밍 규칙을 만든다.</strong> - 재정의 연산에 접두어를 추가하여 식별이 잘되도록 할 수 있다. 예를 들어, 매킨토시 응용프로그램의 MapAPP프레임워크[App89]<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994.
">[2]</span></a></sup>의 모든 템플릿 메서드는 <code>Do-</code>로 시작한다. <code>DoCreateDocument</code>, <code>DoRead</code></li>
</ul>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>문서 관리 응용프로그램이 새 문서를 만드는 경우로 예를 들어 보자. 모든 응용프로그램은 파일을 생성하기 전에 파일 존재 확인과 권한 확인을 하며, 특정 응용프로그램은 파일을 열기전에 로그를 출력해야 한다.</p>
<p>이런 경우에 <code>openNewDocument()</code> 템플릿 메서드를 사용할 수 있다. <code>Application.java</code>는 항상 확인해야할 연산(파일 존재 확인, 권한 확인)을 추상 메서드로 정의하고 템플릿 메서드에서 수행한다. Application에서 <code>beforeCreateDocument()</code>는 hook 연산으로 필요에따라 확장해서 사용 가능하다. 이렇게 함으로</p>
<p>추상 연산을 통해 알고리즘의 일부를 정의함으로써, 템플릿 메서드는 각 단계의 순서는 고정하되 각각의 서브클래스는 필요에 따라 이들 단계의 처리를 다양화시킬 수 있다.</p>
<p><em>Application.java(AbstractClass)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">newDcument</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> createDocument(); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Document <span class="title">createDocument</span><span class="params">()</span></span>; <span class="comment">// factory method</span></div><div class="line"></div><div class="line">  <span class="comment">// template method</span></div><div class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> Document <span class="title">openNewDocument</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!existDocument(fileName)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The file doesn't exist: "</span> + fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!canOpenDocument(fileName)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"can't open the document: "</span> + fileName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    beforeCreateDocument(); <span class="comment">// hook 연산</span></div><div class="line">    Document document = createDocument(); <span class="comment">// template method에서 factory method가 호출된다.</span></div><div class="line">    document.setFileName(fileName);</div><div class="line">    <span class="keyword">return</span> document;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String fileName)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">canOpenDocument</span><span class="params">(String fileName)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeCreateDocument</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// hook: 기본적으로 아무 내용도 정의하지 않는다.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>MyApplication.java(ConcreteClass)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PATH = <span class="string">"/local/path/base"</span>;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCreateDocument</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"create document"</span>); &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">createDocument</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> WordDocument(); &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">existDocument</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> File(BASE_PATH + fileName)).exists();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>[<a href="http://wiki.c2.com/?GangOfFour" rel="external nofollow noopener noreferrer" target="_blank">GOF</a>{kr}:419] - 템플릿 메서드</li><br>        <li>GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.</li><br>    </ul><br></div>

<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC ‘93), pages 66–73, Indianapolis, IN, February 1993.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2, 1994.<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;의도&quot;&gt;&lt;a href=&quot;#의도&quot; class=&quot;headerlink&quot; title=&quot;의도&quot;&gt;&lt;/a&gt;의도&lt;/h2&gt;&lt;p&gt;연산&lt;sub&gt;operation&lt;/sub&gt;에 알고리즘의 뼈대만 정의하고, 구체적 처리는 서브클래스로 미룬다. 알고리즘 구조는 변경하지 않고 단계처리만 서브클래스는에서 재정의할 수 있도록 한다.&lt;/p&gt;
&lt;h2 id=&quot;구조&quot;&gt;&lt;a href=&quot;#구조&quot; class=&quot;headerlink&quot; title=&quot;구조&quot;&gt;&lt;/a&gt;구조&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.cs.unc.edu/~stotts/GOF/hires/Pictures/tmethod.gif&quot; alt=&quot;Template Method Pattern&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;활용성&quot;&gt;&lt;a href=&quot;#활용성&quot; class=&quot;headerlink&quot; title=&quot;활용성&quot;&gt;&lt;/a&gt;활용성&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때&lt;/li&gt;
&lt;li&gt;서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 이것은 Opdyke와 Johnson이 설명한[OJ93]&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-right hint--error hint--large&quot; aria-label=&quot;William F. Opdyke and Ralph E. Johnson. Creating abstract superclasses by refactoring. In Proceedings of the 21st Annual Computer Science Conference (ACM CSC &#39;93), pages 66–73, Indianapolis, IN, February 1993.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; “refactoring to generalize”의 좋은 예이다. 먼저 기존코드에서 차이점을 찾고 이를 새로운 연산으로 분리한다. 그 다음 달라진 코드 부분을 새로운 연산을 호출하는 템플릿 메서드로 대체한다.&lt;/li&gt;
&lt;li&gt;서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 “hook” 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="design pattern" scheme="https://wickso.me/tags/design-pattern/"/>
    
      <category term="befavioral pattern" scheme="https://wickso.me/tags/befavioral-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Factory Method Pattern</title>
    <link href="https://wickso.me/2017/04/26/factory-method-pattern/"/>
    <id>https://wickso.me/2017/04/26/factory-method-pattern/</id>
    <published>2017-04-26T04:32:16.000Z</published>
    <updated>2017-05-02T05:23:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="의도"><a href="#의도" class="headerlink" title="의도"></a>의도</h2><p>객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.</p>
<blockquote><p>Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다.</p>
<footer><strong>위키백과</strong><cite><a href="https://ko.wikipedia.org/wiki/%ED%8C%A9%ED%86%A0%EB%A6%AC_%EB%A9%94%EC%84%9C%EB%93%9C_%ED%8C%A8%ED%84%B4" rel="external nofollow noopener noreferrer" target="_blank">팩토리 메서드 패턴</a></cite></footer></blockquote>
<h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p><img src="https://www.codeproject.com/KB/architecture/csdespat_1/dpcs_fm.gif" alt="Factory Method Pattern"></p>
<h2 id="활용성"><a href="#활용성" class="headerlink" title="활용성"></a>활용성</h2><ul>
<li>어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때</li>
<li>생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때</li>
<li>객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때</li>
</ul>
<a id="more"></a>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>예를 들어 다양한 종류의 문서를 표현하는 응용프로그램 프레임워크가 있다. 이를 위해서는 일단 두 개의 큰 추상화가 필요하다. 하나는 <em>Creator</em>(응용프로그램) 추상 클래스이고, 다른 하나는 <em>Product</em>(문서) 추상 클래스(혹은 인터페이스)이다.<br><em>Creator</em> 클래스는 문서의 인스턴스를 ++언제++ 만들지는 알지만, ++어떤 문서++를 만들어야 하는지는 알지 못한다. <em>Product</em> 클래스가 추상 클래스이기 때문에 인스턴스를 가질 수 없기 때문이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> createProduct(); &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>; <span class="comment">// factory method</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>팩토리 메서드 패턴은 이런 문제에 대한 해법을 제시한다. <em>Document</em>의 서브클래스 중 어느 것을 생성해야 하는지에 대한 정보를 캡슐화하고, 그것을 프레임워크에서 떼어낸다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><em>TextProduct</em> 클래스와 PhotoProduct 클래스를 팩토리 메서드 패턴을 활용하여 생성한다면 아래와 같은 방법이 있다.</p>
<h4 id="방법-1-추상-클래스"><a href="#방법-1-추상-클래스" class="headerlink" title="방법 1) 추상 클래스"></a>방법 1) 추상 클래스</h4><p>사용자는 특정 응용프로그램에 종속적인 구현을 위해서 두 클래스의 서브 클래스를 정의할 수 있다. <em>Creator</em> 클래스는 <em>Product</em> 객체를 관리하는 책임을 맡고 있으며, 필요에 따라 문서를 생성할 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern example with abstract class</span></div><div class="line">Creator textCreator = <span class="keyword">new</span> TextCreator();</div><div class="line">Product p1 = textCreator.newProduct();</div><div class="line"></div><div class="line">Creator photoCreator = <span class="keyword">new</span> PhotoCreator();</div><div class="line">Product p2 = photoCreator.newProduct();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WordProduct();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PhotoProduct();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-2-팩토리-메서드-매개변수화-abstract-factory-pattern"><a href="#방법-2-팩토리-메서드-매개변수화-abstract-factory-pattern" class="headerlink" title="방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern"></a>방법 2) 팩토리 메서드 매개변수화 - abstract factory pattern</h4><p>팩토리 메서드가 매개변수를 받아서 어떤 종류의 제품을 생성할지 만드는 방법도 있다. (추상 팩토리 패턴은 팩토리 메서드를 이용해서 구현할 때가 많다)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Factory pattern example using argument</span></div><div class="line">Product p1 = Creator1.create(ProductType.TEXT);</div><div class="line">Product p2 = Creator1.create(ProductType.PHOTO);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ProductType &#123;</div><div class="line">  TEXT, PHOTO</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Product <span class="title">create</span><span class="params">(ProductType type)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">      <span class="keyword">case</span> TEXT:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExcelProduct();</div><div class="line">      <span class="keyword">case</span> PHOTO:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImageProduct();</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-3-lazy-initialization-기법"><a href="#방법-3-Lazy-Initialization-기법" class="headerlink" title="방법 3) Lazy Initialization 기법"></a>방법 3) Lazy Initialization 기법</h4><p>인스턴스화하는 접근자 메서드를 통해서만 인스턴스에 접근하는 방법으로, 생성자에서 아무 의미 없는 값으로 인스턴스에 대한 매개변수를 초기화하고, 접근자 메서드가 인스턴스를 반환하도록 할 수 있다. 생성자가 초기화 시키는 것이 아니라 필요한 시점에서 초기화를 수행하기 때문에 이런 기법을 Lazy Initialization이라고 한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern with lazy initialization</span></div><div class="line">TextCreator textCreator = <span class="keyword">new</span> TextCreator();</div><div class="line">List collection = textCreator.newCollection();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> List <span class="title">createCollection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TextProduct&gt;();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> List&lt;Product&gt; collection = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> List <span class="title">newCollection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// lazy initialization</span></div><div class="line">    <span class="keyword">if</span> (collection == <span class="keyword">null</span>) &#123;</div><div class="line">      collection = createCollection();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> collection;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// factory method</span></div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> List <span class="title">createCollection</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="방법-4-템플릿-활용"><a href="#방법-4-템플릿-활용" class="headerlink" title="방법 4) 템플릿 활용"></a>방법 4) 템플릿 활용</h4><p>팩토리 메서드를 사용하면 생길 수 있는 문제점 중 하나는 <em>Product</em> 클래스 하나를 추가하려 할 때마다 <em>Creator</em> 클래스를 서브클래싱해야 한다는 점이다(<a href="#방법-1-추상-클래스">방법 1</a>). 이로써 클래스 계통의 부피가 확장되는 문제가 생길 수 있다. 이런 문제를 해결할 수 있는 방법 중 하나는 <em>Creator</em> 클래스를 상속받는 제네릭 클래스를 정의하고 Product 클래스로 매개변수화되도록 만드는 것이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// factory pattern example whti template</span></div><div class="line">StandardCreator&lt;WordProduct&gt; wordProductCreator = <span class="keyword">new</span> StandardCreator&lt;&gt;(WordProduct.class);</div><div class="line">Product p1 = wordProductCreator.newProduct();</div><div class="line"></div><div class="line">StandardCreator&lt;ImageProduct&gt; imageProductCreator = <span class="keyword">new</span> StandardCreator&lt;&gt;(ImageProduct.class);</div><div class="line">Product p2 = imageProductCreator.newProduct();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creator Template</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; product type</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardCreator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Product</span>&gt; <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Class&lt;T&gt; cls;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StandardCreator</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.cls = cls;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">    T product = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      product = cls.newInstance();</div><div class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> product;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div class="tip"><br>    <div>아래 책를 참고하여 학습한 내용을 정리/기록한 포스트입니다. 자세한 내용은 책을 참고하시기 바라며, 문제가 있을 경우 연락 부탁드립니다.</div><br>    <ul><br>        <li>[<a href="http://wiki.c2.com/?GangOfFour" rel="external nofollow noopener noreferrer" target="_blank">GOF</a>{kr}:419] - 템플릿 메서드</li><br>        <li>GoF, 김정아(옮긴이), Design Patterns, 개정판, 프로텍미디어, 2015.</li><br>    </ul><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;의도&quot;&gt;&lt;a href=&quot;#의도&quot; class=&quot;headerlink&quot; title=&quot;의도&quot;&gt;&lt;/a&gt;의도&lt;/h2&gt;&lt;p&gt;객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Factory Method라는 패턴 이름이 적절하지 못한데, 이름으로 인해 객체를 생성하는 메소드를 Factory method라 오해하는 개발자가 많이 있다(Allen Holub의 말을 인용.) 이런 생성 메소드가 모두 Factory method 패턴을 사용하는 것은 아니다. Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;위키백과&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8C%A9%ED%86%A0%EB%A6%AC_%EB%A9%94%EC%84%9C%EB%93%9C_%ED%8C%A8%ED%84%B4&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;팩토리 메서드 패턴&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;구조&quot;&gt;&lt;a href=&quot;#구조&quot; class=&quot;headerlink&quot; title=&quot;구조&quot;&gt;&lt;/a&gt;구조&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www.codeproject.com/KB/architecture/csdespat_1/dpcs_fm.gif&quot; alt=&quot;Factory Method Pattern&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;활용성&quot;&gt;&lt;a href=&quot;#활용성&quot; class=&quot;headerlink&quot; title=&quot;활용성&quot;&gt;&lt;/a&gt;활용성&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때&lt;/li&gt;
&lt;li&gt;생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때&lt;/li&gt;
&lt;li&gt;객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
      <category term="design pattern" scheme="https://wickso.me/tags/design-pattern/"/>
    
      <category term="creational pattern" scheme="https://wickso.me/tags/creational-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Java Generic</title>
    <link href="https://wickso.me/2016/04/12/generic/"/>
    <id>https://wickso.me/2016/04/12/generic/</id>
    <published>2016-04-12T07:40:01.000Z</published>
    <updated>2017-05-03T07:45:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="제네릭-프로그래밍"><a href="#제네릭-프로그래밍" class="headerlink" title="제네릭 프로그래밍"></a>제네릭 프로그래밍</h2><hr>
<h2 id="generic-class-method"><a href="#generic-class-method" class="headerlink" title="generic class, method"></a>generic class, method</h2><pre><code>// class
public class Entry&lt;K, V&gt; {
    private K key;
    private V value;
    ...
}

Entry&lt;String, Integer&gt; entry = new Entry&lt;&gt;(...);

// method
public class Arrays {
    public &lt;T&gt; void swap(T[] array, int i, int j) {
        T tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
</code></pre><p>–</p>
<h3 id="generic-method"><a href="#generic-method" class="headerlink" title="generic method"></a>generic method</h3><pre><code>public static &lt;T&gt; void swap(T[] array, int i, int j)
</code></pre><ul>
<li>타입 파라미터를 제어자와 반환타입 사이에 둔다</li>
<li><p>호출할 때는 명시하지 않아도 가능</p>
<ul>
<li><p>컴파일러가 타입파라미터 추론</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Arrays.&lt;String&gt;swap(friends, 0, 1);</div></pre></td></tr></table></figure>
</li>
<li><p>원한다면 명시적으로 가능</p>
</li>
<li>문제 발생시 더 자세한 오류 메시지</li>
</ul>
</li>
</ul>
<p>–</p>
<h3 id="e-t"><a href="#E-T" class="headerlink" title="E? T? ??"></a>E? T? <code>?</code>?</h3><ul>
<li>E : Element</li>
<li>T : Type</li>
<li>V : Value</li>
<li>K : Key</li>
<li>? : 와일드 카드</li>
<li>…</li>
</ul>
<p>–</p>
<h3 id="기본-타입은-불가능"><a href="#기본-타입은-불가능" class="headerlink" title="기본 타입은 불가능"></a>기본 타입은 불가능</h3><pre><code>Entry&lt;String, int&gt; // 불가능
</code></pre><hr>
<h2 id="타입-경계"><a href="#타입-경계" class="headerlink" title="타입 경계"></a>타입 경계</h2><p>제네릭 클래스/메서드가 받는 타입 파라미터의 타입을 제한할 때</p>
<pre><code>public status &lt;T extends AutoCloseable&gt; void closeAll(ArrayList&lt;T&gt; elems) {
    for (T elem : elems) {
        elem.close();
    }
}
</code></pre><ul>
<li>다중 경계 지정</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">T extends Runable &amp; AutoCloseable</div></pre></td></tr></table></figure>
<p>–</p>
<h3 id="ltt-extends-autocloseablegt"><a href="#lt-T-extends-AutoCloseable-gt" class="headerlink" title="&lt;T extends AutoCloseable&gt;"></a>&lt;T extends AutoCloseable&gt;</h3><ul>
<li>요소타입이 AutoCloseable의 서브타입임을 보장한다.</li>
<li>extends == 서브타입, 상속 X<ul>
<li>기존에 사용하던 extends 키워드를 사용함</li>
</ul>
</li>
</ul>
<hr>
<h2 id="타입-가변성과-와일드카드"><a href="#타입-가변성과-와일드카드" class="headerlink" title="타입 가변성과 와일드카드"></a>타입 가변성과 와일드카드</h2><ul>
<li><p>Employee의 서브클래스 객체로 구성된 배열을 사용하고자 할 때,</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void process(Employee[] staff) &#123;...&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>이때, Manager[]이 Employee[]의 서브타입이라면 process()에 전달할 수 있다.</p>
<ul>
<li>이러한 동작을 공변성(covariance)라고 한다.</li>
<li>즉, 배열은 요소 타입과 같은 방식으로 변한다.</li>
</ul>
</li>
<li>자바에서는 와일드카드로 메서드의 파라미터와 반환 타입이 변하는 방식을 지정.<ul>
<li>이 메커니즘을 use-site variance(사용처 공변성)이라고 한다.</li>
</ul>
</li>
</ul>
<p>–</p>
<h3 id="covariance"><a href="#covariance" class="headerlink" title="covariance"></a>covariance</h3><pre><code>Manager[] bosses1 = new Manager[10];
Employee[] empls1 = bosses1; // 공변성
empls1[0] = new Manager(); // p.169
// 런타임에서 ArrayStoreException을 던질 때 잡을 수 파악
</code></pre><ul>
<li>자바의 모든 제네릭 타입은 불변(invariant)</li>
</ul>
<p>–</p>
<h3 id="but"><a href="#But" class="headerlink" title="But!"></a>But!</h3><pre><code>ArrayList&lt;Manager&gt; bosses2 = new ArrayList&lt;&gt;();
ArrayList&lt;Employee&gt; empls2 = bosses2; // error
</code></pre><ul>
<li>자바의 모든 제네릭 타입은 불변(invariant)</li>
<li>ArrayList<manager>은 ArrayList<employee>의 서브타입이 아니다.</employee></manager></li>
</ul>
<p>–</p>
<h3 id="서브타입-와일드카드"><a href="#서브타입-와일드카드" class="headerlink" title="서브타입 와일드카드"></a>서브타입 와일드카드</h3><ul>
<li><p>&lt;? extends Employee&gt;</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public statis void pringNames(ArrayList&lt;? extends Employee&gt; staff) &#123;</div><div class="line">  for(Employee e : staff) &#123;</div><div class="line">    System.out.println(e.getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>?는 Employee의 서브타입</p>
</li>
</ul>
<p>–</p>
<h4 id="but"><a href="#But-1" class="headerlink" title="But!!"></a>But!!</h4><pre><code>Employee e = staff.get(0); // 가능
staff.add(new Manager(&quot;yj&quot;)); // 불가능, 컴파일 에러
</code></pre><ul>
<li>?는 어떤 서브클래스든 가르킬 수 있으므로 컴파일 오류</li>
<li><p>즉, ? extends Employee는</p>
<ul>
<li>Employee로 변환할 수 있지만</li>
<li><p>어떤 것도 절대 ? extends Employee로 변환할 수 없다.</p>
<p><img src="doc/images/java-generic-01.png"></p>
</li>
</ul>
</li>
<li><p>ArrayList&lt;? extends Employee&gt;에서 읽을 수는 있지만 쓸 수는 없다.</p>
</li>
</ul>
<p>–</p>
<h3 id="슈퍼타입-와일드카드"><a href="#슈퍼타입-와일드카드" class="headerlink" title="슈퍼타입 와일드카드"></a>슈퍼타입 와일드카드</h3><ul>
<li><p>? super Employee</p>
<ul>
<li><p>함수형 객체의 파라미터로 유용</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface Pridicate&lt;T&gt; &#123;</div><div class="line">  boolean test(T arg);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>p.247 다시 볼것</p>
</li>
<li><a href="http://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java" rel="external nofollow noopener noreferrer" target="_blank">super vs extends</a></li>
</ul>
</li>
</ul>
<p>–</p>
<h3 id="슈퍼타입-와일드카드-2"><a href="#슈퍼타입-와일드카드-2" class="headerlink" title="슈퍼타입 와일드카드 2"></a>슈퍼타입 와일드카드 2</h3><p>PECS(Producer Extends Consumer Super)<br>와일드카드와 관련해 PECS라는 약칭을 사용하기도 한다. 생산자에는 extends, 소비자에는 super를 사용한다는 의미이다.</p>
<pre><code>public void pushAll(Iterable&lt;? extends E&gt; src) {
    for (E e : src) {
        push(e);
    }
}

public void popAll(Collection&lt;? super E&gt; dst) {
    while(!isEmpty()) {
        dst.add(pop());
    }
}
</code></pre><p>예를 들어, Stack의 경우에 pushAll()의 src는 Stack에서 사용될 E 인스턴스를 생산하므로 extends, popAll()의 dst는 Stack으로부터 E 인스턴스를 소비하므로 super가 적합하다. <small>(이펙티브자바 항목 28)</small></p>
<p>–</p>
<h3 id="타입-변수와-함께-사용하는-와일드카드"><a href="#타입-변수와-함께-사용하는-와일드카드" class="headerlink" title="타입 변수와 함께 사용하는 와일드카드"></a>타입 변수와 함께 사용하는 와일드카드</h3><ul>
<li>p.249 공부할 곳</li>
</ul>
<p>–</p>
<h3 id="경계-없는-와일드카드"><a href="#경계-없는-와일드카드" class="headerlink" title="경계 없는 와일드카드"></a>경계 없는 와일드카드</h3><pre><code>public static boolean hasNulls(ArrayList&lt;?&gt; elems) {
    for(Object e : elems) {
        if (e == null) return true;
    }
    return false;
}
</code></pre><ul>
<li>파라미터(ArrayList)의 타입 파라미터(?)가 중요하지 않을 때 제네릭 메서드보다 ArrayList&lt;?&gt;를 사용하는 것이 타당</li>
</ul>
<p>–</p>
<h3 id="와일드카드-캡처"><a href="#와일드카드-캡처" class="headerlink" title="와일드카드 캡처"></a>와일드카드 캡처</h3><pre><code>public static void swap(ArrayList&lt;?&gt; elems, int i, int j) {
    ? temp = elems.get(i);
    elems.set(i, elems.get(j));
    elems.set(j, temp);
}
</code></pre><ul>
<li>?을 타입으로 사용할 수 없다.</li>
</ul>
<p>–</p>
<h4 id="정상적인-코드"><a href="#정상적인-코드" class="headerlink" title="정상적인 코드"></a>정상적인 코드</h4><pre><code>public static void swap(ArrayList&lt;?&gt; elems, int i, int j) {
    swapHelper(elems, i, j);
}

private static &lt;T&gt; void swapHelper(ArrayList&lt;T&gt; elems, int i, int j) {
    T temp = elems.get(i);
    elems.set(i, elems.get(j));
    elems.set(j, temp);
}
</code></pre><p>–</p>
<h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><ul>
<li>와일드카드 캡처라는 규칙 덕분에 가능</li>
<li>컴파일러는 ?를 모르지만, ?는 어떤 타입을 나타내므로 제네릭 메서드를 호출해도 된다.</li>
<li>swapHelper 메서드의 타입파라미터 T는 와일드카드 타입을 <strong>캡처</strong>한다.</li>
<li>API 사용자가 T보다 ?를 이해하는것이 쉽다.</li>
</ul>
<hr>
<h2 id="자바-가상-머신에서의-제네릭"><a href="#자바-가상-머신에서의-제네릭" class="headerlink" title="자바 가상 머신에서의 제네릭"></a>자바 가상 머신에서의 제네릭</h2><ul>
<li>제네릭이 없던 시절에는 Object 타입으로 받았다.</li>
<li>이후 설계자들은 VM에서 타입을 지우는 구현 방식으로 기존 버전 클래스와 호환되게 했다.</li>
<li>그리고 점진적으로 제네릭으로 옮겨갔다.</li>
</ul>
<p>–</p>
<h3 id="1-타입소거"><a href="#1-타입소거" class="headerlink" title="1. 타입소거"></a>1. 타입소거</h3><p>제네릭을 정의하면 해당 타입은 raw 타입으로 컴파일된다.</p>
<pre><code>public class Entry {
    private Object key;
    private Object value;

    public Entry(Object key, Object value) {
        this.key = key;
        this.value = value;
    }
    ...
}
</code></pre><p>–</p>
<h4 id="경계가-있는-타입변수의-경우"><a href="#경계가-있는-타입변수의-경우" class="headerlink" title="경계가 있는 타입변수의 경우"></a>경계가 있는 타입변수의 경우</h4><p>첫 번째 경계로 교체된다.</p>
<pre><code>public class Entry&lt;K extends Comparable&lt;? super K&gt; &amp; Serializable,
                   V extends Serializable&gt;
</code></pre><p>다음과 같이 교체</p>
<pre><code>public class Entry{
    private Comparable key;
    private Serializable value;
    ...
</code></pre><p>–</p>
<h3 id="2-타입-변환-연산자-삽입"><a href="#2-타입-변환-연산자-삽입" class="headerlink" title="2. 타입 변환 연산자 삽입"></a>2. 타입 변환 연산자 삽입</h3><ul>
<li>Entry<string, integer="">의 객체로 생성할 경우 반드시 String, Integer가 전달되야 한다.<ul>
<li>그렇지 않으면 컴파일 X</li>
<li>즉, getKey()는 String을 반환한다는 것을 보장받는다.(컴파일이 안되므로)</li>
</ul>
</string,></li>
</ul>
<p>–</p>
<h3 id="21-타입-변환-연산자-삽입"><a href="#2-1-타입-변환-연산자-삽입" class="headerlink" title="2.1 타입 변환 연산자 삽입"></a>2.1 타입 변환 연산자 삽입</h3><ul>
<li><p>타입 연산자(T), 제네릭, raw(Object)를 사용하여 컴파일된 경우(비검사 경고옵션으로)</p>
<ul>
<li>다른 값이 들어갈 수 있다.</li>
<li><p>따라서 실행 시간에 안전성 검사를 해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Entry&lt;String, Integer&gt; entry = ...</div><div class="line">String key = entry.getKey();</div></pre></td></tr></table></figure>
</li>
<li><p>타입이 소거된 getKey()는 Object를 반환하므로 컴파일러는 다음과 같은 코드를 만들어낸다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String key = (String) entry.getKey();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>–</p>
<h3 id="3-bridge-method"><a href="#3-bridge-method" class="headerlink" title="3. bridge method"></a>3. bridge method</h3><ul>
<li>메서드 파라미터와 반환 타입을 소거할 때 때때로 컴파일러가 브릿지 메서드를 만들어내야 한다.</li>
<li>컴파일러가 raw로 만들었기 때문에 bridge method 생성</li>
</ul>
<p>–</p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><pre><code>public class WordList extends ArrayList&lt;String&gt; {
    public void add(String e) {
        return isBadWord(e) ? false : super.add(e);
    }
    ...
}
...
WordList words = ...
ArrayList&lt;String&gt; strs = words;
strs.add(&quot;JAVA&quot;);
</code></pre><ul>
<li>strs.add()에서 타입소거된 ArrayList의 add(Object)를 호출한다.</li>
<li>WordList 객체의 add를 호춣하면 동적 메서드 조회가 일어나고, ArrayList가 아닌 WordList의 add가 호출될 것을 예상할 수 있다.</li>
</ul>
<p>–</p>
<h4 id="example"><a href="#example-1" class="headerlink" title="example"></a>example</h4><ul>
<li>컴파일러는 예상대로 동작하게 하려고 WordList 안에 bridge method를 만든다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class WordList extends ArrayList&lt;String&gt; &#123;</div><div class="line">  public void add(String e) &#123;</div><div class="line">    return isBasWord(e) ? false : super.add(e);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // bridge method</div><div class="line">  public void add(Object e) &#123;</div><div class="line">    add((String) e);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>add(Object)가 호출되고 WordList의 add(String)가 호출된다.</li>
</ul>
<p>–</p>
<h4 id="bridge-method"><a href="#bridge-method" class="headerlink" title="bridge method"></a>bridge method</h4><ul>
<li>컴파일러는 동적 메서드 조회가 일어나게 하려고 브릿지 메서드를 만들어낸다.</li>
<li>자바에서는 이러한 메서드 쌍을 구현할 수 없다.(?)<ul>
<li>파라미터 타입이 다르면 오버로딩으로 가능한데 why?</li>
<li>String get(int), Object get(int)의 형태로도 bridge method 생성!</li>
</ul>
</li>
<li>가상 머신에서는 메서드를 이름, 파라미터 타입, 반환 타입으로 명시하므로 컴파일러가 이 메서드 쌍을 만들어낼 수 있다.</li>
</ul>
<p>–</p>
<h4 id="note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><ul>
<li>제네릭 외에 공변 반환 타입(covariant return type)을 구현하는데도 이용</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Employee implements Cloneable &#123;</div><div class="line">  public Employee clone() throws CloneNotSupportedException &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Employee clone()</div><div class="line">Object clone() // bridge method</div></pre></td></tr></table></figure>
<hr>
<h2 id="제네릭의-제약"><a href="#제네릭의-제약" class="headerlink" title="제네릭의 제약"></a>제네릭의 제약</h2><ul>
<li>기본 타입 인자가 없다</li>
<li>실행 시간에는 모든 타입이 raw 형태다</li>
<li>타입 변수의 인스턴스를 만들 수 없다</li>
<li>파라미터화된 타입의 배열을 생성할 수 없다</li>
<li>정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다</li>
<li>메서드가 소거 후 충동하지 않을 수도 있다</li>
<li>예외와 제네릭</li>
</ul>
<h3 id="실행-시간에는-모든-타입이-raw-형태다"><a href="#실행-시간에는-모든-타입이-raw-형태다" class="headerlink" title="실행 시간에는 모든 타입이 raw 형태다"></a>실행 시간에는 모든 타입이 raw 형태다</h3><p>VM에는 오직 raw type만 있다. 그래서 실행시간에 ArrayList가 String 객체를 담고 있는지 알아낼 수 없다.</p>
<p><img src="doc/images/java-generic-02.png"></p>
<p>이와 같은 조건은 절대로 검사할 수 없으므로 compile-time error를 일으킨다</p>
<p>–</p>
<h3 id="실행-시간에는-모든-타입이-raw-형태다"><a href="#실행-시간에는-모든-타입이-raw-형태다-1" class="headerlink" title="실행 시간에는 모든 타입이 raw 형태다"></a>실행 시간에는 모든 타입이 raw 형태다</h3><p>아래 코드는 비효율적이지만 합법적인 방법이다. obj가 ArrayList인지만 검사한다.</p>
<pre><code>Object obj = ...;
ArrayList&lt;String&gt; list = (ArrayList&lt;String&gt;) obj;
</code></pre><p>경고창을 사라지게 하려면 변수앞에 어노테이션을 붙여야 한다.</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;) ArrayList&lt;String&gt; list = (ArrayList&lt;String&gt;) obj;
</code></pre><p>–</p>
<h3 id="but"><a href="#but" class="headerlink" title="but!"></a>but!</h3><p><strong>caution</strong></p>
<p>@SuppressWarnings 어노테이션을 잘못 사용하면 heap pollution으로 이어질 수 있다. heap pollution이란 객체가 특정 제네릭 타입 인스턴스에 속해야 하지만 실제로는 다른 인스턴스에 속하는 현상을 말한다. ArrayList<string>에 ArrayList<integer>을 할당할 수 있지만, 부적합한 타입 요소를 추출하면 당연히 ClassCastException이 일어난다.</integer></string></p>
<p><img src="doc/images/java-generic-03.png"></p>
<p>–</p>
<h3 id="but"><a href="#but-1" class="headerlink" title="but!"></a>but!</h3><p><strong>tip</strong></p>
<p>힙 펄루션의 문제점은 보고된 실행 시간 오류가 문제의 원인(부적합한 요소의 삽입)과 상당히 다르다는 점이다(문제의 원인은 인스턴스에 다른 값을 넣은 것인데 ClassCate가 발생하는 점). 이런 문제를 디버그하려면 checked view를 사용해야 한다.</p>
<pre><code>List&lt;String&gt; strings =
    Collections.checkedList(new ArrayList&lt;&gt;, String.class);
</code></pre><p>이 검사 뷰는 해당 리스트에 삽입하는 동작을 모두 검사해서 부적합한 타입 객체를 추가하는 순간 예외를 던진다.</p>
<p>–</p>
<h3 id="실행-시간에는-모든-타입이-raw-형태다"><a href="#실행-시간에는-모든-타입이-raw-형태다-2" class="headerlink" title="실행 시간에는 모든 타입이 raw 형태다"></a>실행 시간에는 모든 타입이 raw 형태다</h3><p>getClass 메서드는 항상 raw 타입을 반환한다.</p>
<pre><code>ArrayList&lt;String&gt; list = ...;
list.getClass(); // ArrayList.class
ArrayList&lt;String&gt;/classl // 없는 클래스이므로 문법오류 발생
</code></pre><p>–</p>
<h3 id="타입-변수의-인스턴스를-만들-수-없다"><a href="#타입-변수의-인스턴스를-만들-수-없다" class="headerlink" title="타입 변수의 인스턴스를 만들 수 없다."></a>타입 변수의 인스턴스를 만들 수 없다.</h3><p>해결하려면 호출하는 쪽에서 배열 생성자를 메서드 참조로 제공하게 해야 한다.</p>
<pre><code>// obj가 n개 들어간 배열을 만든다고 가정할때
String[] arr = Arrays.repeat(10, &quot;hi&quot;, String[]::new);
public static &lt;T&gt; T[] repeat(int i, T obj, IntFunction&lt;T[]&gt; constr) {
    T[] result = constr.apply(n);
    for (int i=0; i &lt; n; i++) result[i] = obj;
    return result;
}

String[] arr = Arrays.repeat(10, &quot;hi&quot;, String.class); // 리플렉션
public static &lt;T&gt; T[] repeat(int n, T obj, Class&lt;T&gt; cl) {
    @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) java.lang.reflect.Array.newInstance(cl, n);
    for (int i=0; i &lt; n; i++) result[i] = obj;
    return result;
}
</code></pre><p>–</p>
<h3 id="타입-변수의-인스턴스를-만들-수-없다"><a href="#타입-변수의-인스턴스를-만들-수-없다-1" class="headerlink" title="타입 변수의 인스턴스를 만들 수 없다."></a>타입 변수의 인스턴스를 만들 수 없다.</h3><p>또 다른 방법으로 호출하는 쪽에서 배열을 할당하게 하는 방법</p>
<pre><code>String[] arr = Arrays.repeat(10, &quot;hi&quot;, new String[5]);
public static &lt;T&gt; T[] repeat(int i, T obj, T[] array) {
    T[] result;
    if(array.length &gt;= n) {
        result = array;
    } else {
        @SuppressWarnings(&quot;unchecked&quot;) T[] newArray = (T[]) java.lang.reflect.Array.newInstance(
                array.getClass().getComponenetType(), n);
        result = newArray;
    }
    for (int i=0; i &lt; n; i++) result[i] = obj;
    return result;
}
</code></pre><p>–</p>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><p>타입 변수를 이용하여 ArrayList는 생성가능하니, 마땅히 배열을 사용해야하는 이유가 없다면 ArrayList방법을 권장한다.</p>
<pre><code>public static &lt;T&gt; ArrayList&lt;T&gt; repeat(int n, T obj) {
    ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;();
    for(int i = 0; i &lt; n; i++) result.add(obj);
    return result;
}
</code></pre><p>–</p>
<h3 id="파라미터화된-타입의-배열을-생성할-수-없다"><a href="#파라미터화된-타입의-배열을-생성할-수-없다" class="headerlink" title="파라미터화된 타입의 배열을 생성할 수 없다."></a>파라미터화된 타입의 배열을 생성할 수 없다.</h3><pre><code>// 오류 - 제네릭 컴포넌트 타입으로 구성된 배열은 생성할 수 없다.
Entry&lt;String, Integer&gt;[] entries = new Entry&lt;String, Integer&gt;[100];
// 해결방안
@SuppressWarnings(&quot;unchecked&quot;) Entry&lt;String, Integer&gt;[] entries
    = (Entry&lt;String, Integer&gt;[]) new Entry&lt;?, ?&gt;[100];

// 더 나은 방안 - ArrayList 사용
ArrayList&lt;Entry&lt;String, Integer&gt;&gt; entries = new ArrayList&lt;&gt;(100);
</code></pre><p>–</p>
<h3 id="파라미터화된-타입의-배열을-생성할-수-없다"><a href="#파라미터화된-타입의-배열을-생성할-수-없다-1" class="headerlink" title="파라미터화된 타입의 배열을 생성할 수 없다."></a>파라미터화된 타입의 배열을 생성할 수 없다.</h3><pre><code>public static &lt;T&gt; ArrayList&lt;T&gt; asList(T... elements) {
    ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;();
    for(T e : elements) {
        result.add(e);
    }
    return result;
}
...
Entry&lt;String, Integer&gt; e1 = ...;
Entry&lt;String, Integer&gt; e2 = ...;
ArrayList&lt;Entry&lt;String, Integer&gt;&gt; entries = Lists.asList(e1, e2); // 컴파일러가 경고, 오류X

@SafeVarargs public static &lt;T&gt; ArrayList&lt;T&gt; asList(T... elements) {
    ...
</code></pre><p>–</p>
<h3 id="정적-컨텍스트에서는-클래스-타입-변수가-유효하지-않다"><a href="#정적-컨텍스트에서는-클래스-타입-변수가-유효하지-않다" class="headerlink" title="정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다."></a>정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다.</h3><pre><code>public class Entry&lt;K, V&gt; {
    private static V defaultValue; // 오류
    public static void setDefault(V value) { ... } // 오류
    ...
}

타입 소거는 소거된 Entry 클래스에 이런 종류의 변수나 메서드가 K와 V별로 있는 것이 아니라 오직 한 개만 있다는 것을 알 수 있다.
== 타입 소거가 되면 Entry 클래스에는 Object로 모두 바뀌어서 구분할 수 없이 Object 한 개만 있다는 것이다?
</code></pre><p>–</p>
<h3 id="메서드가-소거-후-충돌하지-않을-수도-있다"><a href="#메서드가-소거-후-충돌하지-않을-수도-있다" class="headerlink" title="메서드가 소거 후 충돌하지 않을 수도 있다."></a>메서드가 소거 후 충돌하지 않을 수도 있다.</h3><p>타입 소거 후 충돌을 일으킬 수 있는 메서드는 선언하지 않아야 한다. 다음 코드는 타입 소거후 Object의 equals과 충돌한다.</p>
<pre><code>public interface Ordered&lt;T&gt; extends Comparable&lt;T&gt; {
    public default boolean equals(T value) {
        return compareTo(value) == 0;
    }
    ...
}
</code></pre><p>–</p>
<h3 id="메서드가-소거-후-충돌하지-않을-수도-있다-2"><a href="#메서드가-소거-후-충돌하지-않을-수도-있다-2" class="headerlink" title="메서드가 소거 후 충돌하지 않을 수도 있다. 2"></a>메서드가 소거 후 충돌하지 않을 수도 있다. 2</h3><p>충돌의 원인이 미묘할 때</p>
<pre><code>public class Employee implements Comparable&lt;Employee&gt; {
    ...
    public int compareTo(Employee other) {
        return name.compareTo(other.name);
    }
}
public class Manager extends Employee implements Comparable&lt;Manager&gt; {
    // 오류 - 두 Comparable 인스턴스를 슈퍼타입으로 둘 수 없다.
    ...
    public int compareTo(Manager other) {
        return Double.compare(salary, other.salary);
    }
}
</code></pre><p>여기서는 소거가 일어나지 않는다. 두 compareTo의 브릿지 메서드가 충돌한다.<br>// ?. 제목이랑 내용이랑 무슨 말인지..?</p>
<p>–</p>
<h3 id="예외와-제네릭"><a href="#예외와-제네릭" class="headerlink" title="예외와 제네릭"></a>예외와 제네릭</h3><p>제네릭 클래스의 객체는 예외로 던지거나 잡아낼 수 없다. Throwable의 제네릭 서브클래스조차 만들 수 없다.</p>
<pre><code>public class Problem&lt;T&gt; extends Exception {
    // 제네릭 틀래스는 Throwable의 서브타입이 될 수 없다.
}
</code></pre><p>catch 절에서도 타입 변수를 사용할 수 없다.</p>
<pre><code>...
try {
    r.run();
} catch(T ex) {
    Logger.get....
}
</code></pre><p>–</p>
<h3 id="but"><a href="#but-2" class="headerlink" title="but"></a>but</h3><p>throws 선언에는 타입 변수를 사용할 수 있다.</p>
<pre><code>public static &lt;V, T extends Throwable&gt; V doWork(Callable&lt;V&gt; c, T ex) throws T {
    try {
        return c.call();
    } catch (Throwable realEx) {
        ex.initCause(realEx);
        throw ex;
    }
}
</code></pre><hr>
<h2 id="리플렉션과-제네릭"><a href="#리플렉션과-제네릭" class="headerlink" title="리플렉션과 제네릭"></a>리플렉션과 제네릭</h2><p>–</p>
<h3 id="class-클래스"><a href="#Class-클래스" class="headerlink" title="Class 클래스"></a>Class<t> 클래스</t></h3><p><strong>Class 클래스는 Class 객체가 기술하는 클래스를 타입 파라미터로 받는다.</strong></p>
<p>String.class 는 타입이 Class<string>이다. 그러므로, Class<string>의 newInstance 메서드는 String을 반환한다.<br>이 정보 덕분에 타입 변환 연산자를 사용하지 않아도된다.</string></string></p>
<p>–</p>
<h3 id="가상-머신에서-제네릭-타입-정보"><a href="#가상-머신에서-제네릭-타입-정보" class="headerlink" title="가상 머신에서 제네릭 타입 정보"></a>가상 머신에서 제네릭 타입 정보</h3><p><strong>제네릭 클래스와 제네릭 메서드의 선언부가 지워지지 않으므로 리플렉션으로 접근할 수 있다.</strong></p>
<p>–</p>
<h3 id="가상-머신에서-제네릭-타입-정보-2"><a href="#가상-머신에서-제네릭-타입-정보-2" class="headerlink" title="가상 머신에서 제네릭 타입 정보 2"></a>가상 머신에서 제네릭 타입 정보 2</h3><p>java.lang.reflect 패키지의 Type 인터페이스는 제네릭 타입 선언을 나타낸다. Type 인터페이스의 서브타입은 다음과 같다.</p>
<ol>
<li>구체적인 타입을 기술하는 Class 클래스</li>
<li>(T extends Comparable&lt;? super T&gt; 같은) 타입 변수를 나타내는 TypeVariable 인터페이스</li>
<li>(? super T 같은) 와일드카드를 나타내는 WildcardType 인터페이스</li>
<li>(Comparable&lt;? super T&gt; 같은) 제네릭 클래스나 인터페이스를 나타내는 ParameterizedType 인터페이스</li>
<li>(T[] 같은) 제네릭 배열을 나타내는 GenericArrayType 인터페이스</li>
</ol>
<p>–</p>
<h3 id="가상-머신에서-제네릭-타입-정보-3"><a href="#가상-머신에서-제네릭-타입-정보-3" class="headerlink" title="가상 머신에서 제네릭 타입 정보 3"></a>가상 머신에서 제네릭 타입 정보 3</h3><p>Class, Method, Constructor 객체가 제네릭 선언에서 나온 것인지 알아내려면 getTypeParameters 메서드를 호출한다. 반환값으로 TypeVariable 인스턴스 배열을 얻으며 각 요소는 선언부에 있는 타입 변수를 나타낸다. 길이가 0이라면 제네릭 선언이 아니다.</p>
<pre><code>Method m = Collections.class.getMethod(&quot;sort&quot;, List.class);
TypeVariable&lt;Method&gt;[] vars = m.getTypeParameters();
String name = vars[0].getName();
System.out.println(name); // &quot;T&quot;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;제네릭-프로그래밍&quot;&gt;&lt;a href=&quot;#제네릭-프로그래밍&quot; c
    
    </summary>
    
      <category term="slide" scheme="https://wickso.me/categories/slide/"/>
    
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring study 01</title>
    <link href="https://wickso.me/2016/04/07/spring-01/"/>
    <id>https://wickso.me/2016/04/07/spring-01/</id>
    <published>2016-04-06T17:32:16.000Z</published>
    <updated>2017-05-03T07:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center><br>    <h2 style="text-align: center;" id="spring-in-action">Spring in Action</h2><br>    <strong>chapter 1</strong><br><br>    스프링 속으로<br></center><br><br><br><div style="text-align: right;"><br>    <p><strong>@date</strong>    2016.04.07</p><br></div><br><br>—<br><br>## readme<br><br>Spring in Action 으로 공부하면서 어려웠던 부분, 기억해야 할 것같은 부분 위주로 정리한 ppt이다. 상단 제목의 번호는 필요할 때 책을 참고하고자 동일하게 적어두었다.<br><br>—<br><br>## 1.1 자바 개발 간소화<br><br>자바 복잡도 간소화를 지원하기 위한 주요 전략<br><br>1. POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive)인 개발<sup><em></em></sup><br>2. DI와 인터페이스 지향(interface orientation)을 통한 느슨한 결합도(loose coupling)<br>3. 애스펙트와 공통 규약을 통한 선언적(declarative) 프로그래밍<br>4. 애스팩트와 템플릿(template)을 통한 반복적인 코드 제거<br><br><small>비침투적 개발이란, 바탕이 되는 기술을 사용하는 클래스, 인터페이스, API 등을 코드에 직접 나타내지 않는 방법으로 복잡함을 분리할 수 있다.</small><br><br>–<br><br>## 1.1.2 종속객체 주입<br><br>- <strong>종속객체 주입(DI, Dependency Injection)</strong><br>- 객체는 종속객체를 생성하거나 얻지 않는다. 즉, 종속객체는 종속객체가 필요한 객체에 주입된다.<br><br>–<br><br>### 1.1.2-1<br><strong>생성자 주입(constructor injection)</strong><br><br>    public class BraveKnight implements Knight {<br>        private Quest quest;<br>        public BraveKnight(Quest quest) { // Quest 주입<br>            this.quest = quest;<br>        }<br>        public void embarkOnQuest() {<br>            quest.embark();<br>        }<br>    }<br><br>–<br><br>### 1.1.2-2<br>BraveNight 테스트<br><br>    public class BraveKnightTest {<br>        @Test<br>        public void knightShouldEmbarkOnQuest() {<br>            Quest mockQuest = mock(Quest.class); // 모의 Quest 생성<br>            BraveKnight knight = new BraveKnight(mockQuest); // 모의 Quest 주입<br>            knight.embarkOnQuest();<br>            verify(mockQuest, time(1)).embark();<br>        }<br>    }<br><br>강한 결합으로 생성자 안에서 quest를 생성할 때는 테스트가 불가능 했지만 DI를 이용하고 테스트가 가능하다. embarkOnQuest()를 호출한 후에 Mockito에게 Quest의 embark()가 정확히 한 번 호출됐는지 확인한다.<br><br>–<br><br>### 1.1.2-3<br><br>    public class SlayDragonQuest implements Quest {<br>        private PrintStream stream;<br>        public SlayDragonQuest(PrintStream stream) {<br>            this.stream = stream;<br>        }<br>        public void embark() {<br>            stream.println(“Embarking on quest to slay the dragon!”);<br>        }<br>    }<br><br>위와 같은 클래스가 있을 때, 어떻게 BraveKnight에게 SlayDragonQuest를 줄 수 있는가? 그리고 어떻게 SlayDragonQuest에게 PrintStrean을 줄 수 있는가?<br><br>–<br><br>### 1.1.2-4<br><strong>와이어링(wiring)</strong>: 애플리케이션 컴포넌트 간의 관계를 정의하는 것(xml or java를 이용한 방법)<br><br>xml<br><br>    &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>    <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd"><br>        <bean id="knight" class="com.test.knights.BraveKnight"><br>            <constructor-arg ref="quest"> <!-- 빈 주입 --><br>        </constructor-arg></bean><br><br>        <bean id="quest" class="com.test.knights.SlayDragonQuest"> <!-- SlayDragonQuest 생성 --><br>            <constructor-arg value="#{T(System).out}"><br>        </constructor-arg></bean><br>    </beans><br><br>–<br><br>### 1.1.2-5<br>java<br><br>    @Configuration<br>    public class KnightConfig {<br>        @Bean<br>        public Knight knight() {<br>            return new BraveKnight(quest());<br>        }<br><br>        @Bean<br>        public Quest quest() {<br>            return new SlayDragonQuest(System.out);<br>        }<br>    }<br><br>–<br><br>### 1.1.2-6<br><strong>실행해 보기</strong><br><br><strong>application context</strong>은 빈에 관한 정의들을 바탕으로 빈들을 엮어 준다. 스프링 애플리케이션 컨텍스트는 애플리케이션을 구성하는 객체의 생성과 와이어링을 전적으로 책임진다.<br><br>xml: ClassPathXmlApplicationContext()<br><br>java: AnnotationConfigApplicationContext()<br><br>    public static void main(String[] args) {<br>        ClassPathXmlApplicationContext context = // 스프링 컨텍스트 로드<br>            new ClassPathXmlApplicationContext(<br>                    “META-INF/spring/knights.xml”);<br>        Knight k = context.getBean(Knight.class); // 빈 얻기<br>        k.embarkOnQuest(); // 사용<br>        context.close();<br>    }<br><br>–<br><br>## 1.1.3 애스펙트 적용<br>AOP(Aspect-Oriented Programming)은 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용할 수 있는 컴포넌트에 담는다. 즉, 소프트웨어 내부의 관심사들을 서로 분리하는 기술이다. 예를 들어 로깅, 트랜잭션 관리, 보안 등의 시스템 서비스(이렇게 여러 컴포넌트에 관련되는 것을 <em>*횡단 관심사(cross-cutting concerns)</em>라고 한다. 이러한 관심사가 각각의 컴포넌트에 퍼지게 되면 다음과 같은 문제점이 있다.<br><br>1. 관심사를 구현하는 코드가 시스템 전반에 중복되어 걸쳐있어, 변경해야하는 경우 모두 변경해야 한다.<br>2. 컴포넌트의 코드가 본연의 기능과 관련 없응 코드로 지저분해진다.<br><br>–<br><br>### 1.1.3-1<br>AOP를 이용하면 응집도가 높고 본연의 관심사에 집중하는 컴포넌트를 만든다. 즉, 애스펙트는 확실히 POJO를 단순화한다.<br><center><br><img src="http://www.geekmantra.com/staticcontent/contentimages/Spring-Aspect-Oriented1.gif" alt="aspect-exam"><br></center>

<p>–</p>
<h3 id="113-2"><a href="#1-1-3-2" class="headerlink" title="1.1.3-2"></a>1.1.3-2</h3><p>ex) 기사가 원정전,후에 노래가 울려야 할 경우</p>
<pre><code>public class BraveKnight implements Knight {
    ...
    public void embarkOuest() {
        sing.beforeQuest(); // 기사가 이것까지 관리해야할까?
        quest.embark();
        sing.afterQuest();
    }
}
</code></pre><p>–</p>
<h3 id="113-3"><a href="#1-1-3-3" class="headerlink" title="1.1.3-3"></a>1.1.3-3</h3><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    ...&gt;
    &lt;bean id=&quot;sing&quot; class=&quot;com.test.Sing&quot;&gt;
        ...
    &lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;aop:aspect ref=&quot;sing&quot;&gt;
            &lt;aop:pointcut id=&quot;embark&quot;
                expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt; &lt;!-- 포인트커트 정의 --&gt;
            &lt;aop:before pointcut-ref=&quot;embark&quot;
                method=&quot;beforeQuest&quot;/&gt;
            &lt;aop:after pointcut-ref=&quot;embark&quot;
                method=&quot;afterQuest&quot;/&gt;
        &lt;/sop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/bean&gt;
</code></pre><hr>
<h2 id="12-빈은-담는-그릇-컨테이너"><a href="#1-2-빈은-담는-그릇-컨테이너" class="headerlink" title="1.2 빈은 담는 그릇, 컨테이너"></a>1.2 빈은 담는 그릇, 컨테이너</h2><p>스프링 기반 애플리케이션은 spring container 안에서 객체가 태어나고, 자라고, 소멸한다. 그래서 spring container는 객체를 생성하고, 엮어주고, 이들의 전체 생명주기를 관리한다.</p>
<p>–</p>
<h3 id="12-1"><a href="#1-2-1" class="headerlink" title="1.2-1"></a>1.2-1</h3><p>스프링에는 여러 컨테이너 구현체가 존재하며, 이들은 크게 두 가지로 분류된다.</p>
<ol>
<li>빈 팩토리(org.springframework.beans.factory.BeanFactory)<ul>
<li>인터페이스에 의해 정의</li>
<li>DI에 대한 기본적인 지원을 제공하는 가장 단순한 컨테이너</li>
</ul>
</li>
<li>애플리케이션 컨텍스트(org.springframework.context.ApplicationContext)<ul>
<li>인터페이스에 의해 정의</li>
<li>빈 팩토리를 확장해 애플리케이션 프레임워크 서비스를 제공하는 컨테이너</li>
</ul>
</li>
</ol>
<p>–</p>
<h3 id="121-애플리케이션-컨텍스트"><a href="#1-2-1-애플리케이션-컨텍스트" class="headerlink" title="1.2.1 애플리케이션 컨텍스트"></a>1.2.1 애플리케이션 컨텍스트</h3><p>애플리케이션의 설정을 제공하기 위한 중앙 인터페이스로, 실행중일땐 읽기만 가능하지만, 실행이 지원되면 리로드될 수 있다.</p>
<ul>
<li>AnnotationConfigApplicationContext<br>  <small>하나 이상의 자바 기반 설정 클래스에서 스코프 애플리케이션 컨텍스트를 로드</small></li>
<li>AnnotationConfigWebApplicationContext<br>  <small>하나 이상의 자바 기반 설정 클래스에서 스프링 웹 애플리케이션 컨텍스트를 로드</small></li>
<li>ClassPathXmlApplicationContext<br>  <small>클래스패스에 위치한 xml 파일에서 컨텍스트 정의 내용을 로드</small></li>
<li>FileSystemXmlApplicationContext<br>  <small>파일 경로로 지정된 xml 파일에서 컨텍스트 정의 내용 로드</small></li>
<li>XmlWebApplicationContext<br>  <small>웹 어플리케이션에 포함된 xml 파일에서 컨텍스트 정의 내용 로드</small></li>
</ul>
<p>–</p>
<h3 id="122-빈의-생명주기"><a href="#1-2-2-빈의-생명주기" class="headerlink" title="1.2.2 빈의 생명주기"></a>1.2.2 빈의 생명주기</h3><center><img src="https://premaseem.files.wordpress.com/2013/02/spring-bean-lifecycle.png" style="border:0px; width:60%; height:60%"></center>

<p>–</p>
<h3 id="122-1-life-cycle"><a href="#1-2-2-1-life-cycle" class="headerlink" title="1.2.2-1 life-cycle"></a>1.2.2-1 life-cycle</h3><ol>
<li>스프링이 빈 인스턴스화</li>
<li>스프링이 값과 빈의 레퍼런스를 빈의 프로퍼티에 주입</li>
<li>빈이 BeanNameAware를 구현하면 스프링이 빈의 ID를 setBEanName()에 넘김</li>
<li>빈이 BeanFactoryAware를 구현하면 setBEanFactory() 호출하여 빈팩토리 자체를 넘김</li>
<li>빈이 ApplicationContextAware를 구현하면 스프링이 setApplicationContext()를 호출하고 둘러싼 애플리케이션컨텍스트에 대한 참조를 넘김</li>
<li>빈이 BeanPostProcessor 인터페이스를 구현하면 스프링은 postProcessBeforeInitialzation()을 호출</li>
</ol>
<p>–</p>
<h3 id="122-2-life-cycle"><a href="#1-2-2-2-life-cycle" class="headerlink" title="1.2.2-2 life-cycle"></a>1.2.2-2 life-cycle</h3><ol start="7"><br><li>빈이 InitialzingBean 인터페이스를 구현하면 스프링은 afterPropertiesSet() 호출, 빈이 init-method와 함께 선언됐으면 지정한 초기화 메소드가 호출</li><br><li>빈이 BeanPostProcessor를 구현하면 스프링은 postProcessAfterInitialization() 호출</li><br><li>이 상태가 되면 빈은 애플리케이션에서 사용될 준비가 된 것이며, 애플리케이션 컨텍스트가 소멸될 때까지 애플리케이션 컨텍스트에 남아 있다.</li><br><li>빈이 DisposableBean 인터페이스를 구현하면 스프링은 destroy()를 호출한다. 마찬가지고 빈이 destroy-method와 함께 선언됬으면 지정 메소드가 호출</li><br></ol>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;center&gt;&lt;br&gt;    &lt;h2 style=&quot;text-align: ce
    
    </summary>
    
      <category term="slide" scheme="https://wickso.me/categories/slide/"/>
    
    
      <category term="spring" scheme="https://wickso.me/tags/spring/"/>
    
      <category term="java" scheme="https://wickso.me/tags/java/"/>
    
  </entry>
  
</feed>
